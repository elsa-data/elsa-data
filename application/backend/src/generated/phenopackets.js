// Common aliases
const $Reader = $protobuf.Reader,
  $Writer = $protobuf.Writer,
  $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const org = ($root.org = (() => {
  /**
   * Namespace org.
   * @exports org
   * @namespace
   */
  const org = {};

  org.phenopackets = (function () {
    /**
     * Namespace phenopackets.
     * @memberof org
     * @namespace
     */
    const phenopackets = {};

    phenopackets.schema = (function () {
      /**
       * Namespace schema.
       * @memberof org.phenopackets
       * @namespace
       */
      const schema = {};

      schema.v2 = (function () {
        /**
         * Namespace v2.
         * @memberof org.phenopackets.schema
         * @namespace
         */
        const v2 = {};

        v2.Phenopacket = (function () {
          /**
           * Properties of a Phenopacket.
           * @memberof org.phenopackets.schema.v2
           * @interface IPhenopacket
           * @property {string|null} [id] Phenopacket id
           * @property {org.phenopackets.schema.v2.core.IIndividual|null} [subject] Phenopacket subject
           * @property {Array.<org.phenopackets.schema.v2.core.IPhenotypicFeature>|null} [phenotypicFeatures] Phenopacket phenotypicFeatures
           * @property {Array.<org.phenopackets.schema.v2.core.IMeasurement>|null} [measurements] Phenopacket measurements
           * @property {Array.<org.phenopackets.schema.v2.core.IBiosample>|null} [biosamples] Phenopacket biosamples
           * @property {Array.<org.phenopackets.schema.v2.core.IInterpretation>|null} [interpretations] Phenopacket interpretations
           * @property {Array.<org.phenopackets.schema.v2.core.IDisease>|null} [diseases] Phenopacket diseases
           * @property {Array.<org.phenopackets.schema.v2.core.IMedicalAction>|null} [medicalActions] Phenopacket medicalActions
           * @property {Array.<org.phenopackets.schema.v2.core.IFile>|null} [files] Phenopacket files
           * @property {org.phenopackets.schema.v2.core.IMetaData|null} [metaData] Phenopacket metaData
           */

          /**
           * Constructs a new Phenopacket.
           * @memberof org.phenopackets.schema.v2
           * @classdesc Represents a Phenopacket.
           * @implements IPhenopacket
           * @constructor
           * @param {org.phenopackets.schema.v2.IPhenopacket=} [properties] Properties to set
           */
          function Phenopacket(properties) {
            this.phenotypicFeatures = [];
            this.measurements = [];
            this.biosamples = [];
            this.interpretations = [];
            this.diseases = [];
            this.medicalActions = [];
            this.files = [];
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Phenopacket id.
           * @member {string} id
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           */
          Phenopacket.prototype.id = "";

          /**
           * Phenopacket subject.
           * @member {org.phenopackets.schema.v2.core.IIndividual|null|undefined} subject
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           */
          Phenopacket.prototype.subject = null;

          /**
           * Phenopacket phenotypicFeatures.
           * @member {Array.<org.phenopackets.schema.v2.core.IPhenotypicFeature>} phenotypicFeatures
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           */
          Phenopacket.prototype.phenotypicFeatures = $util.emptyArray;

          /**
           * Phenopacket measurements.
           * @member {Array.<org.phenopackets.schema.v2.core.IMeasurement>} measurements
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           */
          Phenopacket.prototype.measurements = $util.emptyArray;

          /**
           * Phenopacket biosamples.
           * @member {Array.<org.phenopackets.schema.v2.core.IBiosample>} biosamples
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           */
          Phenopacket.prototype.biosamples = $util.emptyArray;

          /**
           * Phenopacket interpretations.
           * @member {Array.<org.phenopackets.schema.v2.core.IInterpretation>} interpretations
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           */
          Phenopacket.prototype.interpretations = $util.emptyArray;

          /**
           * Phenopacket diseases.
           * @member {Array.<org.phenopackets.schema.v2.core.IDisease>} diseases
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           */
          Phenopacket.prototype.diseases = $util.emptyArray;

          /**
           * Phenopacket medicalActions.
           * @member {Array.<org.phenopackets.schema.v2.core.IMedicalAction>} medicalActions
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           */
          Phenopacket.prototype.medicalActions = $util.emptyArray;

          /**
           * Phenopacket files.
           * @member {Array.<org.phenopackets.schema.v2.core.IFile>} files
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           */
          Phenopacket.prototype.files = $util.emptyArray;

          /**
           * Phenopacket metaData.
           * @member {org.phenopackets.schema.v2.core.IMetaData|null|undefined} metaData
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           */
          Phenopacket.prototype.metaData = null;

          /**
           * Creates a new Phenopacket instance using the specified properties.
           * @function create
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @static
           * @param {org.phenopackets.schema.v2.IPhenopacket=} [properties] Properties to set
           * @returns {org.phenopackets.schema.v2.Phenopacket} Phenopacket instance
           */
          Phenopacket.create = function create(properties) {
            return new Phenopacket(properties);
          };

          /**
           * Encodes the specified Phenopacket message. Does not implicitly {@link org.phenopackets.schema.v2.Phenopacket.verify|verify} messages.
           * @function encode
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @static
           * @param {org.phenopackets.schema.v2.IPhenopacket} message Phenopacket message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Phenopacket.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (
              message.subject != null &&
              Object.hasOwnProperty.call(message, "subject")
            )
              $root.org.phenopackets.schema.v2.core.Individual.encode(
                message.subject,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            if (
              message.phenotypicFeatures != null &&
              message.phenotypicFeatures.length
            )
              for (let i = 0; i < message.phenotypicFeatures.length; ++i)
                $root.org.phenopackets.schema.v2.core.PhenotypicFeature.encode(
                  message.phenotypicFeatures[i],
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
            if (message.measurements != null && message.measurements.length)
              for (let i = 0; i < message.measurements.length; ++i)
                $root.org.phenopackets.schema.v2.core.Measurement.encode(
                  message.measurements[i],
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
            if (message.biosamples != null && message.biosamples.length)
              for (let i = 0; i < message.biosamples.length; ++i)
                $root.org.phenopackets.schema.v2.core.Biosample.encode(
                  message.biosamples[i],
                  writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                ).ldelim();
            if (
              message.interpretations != null &&
              message.interpretations.length
            )
              for (let i = 0; i < message.interpretations.length; ++i)
                $root.org.phenopackets.schema.v2.core.Interpretation.encode(
                  message.interpretations[i],
                  writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
                ).ldelim();
            if (message.diseases != null && message.diseases.length)
              for (let i = 0; i < message.diseases.length; ++i)
                $root.org.phenopackets.schema.v2.core.Disease.encode(
                  message.diseases[i],
                  writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
                ).ldelim();
            if (message.medicalActions != null && message.medicalActions.length)
              for (let i = 0; i < message.medicalActions.length; ++i)
                $root.org.phenopackets.schema.v2.core.MedicalAction.encode(
                  message.medicalActions[i],
                  writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
                ).ldelim();
            if (message.files != null && message.files.length)
              for (let i = 0; i < message.files.length; ++i)
                $root.org.phenopackets.schema.v2.core.File.encode(
                  message.files[i],
                  writer.uint32(/* id 10, wireType 2 =*/ 82).fork(),
                ).ldelim();
            if (
              message.metaData != null &&
              Object.hasOwnProperty.call(message, "metaData")
            )
              $root.org.phenopackets.schema.v2.core.MetaData.encode(
                message.metaData,
                writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified Phenopacket message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.Phenopacket.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @static
           * @param {org.phenopackets.schema.v2.IPhenopacket} message Phenopacket message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Phenopacket.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Phenopacket message from the specified reader or buffer.
           * @function decode
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.phenopackets.schema.v2.Phenopacket} Phenopacket
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Phenopacket.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.phenopackets.schema.v2.Phenopacket();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.id = reader.string();
                  break;
                }
                case 2: {
                  message.subject =
                    $root.org.phenopackets.schema.v2.core.Individual.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 3: {
                  if (
                    !(
                      message.phenotypicFeatures &&
                      message.phenotypicFeatures.length
                    )
                  )
                    message.phenotypicFeatures = [];
                  message.phenotypicFeatures.push(
                    $root.org.phenopackets.schema.v2.core.PhenotypicFeature.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 4: {
                  if (!(message.measurements && message.measurements.length))
                    message.measurements = [];
                  message.measurements.push(
                    $root.org.phenopackets.schema.v2.core.Measurement.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 5: {
                  if (!(message.biosamples && message.biosamples.length))
                    message.biosamples = [];
                  message.biosamples.push(
                    $root.org.phenopackets.schema.v2.core.Biosample.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 6: {
                  if (
                    !(message.interpretations && message.interpretations.length)
                  )
                    message.interpretations = [];
                  message.interpretations.push(
                    $root.org.phenopackets.schema.v2.core.Interpretation.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 7: {
                  if (!(message.diseases && message.diseases.length))
                    message.diseases = [];
                  message.diseases.push(
                    $root.org.phenopackets.schema.v2.core.Disease.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 9: {
                  if (
                    !(message.medicalActions && message.medicalActions.length)
                  )
                    message.medicalActions = [];
                  message.medicalActions.push(
                    $root.org.phenopackets.schema.v2.core.MedicalAction.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 10: {
                  if (!(message.files && message.files.length))
                    message.files = [];
                  message.files.push(
                    $root.org.phenopackets.schema.v2.core.File.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 11: {
                  message.metaData =
                    $root.org.phenopackets.schema.v2.core.MetaData.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Phenopacket message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.phenopackets.schema.v2.Phenopacket} Phenopacket
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Phenopacket.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Phenopacket message.
           * @function verify
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Phenopacket.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
              if (!$util.isString(message.id)) return "id: string expected";
            if (message.subject != null && message.hasOwnProperty("subject")) {
              let error =
                $root.org.phenopackets.schema.v2.core.Individual.verify(
                  message.subject,
                );
              if (error) return "subject." + error;
            }
            if (
              message.phenotypicFeatures != null &&
              message.hasOwnProperty("phenotypicFeatures")
            ) {
              if (!Array.isArray(message.phenotypicFeatures))
                return "phenotypicFeatures: array expected";
              for (let i = 0; i < message.phenotypicFeatures.length; ++i) {
                let error =
                  $root.org.phenopackets.schema.v2.core.PhenotypicFeature.verify(
                    message.phenotypicFeatures[i],
                  );
                if (error) return "phenotypicFeatures." + error;
              }
            }
            if (
              message.measurements != null &&
              message.hasOwnProperty("measurements")
            ) {
              if (!Array.isArray(message.measurements))
                return "measurements: array expected";
              for (let i = 0; i < message.measurements.length; ++i) {
                let error =
                  $root.org.phenopackets.schema.v2.core.Measurement.verify(
                    message.measurements[i],
                  );
                if (error) return "measurements." + error;
              }
            }
            if (
              message.biosamples != null &&
              message.hasOwnProperty("biosamples")
            ) {
              if (!Array.isArray(message.biosamples))
                return "biosamples: array expected";
              for (let i = 0; i < message.biosamples.length; ++i) {
                let error =
                  $root.org.phenopackets.schema.v2.core.Biosample.verify(
                    message.biosamples[i],
                  );
                if (error) return "biosamples." + error;
              }
            }
            if (
              message.interpretations != null &&
              message.hasOwnProperty("interpretations")
            ) {
              if (!Array.isArray(message.interpretations))
                return "interpretations: array expected";
              for (let i = 0; i < message.interpretations.length; ++i) {
                let error =
                  $root.org.phenopackets.schema.v2.core.Interpretation.verify(
                    message.interpretations[i],
                  );
                if (error) return "interpretations." + error;
              }
            }
            if (
              message.diseases != null &&
              message.hasOwnProperty("diseases")
            ) {
              if (!Array.isArray(message.diseases))
                return "diseases: array expected";
              for (let i = 0; i < message.diseases.length; ++i) {
                let error =
                  $root.org.phenopackets.schema.v2.core.Disease.verify(
                    message.diseases[i],
                  );
                if (error) return "diseases." + error;
              }
            }
            if (
              message.medicalActions != null &&
              message.hasOwnProperty("medicalActions")
            ) {
              if (!Array.isArray(message.medicalActions))
                return "medicalActions: array expected";
              for (let i = 0; i < message.medicalActions.length; ++i) {
                let error =
                  $root.org.phenopackets.schema.v2.core.MedicalAction.verify(
                    message.medicalActions[i],
                  );
                if (error) return "medicalActions." + error;
              }
            }
            if (message.files != null && message.hasOwnProperty("files")) {
              if (!Array.isArray(message.files)) return "files: array expected";
              for (let i = 0; i < message.files.length; ++i) {
                let error = $root.org.phenopackets.schema.v2.core.File.verify(
                  message.files[i],
                );
                if (error) return "files." + error;
              }
            }
            if (
              message.metaData != null &&
              message.hasOwnProperty("metaData")
            ) {
              let error = $root.org.phenopackets.schema.v2.core.MetaData.verify(
                message.metaData,
              );
              if (error) return "metaData." + error;
            }
            return null;
          };

          /**
           * Creates a Phenopacket message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.phenopackets.schema.v2.Phenopacket} Phenopacket
           */
          Phenopacket.fromObject = function fromObject(object) {
            if (object instanceof $root.org.phenopackets.schema.v2.Phenopacket)
              return object;
            let message = new $root.org.phenopackets.schema.v2.Phenopacket();
            if (object.id != null) message.id = String(object.id);
            if (object.subject != null) {
              if (typeof object.subject !== "object")
                throw TypeError(
                  ".org.phenopackets.schema.v2.Phenopacket.subject: object expected",
                );
              message.subject =
                $root.org.phenopackets.schema.v2.core.Individual.fromObject(
                  object.subject,
                );
            }
            if (object.phenotypicFeatures) {
              if (!Array.isArray(object.phenotypicFeatures))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Phenopacket.phenotypicFeatures: array expected",
                );
              message.phenotypicFeatures = [];
              for (let i = 0; i < object.phenotypicFeatures.length; ++i) {
                if (typeof object.phenotypicFeatures[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Phenopacket.phenotypicFeatures: object expected",
                  );
                message.phenotypicFeatures[i] =
                  $root.org.phenopackets.schema.v2.core.PhenotypicFeature.fromObject(
                    object.phenotypicFeatures[i],
                  );
              }
            }
            if (object.measurements) {
              if (!Array.isArray(object.measurements))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Phenopacket.measurements: array expected",
                );
              message.measurements = [];
              for (let i = 0; i < object.measurements.length; ++i) {
                if (typeof object.measurements[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Phenopacket.measurements: object expected",
                  );
                message.measurements[i] =
                  $root.org.phenopackets.schema.v2.core.Measurement.fromObject(
                    object.measurements[i],
                  );
              }
            }
            if (object.biosamples) {
              if (!Array.isArray(object.biosamples))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Phenopacket.biosamples: array expected",
                );
              message.biosamples = [];
              for (let i = 0; i < object.biosamples.length; ++i) {
                if (typeof object.biosamples[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Phenopacket.biosamples: object expected",
                  );
                message.biosamples[i] =
                  $root.org.phenopackets.schema.v2.core.Biosample.fromObject(
                    object.biosamples[i],
                  );
              }
            }
            if (object.interpretations) {
              if (!Array.isArray(object.interpretations))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Phenopacket.interpretations: array expected",
                );
              message.interpretations = [];
              for (let i = 0; i < object.interpretations.length; ++i) {
                if (typeof object.interpretations[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Phenopacket.interpretations: object expected",
                  );
                message.interpretations[i] =
                  $root.org.phenopackets.schema.v2.core.Interpretation.fromObject(
                    object.interpretations[i],
                  );
              }
            }
            if (object.diseases) {
              if (!Array.isArray(object.diseases))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Phenopacket.diseases: array expected",
                );
              message.diseases = [];
              for (let i = 0; i < object.diseases.length; ++i) {
                if (typeof object.diseases[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Phenopacket.diseases: object expected",
                  );
                message.diseases[i] =
                  $root.org.phenopackets.schema.v2.core.Disease.fromObject(
                    object.diseases[i],
                  );
              }
            }
            if (object.medicalActions) {
              if (!Array.isArray(object.medicalActions))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Phenopacket.medicalActions: array expected",
                );
              message.medicalActions = [];
              for (let i = 0; i < object.medicalActions.length; ++i) {
                if (typeof object.medicalActions[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Phenopacket.medicalActions: object expected",
                  );
                message.medicalActions[i] =
                  $root.org.phenopackets.schema.v2.core.MedicalAction.fromObject(
                    object.medicalActions[i],
                  );
              }
            }
            if (object.files) {
              if (!Array.isArray(object.files))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Phenopacket.files: array expected",
                );
              message.files = [];
              for (let i = 0; i < object.files.length; ++i) {
                if (typeof object.files[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Phenopacket.files: object expected",
                  );
                message.files[i] =
                  $root.org.phenopackets.schema.v2.core.File.fromObject(
                    object.files[i],
                  );
              }
            }
            if (object.metaData != null) {
              if (typeof object.metaData !== "object")
                throw TypeError(
                  ".org.phenopackets.schema.v2.Phenopacket.metaData: object expected",
                );
              message.metaData =
                $root.org.phenopackets.schema.v2.core.MetaData.fromObject(
                  object.metaData,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a Phenopacket message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @static
           * @param {org.phenopackets.schema.v2.Phenopacket} message Phenopacket
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Phenopacket.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.arrays || options.defaults) {
              object.phenotypicFeatures = [];
              object.measurements = [];
              object.biosamples = [];
              object.interpretations = [];
              object.diseases = [];
              object.medicalActions = [];
              object.files = [];
            }
            if (options.defaults) {
              object.id = "";
              object.subject = null;
              object.metaData = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.subject != null && message.hasOwnProperty("subject"))
              object.subject =
                $root.org.phenopackets.schema.v2.core.Individual.toObject(
                  message.subject,
                  options,
                );
            if (
              message.phenotypicFeatures &&
              message.phenotypicFeatures.length
            ) {
              object.phenotypicFeatures = [];
              for (let j = 0; j < message.phenotypicFeatures.length; ++j)
                object.phenotypicFeatures[j] =
                  $root.org.phenopackets.schema.v2.core.PhenotypicFeature.toObject(
                    message.phenotypicFeatures[j],
                    options,
                  );
            }
            if (message.measurements && message.measurements.length) {
              object.measurements = [];
              for (let j = 0; j < message.measurements.length; ++j)
                object.measurements[j] =
                  $root.org.phenopackets.schema.v2.core.Measurement.toObject(
                    message.measurements[j],
                    options,
                  );
            }
            if (message.biosamples && message.biosamples.length) {
              object.biosamples = [];
              for (let j = 0; j < message.biosamples.length; ++j)
                object.biosamples[j] =
                  $root.org.phenopackets.schema.v2.core.Biosample.toObject(
                    message.biosamples[j],
                    options,
                  );
            }
            if (message.interpretations && message.interpretations.length) {
              object.interpretations = [];
              for (let j = 0; j < message.interpretations.length; ++j)
                object.interpretations[j] =
                  $root.org.phenopackets.schema.v2.core.Interpretation.toObject(
                    message.interpretations[j],
                    options,
                  );
            }
            if (message.diseases && message.diseases.length) {
              object.diseases = [];
              for (let j = 0; j < message.diseases.length; ++j)
                object.diseases[j] =
                  $root.org.phenopackets.schema.v2.core.Disease.toObject(
                    message.diseases[j],
                    options,
                  );
            }
            if (message.medicalActions && message.medicalActions.length) {
              object.medicalActions = [];
              for (let j = 0; j < message.medicalActions.length; ++j)
                object.medicalActions[j] =
                  $root.org.phenopackets.schema.v2.core.MedicalAction.toObject(
                    message.medicalActions[j],
                    options,
                  );
            }
            if (message.files && message.files.length) {
              object.files = [];
              for (let j = 0; j < message.files.length; ++j)
                object.files[j] =
                  $root.org.phenopackets.schema.v2.core.File.toObject(
                    message.files[j],
                    options,
                  );
            }
            if (message.metaData != null && message.hasOwnProperty("metaData"))
              object.metaData =
                $root.org.phenopackets.schema.v2.core.MetaData.toObject(
                  message.metaData,
                  options,
                );
            return object;
          };

          /**
           * Converts this Phenopacket to JSON.
           * @function toJSON
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Phenopacket.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Phenopacket
           * @function getTypeUrl
           * @memberof org.phenopackets.schema.v2.Phenopacket
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Phenopacket.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.phenopackets.schema.v2.Phenopacket";
          };

          return Phenopacket;
        })();

        v2.Family = (function () {
          /**
           * Properties of a Family.
           * @memberof org.phenopackets.schema.v2
           * @interface IFamily
           * @property {string|null} [id] Family id
           * @property {org.phenopackets.schema.v2.IPhenopacket|null} [proband] Family proband
           * @property {Array.<org.phenopackets.schema.v2.IPhenopacket>|null} [relatives] Family relatives
           * @property {boolean|null} [consanguinousParents] Family consanguinousParents
           * @property {org.phenopackets.schema.v2.core.IPedigree|null} [pedigree] Family pedigree
           * @property {Array.<org.phenopackets.schema.v2.core.IFile>|null} [files] Family files
           * @property {org.phenopackets.schema.v2.core.IMetaData|null} [metaData] Family metaData
           */

          /**
           * Constructs a new Family.
           * @memberof org.phenopackets.schema.v2
           * @classdesc Represents a Family.
           * @implements IFamily
           * @constructor
           * @param {org.phenopackets.schema.v2.IFamily=} [properties] Properties to set
           */
          function Family(properties) {
            this.relatives = [];
            this.files = [];
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Family id.
           * @member {string} id
           * @memberof org.phenopackets.schema.v2.Family
           * @instance
           */
          Family.prototype.id = "";

          /**
           * Family proband.
           * @member {org.phenopackets.schema.v2.IPhenopacket|null|undefined} proband
           * @memberof org.phenopackets.schema.v2.Family
           * @instance
           */
          Family.prototype.proband = null;

          /**
           * Family relatives.
           * @member {Array.<org.phenopackets.schema.v2.IPhenopacket>} relatives
           * @memberof org.phenopackets.schema.v2.Family
           * @instance
           */
          Family.prototype.relatives = $util.emptyArray;

          /**
           * Family consanguinousParents.
           * @member {boolean} consanguinousParents
           * @memberof org.phenopackets.schema.v2.Family
           * @instance
           */
          Family.prototype.consanguinousParents = false;

          /**
           * Family pedigree.
           * @member {org.phenopackets.schema.v2.core.IPedigree|null|undefined} pedigree
           * @memberof org.phenopackets.schema.v2.Family
           * @instance
           */
          Family.prototype.pedigree = null;

          /**
           * Family files.
           * @member {Array.<org.phenopackets.schema.v2.core.IFile>} files
           * @memberof org.phenopackets.schema.v2.Family
           * @instance
           */
          Family.prototype.files = $util.emptyArray;

          /**
           * Family metaData.
           * @member {org.phenopackets.schema.v2.core.IMetaData|null|undefined} metaData
           * @memberof org.phenopackets.schema.v2.Family
           * @instance
           */
          Family.prototype.metaData = null;

          /**
           * Creates a new Family instance using the specified properties.
           * @function create
           * @memberof org.phenopackets.schema.v2.Family
           * @static
           * @param {org.phenopackets.schema.v2.IFamily=} [properties] Properties to set
           * @returns {org.phenopackets.schema.v2.Family} Family instance
           */
          Family.create = function create(properties) {
            return new Family(properties);
          };

          /**
           * Encodes the specified Family message. Does not implicitly {@link org.phenopackets.schema.v2.Family.verify|verify} messages.
           * @function encode
           * @memberof org.phenopackets.schema.v2.Family
           * @static
           * @param {org.phenopackets.schema.v2.IFamily} message Family message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Family.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (
              message.proband != null &&
              Object.hasOwnProperty.call(message, "proband")
            )
              $root.org.phenopackets.schema.v2.Phenopacket.encode(
                message.proband,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            if (message.relatives != null && message.relatives.length)
              for (let i = 0; i < message.relatives.length; ++i)
                $root.org.phenopackets.schema.v2.Phenopacket.encode(
                  message.relatives[i],
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
            if (
              message.pedigree != null &&
              Object.hasOwnProperty.call(message, "pedigree")
            )
              $root.org.phenopackets.schema.v2.core.Pedigree.encode(
                message.pedigree,
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
            if (message.files != null && message.files.length)
              for (let i = 0; i < message.files.length; ++i)
                $root.org.phenopackets.schema.v2.core.File.encode(
                  message.files[i],
                  writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                ).ldelim();
            if (
              message.metaData != null &&
              Object.hasOwnProperty.call(message, "metaData")
            )
              $root.org.phenopackets.schema.v2.core.MetaData.encode(
                message.metaData,
                writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
              ).ldelim();
            if (
              message.consanguinousParents != null &&
              Object.hasOwnProperty.call(message, "consanguinousParents")
            )
              writer
                .uint32(/* id 7, wireType 0 =*/ 56)
                .bool(message.consanguinousParents);
            return writer;
          };

          /**
           * Encodes the specified Family message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.Family.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.phenopackets.schema.v2.Family
           * @static
           * @param {org.phenopackets.schema.v2.IFamily} message Family message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Family.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Family message from the specified reader or buffer.
           * @function decode
           * @memberof org.phenopackets.schema.v2.Family
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.phenopackets.schema.v2.Family} Family
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Family.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.phenopackets.schema.v2.Family();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.id = reader.string();
                  break;
                }
                case 2: {
                  message.proband =
                    $root.org.phenopackets.schema.v2.Phenopacket.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 3: {
                  if (!(message.relatives && message.relatives.length))
                    message.relatives = [];
                  message.relatives.push(
                    $root.org.phenopackets.schema.v2.Phenopacket.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 7: {
                  message.consanguinousParents = reader.bool();
                  break;
                }
                case 4: {
                  message.pedigree =
                    $root.org.phenopackets.schema.v2.core.Pedigree.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 5: {
                  if (!(message.files && message.files.length))
                    message.files = [];
                  message.files.push(
                    $root.org.phenopackets.schema.v2.core.File.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 6: {
                  message.metaData =
                    $root.org.phenopackets.schema.v2.core.MetaData.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Family message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.phenopackets.schema.v2.Family
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.phenopackets.schema.v2.Family} Family
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Family.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Family message.
           * @function verify
           * @memberof org.phenopackets.schema.v2.Family
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Family.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
              if (!$util.isString(message.id)) return "id: string expected";
            if (message.proband != null && message.hasOwnProperty("proband")) {
              let error = $root.org.phenopackets.schema.v2.Phenopacket.verify(
                message.proband,
              );
              if (error) return "proband." + error;
            }
            if (
              message.relatives != null &&
              message.hasOwnProperty("relatives")
            ) {
              if (!Array.isArray(message.relatives))
                return "relatives: array expected";
              for (let i = 0; i < message.relatives.length; ++i) {
                let error = $root.org.phenopackets.schema.v2.Phenopacket.verify(
                  message.relatives[i],
                );
                if (error) return "relatives." + error;
              }
            }
            if (
              message.consanguinousParents != null &&
              message.hasOwnProperty("consanguinousParents")
            )
              if (typeof message.consanguinousParents !== "boolean")
                return "consanguinousParents: boolean expected";
            if (
              message.pedigree != null &&
              message.hasOwnProperty("pedigree")
            ) {
              let error = $root.org.phenopackets.schema.v2.core.Pedigree.verify(
                message.pedigree,
              );
              if (error) return "pedigree." + error;
            }
            if (message.files != null && message.hasOwnProperty("files")) {
              if (!Array.isArray(message.files)) return "files: array expected";
              for (let i = 0; i < message.files.length; ++i) {
                let error = $root.org.phenopackets.schema.v2.core.File.verify(
                  message.files[i],
                );
                if (error) return "files." + error;
              }
            }
            if (
              message.metaData != null &&
              message.hasOwnProperty("metaData")
            ) {
              let error = $root.org.phenopackets.schema.v2.core.MetaData.verify(
                message.metaData,
              );
              if (error) return "metaData." + error;
            }
            return null;
          };

          /**
           * Creates a Family message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.phenopackets.schema.v2.Family
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.phenopackets.schema.v2.Family} Family
           */
          Family.fromObject = function fromObject(object) {
            if (object instanceof $root.org.phenopackets.schema.v2.Family)
              return object;
            let message = new $root.org.phenopackets.schema.v2.Family();
            if (object.id != null) message.id = String(object.id);
            if (object.proband != null) {
              if (typeof object.proband !== "object")
                throw TypeError(
                  ".org.phenopackets.schema.v2.Family.proband: object expected",
                );
              message.proband =
                $root.org.phenopackets.schema.v2.Phenopacket.fromObject(
                  object.proband,
                );
            }
            if (object.relatives) {
              if (!Array.isArray(object.relatives))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Family.relatives: array expected",
                );
              message.relatives = [];
              for (let i = 0; i < object.relatives.length; ++i) {
                if (typeof object.relatives[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Family.relatives: object expected",
                  );
                message.relatives[i] =
                  $root.org.phenopackets.schema.v2.Phenopacket.fromObject(
                    object.relatives[i],
                  );
              }
            }
            if (object.consanguinousParents != null)
              message.consanguinousParents = Boolean(
                object.consanguinousParents,
              );
            if (object.pedigree != null) {
              if (typeof object.pedigree !== "object")
                throw TypeError(
                  ".org.phenopackets.schema.v2.Family.pedigree: object expected",
                );
              message.pedigree =
                $root.org.phenopackets.schema.v2.core.Pedigree.fromObject(
                  object.pedigree,
                );
            }
            if (object.files) {
              if (!Array.isArray(object.files))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Family.files: array expected",
                );
              message.files = [];
              for (let i = 0; i < object.files.length; ++i) {
                if (typeof object.files[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Family.files: object expected",
                  );
                message.files[i] =
                  $root.org.phenopackets.schema.v2.core.File.fromObject(
                    object.files[i],
                  );
              }
            }
            if (object.metaData != null) {
              if (typeof object.metaData !== "object")
                throw TypeError(
                  ".org.phenopackets.schema.v2.Family.metaData: object expected",
                );
              message.metaData =
                $root.org.phenopackets.schema.v2.core.MetaData.fromObject(
                  object.metaData,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a Family message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.phenopackets.schema.v2.Family
           * @static
           * @param {org.phenopackets.schema.v2.Family} message Family
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Family.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.arrays || options.defaults) {
              object.relatives = [];
              object.files = [];
            }
            if (options.defaults) {
              object.id = "";
              object.proband = null;
              object.pedigree = null;
              object.metaData = null;
              object.consanguinousParents = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.proband != null && message.hasOwnProperty("proband"))
              object.proband =
                $root.org.phenopackets.schema.v2.Phenopacket.toObject(
                  message.proband,
                  options,
                );
            if (message.relatives && message.relatives.length) {
              object.relatives = [];
              for (let j = 0; j < message.relatives.length; ++j)
                object.relatives[j] =
                  $root.org.phenopackets.schema.v2.Phenopacket.toObject(
                    message.relatives[j],
                    options,
                  );
            }
            if (message.pedigree != null && message.hasOwnProperty("pedigree"))
              object.pedigree =
                $root.org.phenopackets.schema.v2.core.Pedigree.toObject(
                  message.pedigree,
                  options,
                );
            if (message.files && message.files.length) {
              object.files = [];
              for (let j = 0; j < message.files.length; ++j)
                object.files[j] =
                  $root.org.phenopackets.schema.v2.core.File.toObject(
                    message.files[j],
                    options,
                  );
            }
            if (message.metaData != null && message.hasOwnProperty("metaData"))
              object.metaData =
                $root.org.phenopackets.schema.v2.core.MetaData.toObject(
                  message.metaData,
                  options,
                );
            if (
              message.consanguinousParents != null &&
              message.hasOwnProperty("consanguinousParents")
            )
              object.consanguinousParents = message.consanguinousParents;
            return object;
          };

          /**
           * Converts this Family to JSON.
           * @function toJSON
           * @memberof org.phenopackets.schema.v2.Family
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Family.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Family
           * @function getTypeUrl
           * @memberof org.phenopackets.schema.v2.Family
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Family.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.phenopackets.schema.v2.Family";
          };

          return Family;
        })();

        v2.Cohort = (function () {
          /**
           * Properties of a Cohort.
           * @memberof org.phenopackets.schema.v2
           * @interface ICohort
           * @property {string|null} [id] Cohort id
           * @property {string|null} [description] Cohort description
           * @property {Array.<org.phenopackets.schema.v2.IPhenopacket>|null} [members] Cohort members
           * @property {Array.<org.phenopackets.schema.v2.core.IFile>|null} [files] Cohort files
           * @property {org.phenopackets.schema.v2.core.IMetaData|null} [metaData] Cohort metaData
           */

          /**
           * Constructs a new Cohort.
           * @memberof org.phenopackets.schema.v2
           * @classdesc Represents a Cohort.
           * @implements ICohort
           * @constructor
           * @param {org.phenopackets.schema.v2.ICohort=} [properties] Properties to set
           */
          function Cohort(properties) {
            this.members = [];
            this.files = [];
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Cohort id.
           * @member {string} id
           * @memberof org.phenopackets.schema.v2.Cohort
           * @instance
           */
          Cohort.prototype.id = "";

          /**
           * Cohort description.
           * @member {string} description
           * @memberof org.phenopackets.schema.v2.Cohort
           * @instance
           */
          Cohort.prototype.description = "";

          /**
           * Cohort members.
           * @member {Array.<org.phenopackets.schema.v2.IPhenopacket>} members
           * @memberof org.phenopackets.schema.v2.Cohort
           * @instance
           */
          Cohort.prototype.members = $util.emptyArray;

          /**
           * Cohort files.
           * @member {Array.<org.phenopackets.schema.v2.core.IFile>} files
           * @memberof org.phenopackets.schema.v2.Cohort
           * @instance
           */
          Cohort.prototype.files = $util.emptyArray;

          /**
           * Cohort metaData.
           * @member {org.phenopackets.schema.v2.core.IMetaData|null|undefined} metaData
           * @memberof org.phenopackets.schema.v2.Cohort
           * @instance
           */
          Cohort.prototype.metaData = null;

          /**
           * Creates a new Cohort instance using the specified properties.
           * @function create
           * @memberof org.phenopackets.schema.v2.Cohort
           * @static
           * @param {org.phenopackets.schema.v2.ICohort=} [properties] Properties to set
           * @returns {org.phenopackets.schema.v2.Cohort} Cohort instance
           */
          Cohort.create = function create(properties) {
            return new Cohort(properties);
          };

          /**
           * Encodes the specified Cohort message. Does not implicitly {@link org.phenopackets.schema.v2.Cohort.verify|verify} messages.
           * @function encode
           * @memberof org.phenopackets.schema.v2.Cohort
           * @static
           * @param {org.phenopackets.schema.v2.ICohort} message Cohort message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Cohort.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (
              message.description != null &&
              Object.hasOwnProperty.call(message, "description")
            )
              writer
                .uint32(/* id 2, wireType 2 =*/ 18)
                .string(message.description);
            if (message.members != null && message.members.length)
              for (let i = 0; i < message.members.length; ++i)
                $root.org.phenopackets.schema.v2.Phenopacket.encode(
                  message.members[i],
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
            if (message.files != null && message.files.length)
              for (let i = 0; i < message.files.length; ++i)
                $root.org.phenopackets.schema.v2.core.File.encode(
                  message.files[i],
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
            if (
              message.metaData != null &&
              Object.hasOwnProperty.call(message, "metaData")
            )
              $root.org.phenopackets.schema.v2.core.MetaData.encode(
                message.metaData,
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified Cohort message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.Cohort.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.phenopackets.schema.v2.Cohort
           * @static
           * @param {org.phenopackets.schema.v2.ICohort} message Cohort message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Cohort.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Cohort message from the specified reader or buffer.
           * @function decode
           * @memberof org.phenopackets.schema.v2.Cohort
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.phenopackets.schema.v2.Cohort} Cohort
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Cohort.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.phenopackets.schema.v2.Cohort();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.id = reader.string();
                  break;
                }
                case 2: {
                  message.description = reader.string();
                  break;
                }
                case 3: {
                  if (!(message.members && message.members.length))
                    message.members = [];
                  message.members.push(
                    $root.org.phenopackets.schema.v2.Phenopacket.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 4: {
                  if (!(message.files && message.files.length))
                    message.files = [];
                  message.files.push(
                    $root.org.phenopackets.schema.v2.core.File.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 5: {
                  message.metaData =
                    $root.org.phenopackets.schema.v2.core.MetaData.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Cohort message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.phenopackets.schema.v2.Cohort
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.phenopackets.schema.v2.Cohort} Cohort
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Cohort.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Cohort message.
           * @function verify
           * @memberof org.phenopackets.schema.v2.Cohort
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Cohort.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
              if (!$util.isString(message.id)) return "id: string expected";
            if (
              message.description != null &&
              message.hasOwnProperty("description")
            )
              if (!$util.isString(message.description))
                return "description: string expected";
            if (message.members != null && message.hasOwnProperty("members")) {
              if (!Array.isArray(message.members))
                return "members: array expected";
              for (let i = 0; i < message.members.length; ++i) {
                let error = $root.org.phenopackets.schema.v2.Phenopacket.verify(
                  message.members[i],
                );
                if (error) return "members." + error;
              }
            }
            if (message.files != null && message.hasOwnProperty("files")) {
              if (!Array.isArray(message.files)) return "files: array expected";
              for (let i = 0; i < message.files.length; ++i) {
                let error = $root.org.phenopackets.schema.v2.core.File.verify(
                  message.files[i],
                );
                if (error) return "files." + error;
              }
            }
            if (
              message.metaData != null &&
              message.hasOwnProperty("metaData")
            ) {
              let error = $root.org.phenopackets.schema.v2.core.MetaData.verify(
                message.metaData,
              );
              if (error) return "metaData." + error;
            }
            return null;
          };

          /**
           * Creates a Cohort message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.phenopackets.schema.v2.Cohort
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.phenopackets.schema.v2.Cohort} Cohort
           */
          Cohort.fromObject = function fromObject(object) {
            if (object instanceof $root.org.phenopackets.schema.v2.Cohort)
              return object;
            let message = new $root.org.phenopackets.schema.v2.Cohort();
            if (object.id != null) message.id = String(object.id);
            if (object.description != null)
              message.description = String(object.description);
            if (object.members) {
              if (!Array.isArray(object.members))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Cohort.members: array expected",
                );
              message.members = [];
              for (let i = 0; i < object.members.length; ++i) {
                if (typeof object.members[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Cohort.members: object expected",
                  );
                message.members[i] =
                  $root.org.phenopackets.schema.v2.Phenopacket.fromObject(
                    object.members[i],
                  );
              }
            }
            if (object.files) {
              if (!Array.isArray(object.files))
                throw TypeError(
                  ".org.phenopackets.schema.v2.Cohort.files: array expected",
                );
              message.files = [];
              for (let i = 0; i < object.files.length; ++i) {
                if (typeof object.files[i] !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.Cohort.files: object expected",
                  );
                message.files[i] =
                  $root.org.phenopackets.schema.v2.core.File.fromObject(
                    object.files[i],
                  );
              }
            }
            if (object.metaData != null) {
              if (typeof object.metaData !== "object")
                throw TypeError(
                  ".org.phenopackets.schema.v2.Cohort.metaData: object expected",
                );
              message.metaData =
                $root.org.phenopackets.schema.v2.core.MetaData.fromObject(
                  object.metaData,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a Cohort message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.phenopackets.schema.v2.Cohort
           * @static
           * @param {org.phenopackets.schema.v2.Cohort} message Cohort
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Cohort.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.arrays || options.defaults) {
              object.members = [];
              object.files = [];
            }
            if (options.defaults) {
              object.id = "";
              object.description = "";
              object.metaData = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (
              message.description != null &&
              message.hasOwnProperty("description")
            )
              object.description = message.description;
            if (message.members && message.members.length) {
              object.members = [];
              for (let j = 0; j < message.members.length; ++j)
                object.members[j] =
                  $root.org.phenopackets.schema.v2.Phenopacket.toObject(
                    message.members[j],
                    options,
                  );
            }
            if (message.files && message.files.length) {
              object.files = [];
              for (let j = 0; j < message.files.length; ++j)
                object.files[j] =
                  $root.org.phenopackets.schema.v2.core.File.toObject(
                    message.files[j],
                    options,
                  );
            }
            if (message.metaData != null && message.hasOwnProperty("metaData"))
              object.metaData =
                $root.org.phenopackets.schema.v2.core.MetaData.toObject(
                  message.metaData,
                  options,
                );
            return object;
          };

          /**
           * Converts this Cohort to JSON.
           * @function toJSON
           * @memberof org.phenopackets.schema.v2.Cohort
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Cohort.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Cohort
           * @function getTypeUrl
           * @memberof org.phenopackets.schema.v2.Cohort
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Cohort.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.phenopackets.schema.v2.Cohort";
          };

          return Cohort;
        })();

        v2.core = (function () {
          /**
           * Namespace core.
           * @memberof org.phenopackets.schema.v2
           * @namespace
           */
          const core = {};

          core.OntologyClass = (function () {
            /**
             * Properties of an OntologyClass.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IOntologyClass
             * @property {string|null} [id] OntologyClass id
             * @property {string|null} [label] OntologyClass label
             */

            /**
             * Constructs a new OntologyClass.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents an OntologyClass.
             * @implements IOntologyClass
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IOntologyClass=} [properties] Properties to set
             */
            function OntologyClass(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * OntologyClass id.
             * @member {string} id
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @instance
             */
            OntologyClass.prototype.id = "";

            /**
             * OntologyClass label.
             * @member {string} label
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @instance
             */
            OntologyClass.prototype.label = "";

            /**
             * Creates a new OntologyClass instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @static
             * @param {org.phenopackets.schema.v2.core.IOntologyClass=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.OntologyClass} OntologyClass instance
             */
            OntologyClass.create = function create(properties) {
              return new OntologyClass(properties);
            };

            /**
             * Encodes the specified OntologyClass message. Does not implicitly {@link org.phenopackets.schema.v2.core.OntologyClass.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @static
             * @param {org.phenopackets.schema.v2.core.IOntologyClass} message OntologyClass message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OntologyClass.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.id != null &&
                Object.hasOwnProperty.call(message, "id")
              )
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
              if (
                message.label != null &&
                Object.hasOwnProperty.call(message, "label")
              )
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.label);
              return writer;
            };

            /**
             * Encodes the specified OntologyClass message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.OntologyClass.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @static
             * @param {org.phenopackets.schema.v2.core.IOntologyClass} message OntologyClass message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OntologyClass.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OntologyClass message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.OntologyClass} OntologyClass
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OntologyClass.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.OntologyClass();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.id = reader.string();
                    break;
                  }
                  case 2: {
                    message.label = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes an OntologyClass message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.OntologyClass} OntologyClass
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OntologyClass.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OntologyClass message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OntologyClass.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id)) return "id: string expected";
              if (message.label != null && message.hasOwnProperty("label"))
                if (!$util.isString(message.label))
                  return "label: string expected";
              return null;
            };

            /**
             * Creates an OntologyClass message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.OntologyClass} OntologyClass
             */
            OntologyClass.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.OntologyClass
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.OntologyClass();
              if (object.id != null) message.id = String(object.id);
              if (object.label != null) message.label = String(object.label);
              return message;
            };

            /**
             * Creates a plain object from an OntologyClass message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @static
             * @param {org.phenopackets.schema.v2.core.OntologyClass} message OntologyClass
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OntologyClass.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.id = "";
                object.label = "";
              }
              if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
              if (message.label != null && message.hasOwnProperty("label"))
                object.label = message.label;
              return object;
            };

            /**
             * Converts this OntologyClass to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OntologyClass.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for OntologyClass
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.OntologyClass
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OntologyClass.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.OntologyClass"
              );
            };

            return OntologyClass;
          })();

          core.ExternalReference = (function () {
            /**
             * Properties of an ExternalReference.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IExternalReference
             * @property {string|null} [id] ExternalReference id
             * @property {string|null} [reference] ExternalReference reference
             * @property {string|null} [description] ExternalReference description
             */

            /**
             * Constructs a new ExternalReference.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents an ExternalReference.
             * @implements IExternalReference
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IExternalReference=} [properties] Properties to set
             */
            function ExternalReference(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExternalReference id.
             * @member {string} id
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @instance
             */
            ExternalReference.prototype.id = "";

            /**
             * ExternalReference reference.
             * @member {string} reference
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @instance
             */
            ExternalReference.prototype.reference = "";

            /**
             * ExternalReference description.
             * @member {string} description
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @instance
             */
            ExternalReference.prototype.description = "";

            /**
             * Creates a new ExternalReference instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @static
             * @param {org.phenopackets.schema.v2.core.IExternalReference=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.ExternalReference} ExternalReference instance
             */
            ExternalReference.create = function create(properties) {
              return new ExternalReference(properties);
            };

            /**
             * Encodes the specified ExternalReference message. Does not implicitly {@link org.phenopackets.schema.v2.core.ExternalReference.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @static
             * @param {org.phenopackets.schema.v2.core.IExternalReference} message ExternalReference message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExternalReference.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.id != null &&
                Object.hasOwnProperty.call(message, "id")
              )
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
              if (
                message.reference != null &&
                Object.hasOwnProperty.call(message, "reference")
              )
                writer
                  .uint32(/* id 2, wireType 2 =*/ 18)
                  .string(message.reference);
              if (
                message.description != null &&
                Object.hasOwnProperty.call(message, "description")
              )
                writer
                  .uint32(/* id 3, wireType 2 =*/ 26)
                  .string(message.description);
              return writer;
            };

            /**
             * Encodes the specified ExternalReference message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.ExternalReference.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @static
             * @param {org.phenopackets.schema.v2.core.IExternalReference} message ExternalReference message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExternalReference.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExternalReference message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.ExternalReference} ExternalReference
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExternalReference.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.ExternalReference();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.id = reader.string();
                    break;
                  }
                  case 2: {
                    message.reference = reader.string();
                    break;
                  }
                  case 3: {
                    message.description = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes an ExternalReference message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.ExternalReference} ExternalReference
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExternalReference.decodeDelimited = function decodeDelimited(
              reader,
            ) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExternalReference message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExternalReference.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id)) return "id: string expected";
              if (
                message.reference != null &&
                message.hasOwnProperty("reference")
              )
                if (!$util.isString(message.reference))
                  return "reference: string expected";
              if (
                message.description != null &&
                message.hasOwnProperty("description")
              )
                if (!$util.isString(message.description))
                  return "description: string expected";
              return null;
            };

            /**
             * Creates an ExternalReference message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.ExternalReference} ExternalReference
             */
            ExternalReference.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.ExternalReference
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.ExternalReference();
              if (object.id != null) message.id = String(object.id);
              if (object.reference != null)
                message.reference = String(object.reference);
              if (object.description != null)
                message.description = String(object.description);
              return message;
            };

            /**
             * Creates a plain object from an ExternalReference message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @static
             * @param {org.phenopackets.schema.v2.core.ExternalReference} message ExternalReference
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExternalReference.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.id = "";
                object.reference = "";
                object.description = "";
              }
              if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
              if (
                message.reference != null &&
                message.hasOwnProperty("reference")
              )
                object.reference = message.reference;
              if (
                message.description != null &&
                message.hasOwnProperty("description")
              )
                object.description = message.description;
              return object;
            };

            /**
             * Converts this ExternalReference to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExternalReference.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for ExternalReference
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.ExternalReference
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExternalReference.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix +
                "/org.phenopackets.schema.v2.core.ExternalReference"
              );
            };

            return ExternalReference;
          })();

          core.Evidence = (function () {
            /**
             * Properties of an Evidence.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IEvidence
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [evidenceCode] Evidence evidenceCode
             * @property {org.phenopackets.schema.v2.core.IExternalReference|null} [reference] Evidence reference
             */

            /**
             * Constructs a new Evidence.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents an Evidence.
             * @implements IEvidence
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IEvidence=} [properties] Properties to set
             */
            function Evidence(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Evidence evidenceCode.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} evidenceCode
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @instance
             */
            Evidence.prototype.evidenceCode = null;

            /**
             * Evidence reference.
             * @member {org.phenopackets.schema.v2.core.IExternalReference|null|undefined} reference
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @instance
             */
            Evidence.prototype.reference = null;

            /**
             * Creates a new Evidence instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @static
             * @param {org.phenopackets.schema.v2.core.IEvidence=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Evidence} Evidence instance
             */
            Evidence.create = function create(properties) {
              return new Evidence(properties);
            };

            /**
             * Encodes the specified Evidence message. Does not implicitly {@link org.phenopackets.schema.v2.core.Evidence.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @static
             * @param {org.phenopackets.schema.v2.core.IEvidence} message Evidence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Evidence.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.evidenceCode != null &&
                Object.hasOwnProperty.call(message, "evidenceCode")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.evidenceCode,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.reference != null &&
                Object.hasOwnProperty.call(message, "reference")
              )
                $root.org.phenopackets.schema.v2.core.ExternalReference.encode(
                  message.reference,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Evidence message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Evidence.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @static
             * @param {org.phenopackets.schema.v2.core.IEvidence} message Evidence message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Evidence.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Evidence message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Evidence} Evidence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Evidence.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Evidence();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.evidenceCode =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.reference =
                      $root.org.phenopackets.schema.v2.core.ExternalReference.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes an Evidence message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Evidence} Evidence
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Evidence.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Evidence message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Evidence.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.evidenceCode != null &&
                message.hasOwnProperty("evidenceCode")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.evidenceCode,
                  );
                if (error) return "evidenceCode." + error;
              }
              if (
                message.reference != null &&
                message.hasOwnProperty("reference")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.ExternalReference.verify(
                    message.reference,
                  );
                if (error) return "reference." + error;
              }
              return null;
            };

            /**
             * Creates an Evidence message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Evidence} Evidence
             */
            Evidence.fromObject = function fromObject(object) {
              if (
                object instanceof $root.org.phenopackets.schema.v2.core.Evidence
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Evidence();
              if (object.evidenceCode != null) {
                if (typeof object.evidenceCode !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Evidence.evidenceCode: object expected",
                  );
                message.evidenceCode =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.evidenceCode,
                  );
              }
              if (object.reference != null) {
                if (typeof object.reference !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Evidence.reference: object expected",
                  );
                message.reference =
                  $root.org.phenopackets.schema.v2.core.ExternalReference.fromObject(
                    object.reference,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from an Evidence message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @static
             * @param {org.phenopackets.schema.v2.core.Evidence} message Evidence
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Evidence.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.evidenceCode = null;
                object.reference = null;
              }
              if (
                message.evidenceCode != null &&
                message.hasOwnProperty("evidenceCode")
              )
                object.evidenceCode =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.evidenceCode,
                    options,
                  );
              if (
                message.reference != null &&
                message.hasOwnProperty("reference")
              )
                object.reference =
                  $root.org.phenopackets.schema.v2.core.ExternalReference.toObject(
                    message.reference,
                    options,
                  );
              return object;
            };

            /**
             * Converts this Evidence to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Evidence.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Evidence
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Evidence
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Evidence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.Evidence"
              );
            };

            return Evidence;
          })();

          core.Procedure = (function () {
            /**
             * Properties of a Procedure.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IProcedure
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [code] Procedure code
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [bodySite] Procedure bodySite
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [performed] Procedure performed
             */

            /**
             * Constructs a new Procedure.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a Procedure.
             * @implements IProcedure
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IProcedure=} [properties] Properties to set
             */
            function Procedure(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Procedure code.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} code
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @instance
             */
            Procedure.prototype.code = null;

            /**
             * Procedure bodySite.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} bodySite
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @instance
             */
            Procedure.prototype.bodySite = null;

            /**
             * Procedure performed.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} performed
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @instance
             */
            Procedure.prototype.performed = null;

            /**
             * Creates a new Procedure instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @static
             * @param {org.phenopackets.schema.v2.core.IProcedure=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Procedure} Procedure instance
             */
            Procedure.create = function create(properties) {
              return new Procedure(properties);
            };

            /**
             * Encodes the specified Procedure message. Does not implicitly {@link org.phenopackets.schema.v2.core.Procedure.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @static
             * @param {org.phenopackets.schema.v2.core.IProcedure} message Procedure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Procedure.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.code != null &&
                Object.hasOwnProperty.call(message, "code")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.code,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.bodySite != null &&
                Object.hasOwnProperty.call(message, "bodySite")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.bodySite,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (
                message.performed != null &&
                Object.hasOwnProperty.call(message, "performed")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.performed,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Procedure message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Procedure.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @static
             * @param {org.phenopackets.schema.v2.core.IProcedure} message Procedure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Procedure.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Procedure message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Procedure} Procedure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Procedure.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Procedure();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.code =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.bodySite =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 3: {
                    message.performed =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Procedure message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Procedure} Procedure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Procedure.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Procedure message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Procedure.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.code != null && message.hasOwnProperty("code")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.code,
                  );
                if (error) return "code." + error;
              }
              if (
                message.bodySite != null &&
                message.hasOwnProperty("bodySite")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.bodySite,
                  );
                if (error) return "bodySite." + error;
              }
              if (
                message.performed != null &&
                message.hasOwnProperty("performed")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.performed,
                  );
                if (error) return "performed." + error;
              }
              return null;
            };

            /**
             * Creates a Procedure message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Procedure} Procedure
             */
            Procedure.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.Procedure
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Procedure();
              if (object.code != null) {
                if (typeof object.code !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Procedure.code: object expected",
                  );
                message.code =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.code,
                  );
              }
              if (object.bodySite != null) {
                if (typeof object.bodySite !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Procedure.bodySite: object expected",
                  );
                message.bodySite =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.bodySite,
                  );
              }
              if (object.performed != null) {
                if (typeof object.performed !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Procedure.performed: object expected",
                  );
                message.performed =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.performed,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a Procedure message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @static
             * @param {org.phenopackets.schema.v2.core.Procedure} message Procedure
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Procedure.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.code = null;
                object.bodySite = null;
                object.performed = null;
              }
              if (message.code != null && message.hasOwnProperty("code"))
                object.code =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.code,
                    options,
                  );
              if (
                message.bodySite != null &&
                message.hasOwnProperty("bodySite")
              )
                object.bodySite =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.bodySite,
                    options,
                  );
              if (
                message.performed != null &&
                message.hasOwnProperty("performed")
              )
                object.performed =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.performed,
                    options,
                  );
              return object;
            };

            /**
             * Converts this Procedure to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Procedure.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Procedure
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Procedure
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Procedure.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.Procedure"
              );
            };

            return Procedure;
          })();

          core.GestationalAge = (function () {
            /**
             * Properties of a GestationalAge.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IGestationalAge
             * @property {number|null} [weeks] GestationalAge weeks
             * @property {number|null} [days] GestationalAge days
             */

            /**
             * Constructs a new GestationalAge.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a GestationalAge.
             * @implements IGestationalAge
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IGestationalAge=} [properties] Properties to set
             */
            function GestationalAge(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * GestationalAge weeks.
             * @member {number} weeks
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @instance
             */
            GestationalAge.prototype.weeks = 0;

            /**
             * GestationalAge days.
             * @member {number} days
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @instance
             */
            GestationalAge.prototype.days = 0;

            /**
             * Creates a new GestationalAge instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @static
             * @param {org.phenopackets.schema.v2.core.IGestationalAge=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.GestationalAge} GestationalAge instance
             */
            GestationalAge.create = function create(properties) {
              return new GestationalAge(properties);
            };

            /**
             * Encodes the specified GestationalAge message. Does not implicitly {@link org.phenopackets.schema.v2.core.GestationalAge.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @static
             * @param {org.phenopackets.schema.v2.core.IGestationalAge} message GestationalAge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GestationalAge.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.weeks != null &&
                Object.hasOwnProperty.call(message, "weeks")
              )
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.weeks);
              if (
                message.days != null &&
                Object.hasOwnProperty.call(message, "days")
              )
                writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.days);
              return writer;
            };

            /**
             * Encodes the specified GestationalAge message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.GestationalAge.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @static
             * @param {org.phenopackets.schema.v2.core.IGestationalAge} message GestationalAge message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GestationalAge.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GestationalAge message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.GestationalAge} GestationalAge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GestationalAge.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.GestationalAge();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.weeks = reader.int32();
                    break;
                  }
                  case 2: {
                    message.days = reader.int32();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a GestationalAge message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.GestationalAge} GestationalAge
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GestationalAge.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GestationalAge message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GestationalAge.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.weeks != null && message.hasOwnProperty("weeks"))
                if (!$util.isInteger(message.weeks))
                  return "weeks: integer expected";
              if (message.days != null && message.hasOwnProperty("days"))
                if (!$util.isInteger(message.days))
                  return "days: integer expected";
              return null;
            };

            /**
             * Creates a GestationalAge message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.GestationalAge} GestationalAge
             */
            GestationalAge.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.GestationalAge
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.GestationalAge();
              if (object.weeks != null) message.weeks = object.weeks | 0;
              if (object.days != null) message.days = object.days | 0;
              return message;
            };

            /**
             * Creates a plain object from a GestationalAge message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @static
             * @param {org.phenopackets.schema.v2.core.GestationalAge} message GestationalAge
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GestationalAge.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.weeks = 0;
                object.days = 0;
              }
              if (message.weeks != null && message.hasOwnProperty("weeks"))
                object.weeks = message.weeks;
              if (message.days != null && message.hasOwnProperty("days"))
                object.days = message.days;
              return object;
            };

            /**
             * Converts this GestationalAge to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GestationalAge.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for GestationalAge
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.GestationalAge
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GestationalAge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix +
                "/org.phenopackets.schema.v2.core.GestationalAge"
              );
            };

            return GestationalAge;
          })();

          core.Age = (function () {
            /**
             * Properties of an Age.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IAge
             * @property {string|null} [iso8601duration] Age iso8601duration
             */

            /**
             * Constructs a new Age.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents an Age.
             * @implements IAge
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IAge=} [properties] Properties to set
             */
            function Age(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Age iso8601duration.
             * @member {string} iso8601duration
             * @memberof org.phenopackets.schema.v2.core.Age
             * @instance
             */
            Age.prototype.iso8601duration = "";

            /**
             * Creates a new Age instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Age
             * @static
             * @param {org.phenopackets.schema.v2.core.IAge=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Age} Age instance
             */
            Age.create = function create(properties) {
              return new Age(properties);
            };

            /**
             * Encodes the specified Age message. Does not implicitly {@link org.phenopackets.schema.v2.core.Age.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Age
             * @static
             * @param {org.phenopackets.schema.v2.core.IAge} message Age message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Age.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.iso8601duration != null &&
                Object.hasOwnProperty.call(message, "iso8601duration")
              )
                writer
                  .uint32(/* id 1, wireType 2 =*/ 10)
                  .string(message.iso8601duration);
              return writer;
            };

            /**
             * Encodes the specified Age message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Age.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Age
             * @static
             * @param {org.phenopackets.schema.v2.core.IAge} message Age message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Age.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Age message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Age
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Age} Age
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Age.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Age();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.iso8601duration = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes an Age message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Age
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Age} Age
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Age.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Age message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Age
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Age.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.iso8601duration != null &&
                message.hasOwnProperty("iso8601duration")
              )
                if (!$util.isString(message.iso8601duration))
                  return "iso8601duration: string expected";
              return null;
            };

            /**
             * Creates an Age message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Age
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Age} Age
             */
            Age.fromObject = function fromObject(object) {
              if (object instanceof $root.org.phenopackets.schema.v2.core.Age)
                return object;
              let message = new $root.org.phenopackets.schema.v2.core.Age();
              if (object.iso8601duration != null)
                message.iso8601duration = String(object.iso8601duration);
              return message;
            };

            /**
             * Creates a plain object from an Age message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Age
             * @static
             * @param {org.phenopackets.schema.v2.core.Age} message Age
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Age.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) object.iso8601duration = "";
              if (
                message.iso8601duration != null &&
                message.hasOwnProperty("iso8601duration")
              )
                object.iso8601duration = message.iso8601duration;
              return object;
            };

            /**
             * Converts this Age to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Age
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Age.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Age
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Age
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Age.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/org.phenopackets.schema.v2.core.Age";
            };

            return Age;
          })();

          core.AgeRange = (function () {
            /**
             * Properties of an AgeRange.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IAgeRange
             * @property {org.phenopackets.schema.v2.core.IAge|null} [start] AgeRange start
             * @property {org.phenopackets.schema.v2.core.IAge|null} [end] AgeRange end
             */

            /**
             * Constructs a new AgeRange.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents an AgeRange.
             * @implements IAgeRange
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IAgeRange=} [properties] Properties to set
             */
            function AgeRange(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * AgeRange start.
             * @member {org.phenopackets.schema.v2.core.IAge|null|undefined} start
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @instance
             */
            AgeRange.prototype.start = null;

            /**
             * AgeRange end.
             * @member {org.phenopackets.schema.v2.core.IAge|null|undefined} end
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @instance
             */
            AgeRange.prototype.end = null;

            /**
             * Creates a new AgeRange instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @static
             * @param {org.phenopackets.schema.v2.core.IAgeRange=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.AgeRange} AgeRange instance
             */
            AgeRange.create = function create(properties) {
              return new AgeRange(properties);
            };

            /**
             * Encodes the specified AgeRange message. Does not implicitly {@link org.phenopackets.schema.v2.core.AgeRange.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @static
             * @param {org.phenopackets.schema.v2.core.IAgeRange} message AgeRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AgeRange.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.start != null &&
                Object.hasOwnProperty.call(message, "start")
              )
                $root.org.phenopackets.schema.v2.core.Age.encode(
                  message.start,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.end != null &&
                Object.hasOwnProperty.call(message, "end")
              )
                $root.org.phenopackets.schema.v2.core.Age.encode(
                  message.end,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified AgeRange message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.AgeRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @static
             * @param {org.phenopackets.schema.v2.core.IAgeRange} message AgeRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AgeRange.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AgeRange message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.AgeRange} AgeRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AgeRange.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.AgeRange();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.start =
                      $root.org.phenopackets.schema.v2.core.Age.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.end =
                      $root.org.phenopackets.schema.v2.core.Age.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes an AgeRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.AgeRange} AgeRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AgeRange.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AgeRange message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AgeRange.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.start != null && message.hasOwnProperty("start")) {
                let error = $root.org.phenopackets.schema.v2.core.Age.verify(
                  message.start,
                );
                if (error) return "start." + error;
              }
              if (message.end != null && message.hasOwnProperty("end")) {
                let error = $root.org.phenopackets.schema.v2.core.Age.verify(
                  message.end,
                );
                if (error) return "end." + error;
              }
              return null;
            };

            /**
             * Creates an AgeRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.AgeRange} AgeRange
             */
            AgeRange.fromObject = function fromObject(object) {
              if (
                object instanceof $root.org.phenopackets.schema.v2.core.AgeRange
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.AgeRange();
              if (object.start != null) {
                if (typeof object.start !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.AgeRange.start: object expected",
                  );
                message.start =
                  $root.org.phenopackets.schema.v2.core.Age.fromObject(
                    object.start,
                  );
              }
              if (object.end != null) {
                if (typeof object.end !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.AgeRange.end: object expected",
                  );
                message.end =
                  $root.org.phenopackets.schema.v2.core.Age.fromObject(
                    object.end,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from an AgeRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @static
             * @param {org.phenopackets.schema.v2.core.AgeRange} message AgeRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AgeRange.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.start = null;
                object.end = null;
              }
              if (message.start != null && message.hasOwnProperty("start"))
                object.start =
                  $root.org.phenopackets.schema.v2.core.Age.toObject(
                    message.start,
                    options,
                  );
              if (message.end != null && message.hasOwnProperty("end"))
                object.end = $root.org.phenopackets.schema.v2.core.Age.toObject(
                  message.end,
                  options,
                );
              return object;
            };

            /**
             * Converts this AgeRange to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AgeRange.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for AgeRange
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.AgeRange
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AgeRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.AgeRange"
              );
            };

            return AgeRange;
          })();

          core.TimeInterval = (function () {
            /**
             * Properties of a TimeInterval.
             * @memberof org.phenopackets.schema.v2.core
             * @interface ITimeInterval
             * @property {google.protobuf.ITimestamp|null} [start] TimeInterval start
             * @property {google.protobuf.ITimestamp|null} [end] TimeInterval end
             */

            /**
             * Constructs a new TimeInterval.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a TimeInterval.
             * @implements ITimeInterval
             * @constructor
             * @param {org.phenopackets.schema.v2.core.ITimeInterval=} [properties] Properties to set
             */
            function TimeInterval(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * TimeInterval start.
             * @member {google.protobuf.ITimestamp|null|undefined} start
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @instance
             */
            TimeInterval.prototype.start = null;

            /**
             * TimeInterval end.
             * @member {google.protobuf.ITimestamp|null|undefined} end
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @instance
             */
            TimeInterval.prototype.end = null;

            /**
             * Creates a new TimeInterval instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @static
             * @param {org.phenopackets.schema.v2.core.ITimeInterval=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.TimeInterval} TimeInterval instance
             */
            TimeInterval.create = function create(properties) {
              return new TimeInterval(properties);
            };

            /**
             * Encodes the specified TimeInterval message. Does not implicitly {@link org.phenopackets.schema.v2.core.TimeInterval.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @static
             * @param {org.phenopackets.schema.v2.core.ITimeInterval} message TimeInterval message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeInterval.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.start != null &&
                Object.hasOwnProperty.call(message, "start")
              )
                $root.google.protobuf.Timestamp.encode(
                  message.start,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.end != null &&
                Object.hasOwnProperty.call(message, "end")
              )
                $root.google.protobuf.Timestamp.encode(
                  message.end,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified TimeInterval message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.TimeInterval.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @static
             * @param {org.phenopackets.schema.v2.core.ITimeInterval} message TimeInterval message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeInterval.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TimeInterval message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.TimeInterval} TimeInterval
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeInterval.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.TimeInterval();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.start = $root.google.protobuf.Timestamp.decode(
                      reader,
                      reader.uint32(),
                    );
                    break;
                  }
                  case 2: {
                    message.end = $root.google.protobuf.Timestamp.decode(
                      reader,
                      reader.uint32(),
                    );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a TimeInterval message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.TimeInterval} TimeInterval
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeInterval.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TimeInterval message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TimeInterval.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.start != null && message.hasOwnProperty("start")) {
                let error = $root.google.protobuf.Timestamp.verify(
                  message.start,
                );
                if (error) return "start." + error;
              }
              if (message.end != null && message.hasOwnProperty("end")) {
                let error = $root.google.protobuf.Timestamp.verify(message.end);
                if (error) return "end." + error;
              }
              return null;
            };

            /**
             * Creates a TimeInterval message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.TimeInterval} TimeInterval
             */
            TimeInterval.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.TimeInterval
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.TimeInterval();
              if (object.start != null) {
                if (typeof object.start !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TimeInterval.start: object expected",
                  );
                message.start = $root.google.protobuf.Timestamp.fromObject(
                  object.start,
                );
              }
              if (object.end != null) {
                if (typeof object.end !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TimeInterval.end: object expected",
                  );
                message.end = $root.google.protobuf.Timestamp.fromObject(
                  object.end,
                );
              }
              return message;
            };

            /**
             * Creates a plain object from a TimeInterval message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @static
             * @param {org.phenopackets.schema.v2.core.TimeInterval} message TimeInterval
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TimeInterval.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.start = null;
                object.end = null;
              }
              if (message.start != null && message.hasOwnProperty("start"))
                object.start = $root.google.protobuf.Timestamp.toObject(
                  message.start,
                  options,
                );
              if (message.end != null && message.hasOwnProperty("end"))
                object.end = $root.google.protobuf.Timestamp.toObject(
                  message.end,
                  options,
                );
              return object;
            };

            /**
             * Converts this TimeInterval to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TimeInterval.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for TimeInterval
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.TimeInterval
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TimeInterval.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.TimeInterval"
              );
            };

            return TimeInterval;
          })();

          core.TimeElement = (function () {
            /**
             * Properties of a TimeElement.
             * @memberof org.phenopackets.schema.v2.core
             * @interface ITimeElement
             * @property {org.phenopackets.schema.v2.core.IGestationalAge|null} [gestationalAge] TimeElement gestationalAge
             * @property {org.phenopackets.schema.v2.core.IAge|null} [age] TimeElement age
             * @property {org.phenopackets.schema.v2.core.IAgeRange|null} [ageRange] TimeElement ageRange
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [ontologyClass] TimeElement ontologyClass
             * @property {google.protobuf.ITimestamp|null} [timestamp] TimeElement timestamp
             * @property {org.phenopackets.schema.v2.core.ITimeInterval|null} [interval] TimeElement interval
             */

            /**
             * Constructs a new TimeElement.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a TimeElement.
             * @implements ITimeElement
             * @constructor
             * @param {org.phenopackets.schema.v2.core.ITimeElement=} [properties] Properties to set
             */
            function TimeElement(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * TimeElement gestationalAge.
             * @member {org.phenopackets.schema.v2.core.IGestationalAge|null|undefined} gestationalAge
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @instance
             */
            TimeElement.prototype.gestationalAge = null;

            /**
             * TimeElement age.
             * @member {org.phenopackets.schema.v2.core.IAge|null|undefined} age
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @instance
             */
            TimeElement.prototype.age = null;

            /**
             * TimeElement ageRange.
             * @member {org.phenopackets.schema.v2.core.IAgeRange|null|undefined} ageRange
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @instance
             */
            TimeElement.prototype.ageRange = null;

            /**
             * TimeElement ontologyClass.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} ontologyClass
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @instance
             */
            TimeElement.prototype.ontologyClass = null;

            /**
             * TimeElement timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @instance
             */
            TimeElement.prototype.timestamp = null;

            /**
             * TimeElement interval.
             * @member {org.phenopackets.schema.v2.core.ITimeInterval|null|undefined} interval
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @instance
             */
            TimeElement.prototype.interval = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * TimeElement element.
             * @member {"gestationalAge"|"age"|"ageRange"|"ontologyClass"|"timestamp"|"interval"|undefined} element
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @instance
             */
            Object.defineProperty(TimeElement.prototype, "element", {
              get: $util.oneOfGetter(
                ($oneOfFields = [
                  "gestationalAge",
                  "age",
                  "ageRange",
                  "ontologyClass",
                  "timestamp",
                  "interval",
                ]),
              ),
              set: $util.oneOfSetter($oneOfFields),
            });

            /**
             * Creates a new TimeElement instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @static
             * @param {org.phenopackets.schema.v2.core.ITimeElement=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.TimeElement} TimeElement instance
             */
            TimeElement.create = function create(properties) {
              return new TimeElement(properties);
            };

            /**
             * Encodes the specified TimeElement message. Does not implicitly {@link org.phenopackets.schema.v2.core.TimeElement.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @static
             * @param {org.phenopackets.schema.v2.core.ITimeElement} message TimeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeElement.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.age != null &&
                Object.hasOwnProperty.call(message, "age")
              )
                $root.org.phenopackets.schema.v2.core.Age.encode(
                  message.age,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.ageRange != null &&
                Object.hasOwnProperty.call(message, "ageRange")
              )
                $root.org.phenopackets.schema.v2.core.AgeRange.encode(
                  message.ageRange,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (
                message.ontologyClass != null &&
                Object.hasOwnProperty.call(message, "ontologyClass")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.ontologyClass,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              if (
                message.timestamp != null &&
                Object.hasOwnProperty.call(message, "timestamp")
              )
                $root.google.protobuf.Timestamp.encode(
                  message.timestamp,
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
              if (
                message.interval != null &&
                Object.hasOwnProperty.call(message, "interval")
              )
                $root.org.phenopackets.schema.v2.core.TimeInterval.encode(
                  message.interval,
                  writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                ).ldelim();
              if (
                message.gestationalAge != null &&
                Object.hasOwnProperty.call(message, "gestationalAge")
              )
                $root.org.phenopackets.schema.v2.core.GestationalAge.encode(
                  message.gestationalAge,
                  writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified TimeElement message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.TimeElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @static
             * @param {org.phenopackets.schema.v2.core.ITimeElement} message TimeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TimeElement.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TimeElement message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.TimeElement} TimeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeElement.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.TimeElement();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 6: {
                    message.gestationalAge =
                      $root.org.phenopackets.schema.v2.core.GestationalAge.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 1: {
                    message.age =
                      $root.org.phenopackets.schema.v2.core.Age.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.ageRange =
                      $root.org.phenopackets.schema.v2.core.AgeRange.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 3: {
                    message.ontologyClass =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 4: {
                    message.timestamp = $root.google.protobuf.Timestamp.decode(
                      reader,
                      reader.uint32(),
                    );
                    break;
                  }
                  case 5: {
                    message.interval =
                      $root.org.phenopackets.schema.v2.core.TimeInterval.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a TimeElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.TimeElement} TimeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TimeElement.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TimeElement message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TimeElement.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              let properties = {};
              if (
                message.gestationalAge != null &&
                message.hasOwnProperty("gestationalAge")
              ) {
                properties.element = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.GestationalAge.verify(
                      message.gestationalAge,
                    );
                  if (error) return "gestationalAge." + error;
                }
              }
              if (message.age != null && message.hasOwnProperty("age")) {
                if (properties.element === 1) return "element: multiple values";
                properties.element = 1;
                {
                  let error = $root.org.phenopackets.schema.v2.core.Age.verify(
                    message.age,
                  );
                  if (error) return "age." + error;
                }
              }
              if (
                message.ageRange != null &&
                message.hasOwnProperty("ageRange")
              ) {
                if (properties.element === 1) return "element: multiple values";
                properties.element = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.AgeRange.verify(
                      message.ageRange,
                    );
                  if (error) return "ageRange." + error;
                }
              }
              if (
                message.ontologyClass != null &&
                message.hasOwnProperty("ontologyClass")
              ) {
                if (properties.element === 1) return "element: multiple values";
                properties.element = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                      message.ontologyClass,
                    );
                  if (error) return "ontologyClass." + error;
                }
              }
              if (
                message.timestamp != null &&
                message.hasOwnProperty("timestamp")
              ) {
                if (properties.element === 1) return "element: multiple values";
                properties.element = 1;
                {
                  let error = $root.google.protobuf.Timestamp.verify(
                    message.timestamp,
                  );
                  if (error) return "timestamp." + error;
                }
              }
              if (
                message.interval != null &&
                message.hasOwnProperty("interval")
              ) {
                if (properties.element === 1) return "element: multiple values";
                properties.element = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.TimeInterval.verify(
                      message.interval,
                    );
                  if (error) return "interval." + error;
                }
              }
              return null;
            };

            /**
             * Creates a TimeElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.TimeElement} TimeElement
             */
            TimeElement.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.TimeElement
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.TimeElement();
              if (object.gestationalAge != null) {
                if (typeof object.gestationalAge !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TimeElement.gestationalAge: object expected",
                  );
                message.gestationalAge =
                  $root.org.phenopackets.schema.v2.core.GestationalAge.fromObject(
                    object.gestationalAge,
                  );
              }
              if (object.age != null) {
                if (typeof object.age !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TimeElement.age: object expected",
                  );
                message.age =
                  $root.org.phenopackets.schema.v2.core.Age.fromObject(
                    object.age,
                  );
              }
              if (object.ageRange != null) {
                if (typeof object.ageRange !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TimeElement.ageRange: object expected",
                  );
                message.ageRange =
                  $root.org.phenopackets.schema.v2.core.AgeRange.fromObject(
                    object.ageRange,
                  );
              }
              if (object.ontologyClass != null) {
                if (typeof object.ontologyClass !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TimeElement.ontologyClass: object expected",
                  );
                message.ontologyClass =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.ontologyClass,
                  );
              }
              if (object.timestamp != null) {
                if (typeof object.timestamp !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TimeElement.timestamp: object expected",
                  );
                message.timestamp = $root.google.protobuf.Timestamp.fromObject(
                  object.timestamp,
                );
              }
              if (object.interval != null) {
                if (typeof object.interval !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TimeElement.interval: object expected",
                  );
                message.interval =
                  $root.org.phenopackets.schema.v2.core.TimeInterval.fromObject(
                    object.interval,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a TimeElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @static
             * @param {org.phenopackets.schema.v2.core.TimeElement} message TimeElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TimeElement.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (message.age != null && message.hasOwnProperty("age")) {
                object.age = $root.org.phenopackets.schema.v2.core.Age.toObject(
                  message.age,
                  options,
                );
                if (options.oneofs) object.element = "age";
              }
              if (
                message.ageRange != null &&
                message.hasOwnProperty("ageRange")
              ) {
                object.ageRange =
                  $root.org.phenopackets.schema.v2.core.AgeRange.toObject(
                    message.ageRange,
                    options,
                  );
                if (options.oneofs) object.element = "ageRange";
              }
              if (
                message.ontologyClass != null &&
                message.hasOwnProperty("ontologyClass")
              ) {
                object.ontologyClass =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.ontologyClass,
                    options,
                  );
                if (options.oneofs) object.element = "ontologyClass";
              }
              if (
                message.timestamp != null &&
                message.hasOwnProperty("timestamp")
              ) {
                object.timestamp = $root.google.protobuf.Timestamp.toObject(
                  message.timestamp,
                  options,
                );
                if (options.oneofs) object.element = "timestamp";
              }
              if (
                message.interval != null &&
                message.hasOwnProperty("interval")
              ) {
                object.interval =
                  $root.org.phenopackets.schema.v2.core.TimeInterval.toObject(
                    message.interval,
                    options,
                  );
                if (options.oneofs) object.element = "interval";
              }
              if (
                message.gestationalAge != null &&
                message.hasOwnProperty("gestationalAge")
              ) {
                object.gestationalAge =
                  $root.org.phenopackets.schema.v2.core.GestationalAge.toObject(
                    message.gestationalAge,
                    options,
                  );
                if (options.oneofs) object.element = "gestationalAge";
              }
              return object;
            };

            /**
             * Converts this TimeElement to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TimeElement.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for TimeElement
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.TimeElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TimeElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.TimeElement"
              );
            };

            return TimeElement;
          })();

          core.File = (function () {
            /**
             * Properties of a File.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IFile
             * @property {string|null} [uri] File uri
             * @property {Object.<string,string>|null} [individualToFileIdentifiers] File individualToFileIdentifiers
             * @property {Object.<string,string>|null} [fileAttributes] File fileAttributes
             */

            /**
             * Constructs a new File.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a File.
             * @implements IFile
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IFile=} [properties] Properties to set
             */
            function File(properties) {
              this.individualToFileIdentifiers = {};
              this.fileAttributes = {};
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * File uri.
             * @member {string} uri
             * @memberof org.phenopackets.schema.v2.core.File
             * @instance
             */
            File.prototype.uri = "";

            /**
             * File individualToFileIdentifiers.
             * @member {Object.<string,string>} individualToFileIdentifiers
             * @memberof org.phenopackets.schema.v2.core.File
             * @instance
             */
            File.prototype.individualToFileIdentifiers = $util.emptyObject;

            /**
             * File fileAttributes.
             * @member {Object.<string,string>} fileAttributes
             * @memberof org.phenopackets.schema.v2.core.File
             * @instance
             */
            File.prototype.fileAttributes = $util.emptyObject;

            /**
             * Creates a new File instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.File
             * @static
             * @param {org.phenopackets.schema.v2.core.IFile=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.File} File instance
             */
            File.create = function create(properties) {
              return new File(properties);
            };

            /**
             * Encodes the specified File message. Does not implicitly {@link org.phenopackets.schema.v2.core.File.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.File
             * @static
             * @param {org.phenopackets.schema.v2.core.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.uri != null &&
                Object.hasOwnProperty.call(message, "uri")
              )
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.uri);
              if (
                message.individualToFileIdentifiers != null &&
                Object.hasOwnProperty.call(
                  message,
                  "individualToFileIdentifiers",
                )
              )
                for (
                  let keys = Object.keys(message.individualToFileIdentifiers),
                    i = 0;
                  i < keys.length;
                  ++i
                )
                  writer
                    .uint32(/* id 2, wireType 2 =*/ 18)
                    .fork()
                    .uint32(/* id 1, wireType 2 =*/ 10)
                    .string(keys[i])
                    .uint32(/* id 2, wireType 2 =*/ 18)
                    .string(message.individualToFileIdentifiers[keys[i]])
                    .ldelim();
              if (
                message.fileAttributes != null &&
                Object.hasOwnProperty.call(message, "fileAttributes")
              )
                for (
                  let keys = Object.keys(message.fileAttributes), i = 0;
                  i < keys.length;
                  ++i
                )
                  writer
                    .uint32(/* id 3, wireType 2 =*/ 26)
                    .fork()
                    .uint32(/* id 1, wireType 2 =*/ 10)
                    .string(keys[i])
                    .uint32(/* id 2, wireType 2 =*/ 18)
                    .string(message.fileAttributes[keys[i]])
                    .ldelim();
              return writer;
            };

            /**
             * Encodes the specified File message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.File.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.File
             * @static
             * @param {org.phenopackets.schema.v2.core.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a File message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.File(),
                key,
                value;
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.uri = reader.string();
                    break;
                  }
                  case 2: {
                    if (
                      message.individualToFileIdentifiers === $util.emptyObject
                    )
                      message.individualToFileIdentifiers = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = "";
                    while (reader.pos < end2) {
                      let tag2 = reader.uint32();
                      switch (tag2 >>> 3) {
                        case 1:
                          key = reader.string();
                          break;
                        case 2:
                          value = reader.string();
                          break;
                        default:
                          reader.skipType(tag2 & 7);
                          break;
                      }
                    }
                    message.individualToFileIdentifiers[key] = value;
                    break;
                  }
                  case 3: {
                    if (message.fileAttributes === $util.emptyObject)
                      message.fileAttributes = {};
                    let end2 = reader.uint32() + reader.pos;
                    key = "";
                    value = "";
                    while (reader.pos < end2) {
                      let tag2 = reader.uint32();
                      switch (tag2 >>> 3) {
                        case 1:
                          key = reader.string();
                          break;
                        case 2:
                          value = reader.string();
                          break;
                        default:
                          reader.skipType(tag2 & 7);
                          break;
                      }
                    }
                    message.fileAttributes[key] = value;
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a File message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a File message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.File
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            File.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.uri != null && message.hasOwnProperty("uri"))
                if (!$util.isString(message.uri)) return "uri: string expected";
              if (
                message.individualToFileIdentifiers != null &&
                message.hasOwnProperty("individualToFileIdentifiers")
              ) {
                if (!$util.isObject(message.individualToFileIdentifiers))
                  return "individualToFileIdentifiers: object expected";
                let key = Object.keys(message.individualToFileIdentifiers);
                for (let i = 0; i < key.length; ++i)
                  if (
                    !$util.isString(message.individualToFileIdentifiers[key[i]])
                  )
                    return "individualToFileIdentifiers: string{k:string} expected";
              }
              if (
                message.fileAttributes != null &&
                message.hasOwnProperty("fileAttributes")
              ) {
                if (!$util.isObject(message.fileAttributes))
                  return "fileAttributes: object expected";
                let key = Object.keys(message.fileAttributes);
                for (let i = 0; i < key.length; ++i)
                  if (!$util.isString(message.fileAttributes[key[i]]))
                    return "fileAttributes: string{k:string} expected";
              }
              return null;
            };

            /**
             * Creates a File message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.File
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.File} File
             */
            File.fromObject = function fromObject(object) {
              if (object instanceof $root.org.phenopackets.schema.v2.core.File)
                return object;
              let message = new $root.org.phenopackets.schema.v2.core.File();
              if (object.uri != null) message.uri = String(object.uri);
              if (object.individualToFileIdentifiers) {
                if (typeof object.individualToFileIdentifiers !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.File.individualToFileIdentifiers: object expected",
                  );
                message.individualToFileIdentifiers = {};
                for (
                  let keys = Object.keys(object.individualToFileIdentifiers),
                    i = 0;
                  i < keys.length;
                  ++i
                )
                  message.individualToFileIdentifiers[keys[i]] = String(
                    object.individualToFileIdentifiers[keys[i]],
                  );
              }
              if (object.fileAttributes) {
                if (typeof object.fileAttributes !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.File.fileAttributes: object expected",
                  );
                message.fileAttributes = {};
                for (
                  let keys = Object.keys(object.fileAttributes), i = 0;
                  i < keys.length;
                  ++i
                )
                  message.fileAttributes[keys[i]] = String(
                    object.fileAttributes[keys[i]],
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a File message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.File
             * @static
             * @param {org.phenopackets.schema.v2.core.File} message File
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            File.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.objects || options.defaults) {
                object.individualToFileIdentifiers = {};
                object.fileAttributes = {};
              }
              if (options.defaults) object.uri = "";
              if (message.uri != null && message.hasOwnProperty("uri"))
                object.uri = message.uri;
              let keys2;
              if (
                message.individualToFileIdentifiers &&
                (keys2 = Object.keys(message.individualToFileIdentifiers))
                  .length
              ) {
                object.individualToFileIdentifiers = {};
                for (let j = 0; j < keys2.length; ++j)
                  object.individualToFileIdentifiers[keys2[j]] =
                    message.individualToFileIdentifiers[keys2[j]];
              }
              if (
                message.fileAttributes &&
                (keys2 = Object.keys(message.fileAttributes)).length
              ) {
                object.fileAttributes = {};
                for (let j = 0; j < keys2.length; ++j)
                  object.fileAttributes[keys2[j]] =
                    message.fileAttributes[keys2[j]];
              }
              return object;
            };

            /**
             * Converts this File to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.File
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            File.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for File
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.File
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            File.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/org.phenopackets.schema.v2.core.File";
            };

            return File;
          })();

          core.Biosample = (function () {
            /**
             * Properties of a Biosample.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IBiosample
             * @property {string|null} [id] Biosample id
             * @property {string|null} [individualId] Biosample individualId
             * @property {string|null} [derivedFromId] Biosample derivedFromId
             * @property {string|null} [description] Biosample description
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [sampledTissue] Biosample sampledTissue
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [sampleType] Biosample sampleType
             * @property {Array.<org.phenopackets.schema.v2.core.IPhenotypicFeature>|null} [phenotypicFeatures] Biosample phenotypicFeatures
             * @property {Array.<org.phenopackets.schema.v2.core.IMeasurement>|null} [measurements] Biosample measurements
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [taxonomy] Biosample taxonomy
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [timeOfCollection] Biosample timeOfCollection
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [histologicalDiagnosis] Biosample histologicalDiagnosis
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [tumorProgression] Biosample tumorProgression
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [tumorGrade] Biosample tumorGrade
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [pathologicalStage] Biosample pathologicalStage
             * @property {Array.<org.phenopackets.schema.v2.core.IOntologyClass>|null} [pathologicalTnmFinding] Biosample pathologicalTnmFinding
             * @property {Array.<org.phenopackets.schema.v2.core.IOntologyClass>|null} [diagnosticMarkers] Biosample diagnosticMarkers
             * @property {org.phenopackets.schema.v2.core.IProcedure|null} [procedure] Biosample procedure
             * @property {Array.<org.phenopackets.schema.v2.core.IFile>|null} [files] Biosample files
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [materialSample] Biosample materialSample
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [sampleProcessing] Biosample sampleProcessing
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [sampleStorage] Biosample sampleStorage
             */

            /**
             * Constructs a new Biosample.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a Biosample.
             * @implements IBiosample
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IBiosample=} [properties] Properties to set
             */
            function Biosample(properties) {
              this.phenotypicFeatures = [];
              this.measurements = [];
              this.pathologicalTnmFinding = [];
              this.diagnosticMarkers = [];
              this.files = [];
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Biosample id.
             * @member {string} id
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.id = "";

            /**
             * Biosample individualId.
             * @member {string} individualId
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.individualId = "";

            /**
             * Biosample derivedFromId.
             * @member {string} derivedFromId
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.derivedFromId = "";

            /**
             * Biosample description.
             * @member {string} description
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.description = "";

            /**
             * Biosample sampledTissue.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} sampledTissue
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.sampledTissue = null;

            /**
             * Biosample sampleType.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} sampleType
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.sampleType = null;

            /**
             * Biosample phenotypicFeatures.
             * @member {Array.<org.phenopackets.schema.v2.core.IPhenotypicFeature>} phenotypicFeatures
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.phenotypicFeatures = $util.emptyArray;

            /**
             * Biosample measurements.
             * @member {Array.<org.phenopackets.schema.v2.core.IMeasurement>} measurements
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.measurements = $util.emptyArray;

            /**
             * Biosample taxonomy.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} taxonomy
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.taxonomy = null;

            /**
             * Biosample timeOfCollection.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} timeOfCollection
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.timeOfCollection = null;

            /**
             * Biosample histologicalDiagnosis.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} histologicalDiagnosis
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.histologicalDiagnosis = null;

            /**
             * Biosample tumorProgression.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} tumorProgression
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.tumorProgression = null;

            /**
             * Biosample tumorGrade.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} tumorGrade
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.tumorGrade = null;

            /**
             * Biosample pathologicalStage.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} pathologicalStage
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.pathologicalStage = null;

            /**
             * Biosample pathologicalTnmFinding.
             * @member {Array.<org.phenopackets.schema.v2.core.IOntologyClass>} pathologicalTnmFinding
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.pathologicalTnmFinding = $util.emptyArray;

            /**
             * Biosample diagnosticMarkers.
             * @member {Array.<org.phenopackets.schema.v2.core.IOntologyClass>} diagnosticMarkers
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.diagnosticMarkers = $util.emptyArray;

            /**
             * Biosample procedure.
             * @member {org.phenopackets.schema.v2.core.IProcedure|null|undefined} procedure
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.procedure = null;

            /**
             * Biosample files.
             * @member {Array.<org.phenopackets.schema.v2.core.IFile>} files
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.files = $util.emptyArray;

            /**
             * Biosample materialSample.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} materialSample
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.materialSample = null;

            /**
             * Biosample sampleProcessing.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} sampleProcessing
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.sampleProcessing = null;

            /**
             * Biosample sampleStorage.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} sampleStorage
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             */
            Biosample.prototype.sampleStorage = null;

            /**
             * Creates a new Biosample instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @static
             * @param {org.phenopackets.schema.v2.core.IBiosample=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Biosample} Biosample instance
             */
            Biosample.create = function create(properties) {
              return new Biosample(properties);
            };

            /**
             * Encodes the specified Biosample message. Does not implicitly {@link org.phenopackets.schema.v2.core.Biosample.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @static
             * @param {org.phenopackets.schema.v2.core.IBiosample} message Biosample message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Biosample.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.id != null &&
                Object.hasOwnProperty.call(message, "id")
              )
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
              if (
                message.individualId != null &&
                Object.hasOwnProperty.call(message, "individualId")
              )
                writer
                  .uint32(/* id 2, wireType 2 =*/ 18)
                  .string(message.individualId);
              if (
                message.derivedFromId != null &&
                Object.hasOwnProperty.call(message, "derivedFromId")
              )
                writer
                  .uint32(/* id 3, wireType 2 =*/ 26)
                  .string(message.derivedFromId);
              if (
                message.description != null &&
                Object.hasOwnProperty.call(message, "description")
              )
                writer
                  .uint32(/* id 4, wireType 2 =*/ 34)
                  .string(message.description);
              if (
                message.sampledTissue != null &&
                Object.hasOwnProperty.call(message, "sampledTissue")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.sampledTissue,
                  writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                ).ldelim();
              if (
                message.sampleType != null &&
                Object.hasOwnProperty.call(message, "sampleType")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.sampleType,
                  writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
                ).ldelim();
              if (
                message.phenotypicFeatures != null &&
                message.phenotypicFeatures.length
              )
                for (let i = 0; i < message.phenotypicFeatures.length; ++i)
                  $root.org.phenopackets.schema.v2.core.PhenotypicFeature.encode(
                    message.phenotypicFeatures[i],
                    writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
                  ).ldelim();
              if (message.measurements != null && message.measurements.length)
                for (let i = 0; i < message.measurements.length; ++i)
                  $root.org.phenopackets.schema.v2.core.Measurement.encode(
                    message.measurements[i],
                    writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
                  ).ldelim();
              if (
                message.taxonomy != null &&
                Object.hasOwnProperty.call(message, "taxonomy")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.taxonomy,
                  writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
                ).ldelim();
              if (
                message.timeOfCollection != null &&
                Object.hasOwnProperty.call(message, "timeOfCollection")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.timeOfCollection,
                  writer.uint32(/* id 10, wireType 2 =*/ 82).fork(),
                ).ldelim();
              if (
                message.histologicalDiagnosis != null &&
                Object.hasOwnProperty.call(message, "histologicalDiagnosis")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.histologicalDiagnosis,
                  writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),
                ).ldelim();
              if (
                message.tumorProgression != null &&
                Object.hasOwnProperty.call(message, "tumorProgression")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.tumorProgression,
                  writer.uint32(/* id 12, wireType 2 =*/ 98).fork(),
                ).ldelim();
              if (
                message.tumorGrade != null &&
                Object.hasOwnProperty.call(message, "tumorGrade")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.tumorGrade,
                  writer.uint32(/* id 13, wireType 2 =*/ 106).fork(),
                ).ldelim();
              if (
                message.pathologicalStage != null &&
                Object.hasOwnProperty.call(message, "pathologicalStage")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.pathologicalStage,
                  writer.uint32(/* id 14, wireType 2 =*/ 114).fork(),
                ).ldelim();
              if (
                message.pathologicalTnmFinding != null &&
                message.pathologicalTnmFinding.length
              )
                for (let i = 0; i < message.pathologicalTnmFinding.length; ++i)
                  $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                    message.pathologicalTnmFinding[i],
                    writer.uint32(/* id 15, wireType 2 =*/ 122).fork(),
                  ).ldelim();
              if (
                message.diagnosticMarkers != null &&
                message.diagnosticMarkers.length
              )
                for (let i = 0; i < message.diagnosticMarkers.length; ++i)
                  $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                    message.diagnosticMarkers[i],
                    writer.uint32(/* id 16, wireType 2 =*/ 130).fork(),
                  ).ldelim();
              if (
                message.procedure != null &&
                Object.hasOwnProperty.call(message, "procedure")
              )
                $root.org.phenopackets.schema.v2.core.Procedure.encode(
                  message.procedure,
                  writer.uint32(/* id 17, wireType 2 =*/ 138).fork(),
                ).ldelim();
              if (message.files != null && message.files.length)
                for (let i = 0; i < message.files.length; ++i)
                  $root.org.phenopackets.schema.v2.core.File.encode(
                    message.files[i],
                    writer.uint32(/* id 18, wireType 2 =*/ 146).fork(),
                  ).ldelim();
              if (
                message.materialSample != null &&
                Object.hasOwnProperty.call(message, "materialSample")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.materialSample,
                  writer.uint32(/* id 19, wireType 2 =*/ 154).fork(),
                ).ldelim();
              if (
                message.sampleProcessing != null &&
                Object.hasOwnProperty.call(message, "sampleProcessing")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.sampleProcessing,
                  writer.uint32(/* id 20, wireType 2 =*/ 162).fork(),
                ).ldelim();
              if (
                message.sampleStorage != null &&
                Object.hasOwnProperty.call(message, "sampleStorage")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.sampleStorage,
                  writer.uint32(/* id 21, wireType 2 =*/ 170).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Biosample message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Biosample.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @static
             * @param {org.phenopackets.schema.v2.core.IBiosample} message Biosample message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Biosample.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Biosample message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Biosample} Biosample
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Biosample.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Biosample();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.id = reader.string();
                    break;
                  }
                  case 2: {
                    message.individualId = reader.string();
                    break;
                  }
                  case 3: {
                    message.derivedFromId = reader.string();
                    break;
                  }
                  case 4: {
                    message.description = reader.string();
                    break;
                  }
                  case 5: {
                    message.sampledTissue =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 6: {
                    message.sampleType =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 7: {
                    if (
                      !(
                        message.phenotypicFeatures &&
                        message.phenotypicFeatures.length
                      )
                    )
                      message.phenotypicFeatures = [];
                    message.phenotypicFeatures.push(
                      $root.org.phenopackets.schema.v2.core.PhenotypicFeature.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 8: {
                    if (!(message.measurements && message.measurements.length))
                      message.measurements = [];
                    message.measurements.push(
                      $root.org.phenopackets.schema.v2.core.Measurement.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 9: {
                    message.taxonomy =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 10: {
                    message.timeOfCollection =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 11: {
                    message.histologicalDiagnosis =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 12: {
                    message.tumorProgression =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 13: {
                    message.tumorGrade =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 14: {
                    message.pathologicalStage =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 15: {
                    if (
                      !(
                        message.pathologicalTnmFinding &&
                        message.pathologicalTnmFinding.length
                      )
                    )
                      message.pathologicalTnmFinding = [];
                    message.pathologicalTnmFinding.push(
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 16: {
                    if (
                      !(
                        message.diagnosticMarkers &&
                        message.diagnosticMarkers.length
                      )
                    )
                      message.diagnosticMarkers = [];
                    message.diagnosticMarkers.push(
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 17: {
                    message.procedure =
                      $root.org.phenopackets.schema.v2.core.Procedure.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 18: {
                    if (!(message.files && message.files.length))
                      message.files = [];
                    message.files.push(
                      $root.org.phenopackets.schema.v2.core.File.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 19: {
                    message.materialSample =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 20: {
                    message.sampleProcessing =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 21: {
                    message.sampleStorage =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Biosample message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Biosample} Biosample
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Biosample.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Biosample message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Biosample.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id)) return "id: string expected";
              if (
                message.individualId != null &&
                message.hasOwnProperty("individualId")
              )
                if (!$util.isString(message.individualId))
                  return "individualId: string expected";
              if (
                message.derivedFromId != null &&
                message.hasOwnProperty("derivedFromId")
              )
                if (!$util.isString(message.derivedFromId))
                  return "derivedFromId: string expected";
              if (
                message.description != null &&
                message.hasOwnProperty("description")
              )
                if (!$util.isString(message.description))
                  return "description: string expected";
              if (
                message.sampledTissue != null &&
                message.hasOwnProperty("sampledTissue")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.sampledTissue,
                  );
                if (error) return "sampledTissue." + error;
              }
              if (
                message.sampleType != null &&
                message.hasOwnProperty("sampleType")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.sampleType,
                  );
                if (error) return "sampleType." + error;
              }
              if (
                message.phenotypicFeatures != null &&
                message.hasOwnProperty("phenotypicFeatures")
              ) {
                if (!Array.isArray(message.phenotypicFeatures))
                  return "phenotypicFeatures: array expected";
                for (let i = 0; i < message.phenotypicFeatures.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.PhenotypicFeature.verify(
                      message.phenotypicFeatures[i],
                    );
                  if (error) return "phenotypicFeatures." + error;
                }
              }
              if (
                message.measurements != null &&
                message.hasOwnProperty("measurements")
              ) {
                if (!Array.isArray(message.measurements))
                  return "measurements: array expected";
                for (let i = 0; i < message.measurements.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.Measurement.verify(
                      message.measurements[i],
                    );
                  if (error) return "measurements." + error;
                }
              }
              if (
                message.taxonomy != null &&
                message.hasOwnProperty("taxonomy")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.taxonomy,
                  );
                if (error) return "taxonomy." + error;
              }
              if (
                message.timeOfCollection != null &&
                message.hasOwnProperty("timeOfCollection")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.timeOfCollection,
                  );
                if (error) return "timeOfCollection." + error;
              }
              if (
                message.histologicalDiagnosis != null &&
                message.hasOwnProperty("histologicalDiagnosis")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.histologicalDiagnosis,
                  );
                if (error) return "histologicalDiagnosis." + error;
              }
              if (
                message.tumorProgression != null &&
                message.hasOwnProperty("tumorProgression")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.tumorProgression,
                  );
                if (error) return "tumorProgression." + error;
              }
              if (
                message.tumorGrade != null &&
                message.hasOwnProperty("tumorGrade")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.tumorGrade,
                  );
                if (error) return "tumorGrade." + error;
              }
              if (
                message.pathologicalStage != null &&
                message.hasOwnProperty("pathologicalStage")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.pathologicalStage,
                  );
                if (error) return "pathologicalStage." + error;
              }
              if (
                message.pathologicalTnmFinding != null &&
                message.hasOwnProperty("pathologicalTnmFinding")
              ) {
                if (!Array.isArray(message.pathologicalTnmFinding))
                  return "pathologicalTnmFinding: array expected";
                for (
                  let i = 0;
                  i < message.pathologicalTnmFinding.length;
                  ++i
                ) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                      message.pathologicalTnmFinding[i],
                    );
                  if (error) return "pathologicalTnmFinding." + error;
                }
              }
              if (
                message.diagnosticMarkers != null &&
                message.hasOwnProperty("diagnosticMarkers")
              ) {
                if (!Array.isArray(message.diagnosticMarkers))
                  return "diagnosticMarkers: array expected";
                for (let i = 0; i < message.diagnosticMarkers.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                      message.diagnosticMarkers[i],
                    );
                  if (error) return "diagnosticMarkers." + error;
                }
              }
              if (
                message.procedure != null &&
                message.hasOwnProperty("procedure")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.Procedure.verify(
                    message.procedure,
                  );
                if (error) return "procedure." + error;
              }
              if (message.files != null && message.hasOwnProperty("files")) {
                if (!Array.isArray(message.files))
                  return "files: array expected";
                for (let i = 0; i < message.files.length; ++i) {
                  let error = $root.org.phenopackets.schema.v2.core.File.verify(
                    message.files[i],
                  );
                  if (error) return "files." + error;
                }
              }
              if (
                message.materialSample != null &&
                message.hasOwnProperty("materialSample")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.materialSample,
                  );
                if (error) return "materialSample." + error;
              }
              if (
                message.sampleProcessing != null &&
                message.hasOwnProperty("sampleProcessing")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.sampleProcessing,
                  );
                if (error) return "sampleProcessing." + error;
              }
              if (
                message.sampleStorage != null &&
                message.hasOwnProperty("sampleStorage")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.sampleStorage,
                  );
                if (error) return "sampleStorage." + error;
              }
              return null;
            };

            /**
             * Creates a Biosample message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Biosample} Biosample
             */
            Biosample.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.Biosample
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Biosample();
              if (object.id != null) message.id = String(object.id);
              if (object.individualId != null)
                message.individualId = String(object.individualId);
              if (object.derivedFromId != null)
                message.derivedFromId = String(object.derivedFromId);
              if (object.description != null)
                message.description = String(object.description);
              if (object.sampledTissue != null) {
                if (typeof object.sampledTissue !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.sampledTissue: object expected",
                  );
                message.sampledTissue =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.sampledTissue,
                  );
              }
              if (object.sampleType != null) {
                if (typeof object.sampleType !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.sampleType: object expected",
                  );
                message.sampleType =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.sampleType,
                  );
              }
              if (object.phenotypicFeatures) {
                if (!Array.isArray(object.phenotypicFeatures))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.phenotypicFeatures: array expected",
                  );
                message.phenotypicFeatures = [];
                for (let i = 0; i < object.phenotypicFeatures.length; ++i) {
                  if (typeof object.phenotypicFeatures[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.Biosample.phenotypicFeatures: object expected",
                    );
                  message.phenotypicFeatures[i] =
                    $root.org.phenopackets.schema.v2.core.PhenotypicFeature.fromObject(
                      object.phenotypicFeatures[i],
                    );
                }
              }
              if (object.measurements) {
                if (!Array.isArray(object.measurements))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.measurements: array expected",
                  );
                message.measurements = [];
                for (let i = 0; i < object.measurements.length; ++i) {
                  if (typeof object.measurements[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.Biosample.measurements: object expected",
                    );
                  message.measurements[i] =
                    $root.org.phenopackets.schema.v2.core.Measurement.fromObject(
                      object.measurements[i],
                    );
                }
              }
              if (object.taxonomy != null) {
                if (typeof object.taxonomy !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.taxonomy: object expected",
                  );
                message.taxonomy =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.taxonomy,
                  );
              }
              if (object.timeOfCollection != null) {
                if (typeof object.timeOfCollection !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.timeOfCollection: object expected",
                  );
                message.timeOfCollection =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.timeOfCollection,
                  );
              }
              if (object.histologicalDiagnosis != null) {
                if (typeof object.histologicalDiagnosis !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.histologicalDiagnosis: object expected",
                  );
                message.histologicalDiagnosis =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.histologicalDiagnosis,
                  );
              }
              if (object.tumorProgression != null) {
                if (typeof object.tumorProgression !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.tumorProgression: object expected",
                  );
                message.tumorProgression =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.tumorProgression,
                  );
              }
              if (object.tumorGrade != null) {
                if (typeof object.tumorGrade !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.tumorGrade: object expected",
                  );
                message.tumorGrade =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.tumorGrade,
                  );
              }
              if (object.pathologicalStage != null) {
                if (typeof object.pathologicalStage !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.pathologicalStage: object expected",
                  );
                message.pathologicalStage =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.pathologicalStage,
                  );
              }
              if (object.pathologicalTnmFinding) {
                if (!Array.isArray(object.pathologicalTnmFinding))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.pathologicalTnmFinding: array expected",
                  );
                message.pathologicalTnmFinding = [];
                for (let i = 0; i < object.pathologicalTnmFinding.length; ++i) {
                  if (typeof object.pathologicalTnmFinding[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.Biosample.pathologicalTnmFinding: object expected",
                    );
                  message.pathologicalTnmFinding[i] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                      object.pathologicalTnmFinding[i],
                    );
                }
              }
              if (object.diagnosticMarkers) {
                if (!Array.isArray(object.diagnosticMarkers))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.diagnosticMarkers: array expected",
                  );
                message.diagnosticMarkers = [];
                for (let i = 0; i < object.diagnosticMarkers.length; ++i) {
                  if (typeof object.diagnosticMarkers[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.Biosample.diagnosticMarkers: object expected",
                    );
                  message.diagnosticMarkers[i] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                      object.diagnosticMarkers[i],
                    );
                }
              }
              if (object.procedure != null) {
                if (typeof object.procedure !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.procedure: object expected",
                  );
                message.procedure =
                  $root.org.phenopackets.schema.v2.core.Procedure.fromObject(
                    object.procedure,
                  );
              }
              if (object.files) {
                if (!Array.isArray(object.files))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.files: array expected",
                  );
                message.files = [];
                for (let i = 0; i < object.files.length; ++i) {
                  if (typeof object.files[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.Biosample.files: object expected",
                    );
                  message.files[i] =
                    $root.org.phenopackets.schema.v2.core.File.fromObject(
                      object.files[i],
                    );
                }
              }
              if (object.materialSample != null) {
                if (typeof object.materialSample !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.materialSample: object expected",
                  );
                message.materialSample =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.materialSample,
                  );
              }
              if (object.sampleProcessing != null) {
                if (typeof object.sampleProcessing !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.sampleProcessing: object expected",
                  );
                message.sampleProcessing =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.sampleProcessing,
                  );
              }
              if (object.sampleStorage != null) {
                if (typeof object.sampleStorage !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Biosample.sampleStorage: object expected",
                  );
                message.sampleStorage =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.sampleStorage,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a Biosample message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @static
             * @param {org.phenopackets.schema.v2.core.Biosample} message Biosample
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Biosample.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.arrays || options.defaults) {
                object.phenotypicFeatures = [];
                object.measurements = [];
                object.pathologicalTnmFinding = [];
                object.diagnosticMarkers = [];
                object.files = [];
              }
              if (options.defaults) {
                object.id = "";
                object.individualId = "";
                object.derivedFromId = "";
                object.description = "";
                object.sampledTissue = null;
                object.sampleType = null;
                object.taxonomy = null;
                object.timeOfCollection = null;
                object.histologicalDiagnosis = null;
                object.tumorProgression = null;
                object.tumorGrade = null;
                object.pathologicalStage = null;
                object.procedure = null;
                object.materialSample = null;
                object.sampleProcessing = null;
                object.sampleStorage = null;
              }
              if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
              if (
                message.individualId != null &&
                message.hasOwnProperty("individualId")
              )
                object.individualId = message.individualId;
              if (
                message.derivedFromId != null &&
                message.hasOwnProperty("derivedFromId")
              )
                object.derivedFromId = message.derivedFromId;
              if (
                message.description != null &&
                message.hasOwnProperty("description")
              )
                object.description = message.description;
              if (
                message.sampledTissue != null &&
                message.hasOwnProperty("sampledTissue")
              )
                object.sampledTissue =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.sampledTissue,
                    options,
                  );
              if (
                message.sampleType != null &&
                message.hasOwnProperty("sampleType")
              )
                object.sampleType =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.sampleType,
                    options,
                  );
              if (
                message.phenotypicFeatures &&
                message.phenotypicFeatures.length
              ) {
                object.phenotypicFeatures = [];
                for (let j = 0; j < message.phenotypicFeatures.length; ++j)
                  object.phenotypicFeatures[j] =
                    $root.org.phenopackets.schema.v2.core.PhenotypicFeature.toObject(
                      message.phenotypicFeatures[j],
                      options,
                    );
              }
              if (message.measurements && message.measurements.length) {
                object.measurements = [];
                for (let j = 0; j < message.measurements.length; ++j)
                  object.measurements[j] =
                    $root.org.phenopackets.schema.v2.core.Measurement.toObject(
                      message.measurements[j],
                      options,
                    );
              }
              if (
                message.taxonomy != null &&
                message.hasOwnProperty("taxonomy")
              )
                object.taxonomy =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.taxonomy,
                    options,
                  );
              if (
                message.timeOfCollection != null &&
                message.hasOwnProperty("timeOfCollection")
              )
                object.timeOfCollection =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.timeOfCollection,
                    options,
                  );
              if (
                message.histologicalDiagnosis != null &&
                message.hasOwnProperty("histologicalDiagnosis")
              )
                object.histologicalDiagnosis =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.histologicalDiagnosis,
                    options,
                  );
              if (
                message.tumorProgression != null &&
                message.hasOwnProperty("tumorProgression")
              )
                object.tumorProgression =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.tumorProgression,
                    options,
                  );
              if (
                message.tumorGrade != null &&
                message.hasOwnProperty("tumorGrade")
              )
                object.tumorGrade =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.tumorGrade,
                    options,
                  );
              if (
                message.pathologicalStage != null &&
                message.hasOwnProperty("pathologicalStage")
              )
                object.pathologicalStage =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.pathologicalStage,
                    options,
                  );
              if (
                message.pathologicalTnmFinding &&
                message.pathologicalTnmFinding.length
              ) {
                object.pathologicalTnmFinding = [];
                for (let j = 0; j < message.pathologicalTnmFinding.length; ++j)
                  object.pathologicalTnmFinding[j] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                      message.pathologicalTnmFinding[j],
                      options,
                    );
              }
              if (
                message.diagnosticMarkers &&
                message.diagnosticMarkers.length
              ) {
                object.diagnosticMarkers = [];
                for (let j = 0; j < message.diagnosticMarkers.length; ++j)
                  object.diagnosticMarkers[j] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                      message.diagnosticMarkers[j],
                      options,
                    );
              }
              if (
                message.procedure != null &&
                message.hasOwnProperty("procedure")
              )
                object.procedure =
                  $root.org.phenopackets.schema.v2.core.Procedure.toObject(
                    message.procedure,
                    options,
                  );
              if (message.files && message.files.length) {
                object.files = [];
                for (let j = 0; j < message.files.length; ++j)
                  object.files[j] =
                    $root.org.phenopackets.schema.v2.core.File.toObject(
                      message.files[j],
                      options,
                    );
              }
              if (
                message.materialSample != null &&
                message.hasOwnProperty("materialSample")
              )
                object.materialSample =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.materialSample,
                    options,
                  );
              if (
                message.sampleProcessing != null &&
                message.hasOwnProperty("sampleProcessing")
              )
                object.sampleProcessing =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.sampleProcessing,
                    options,
                  );
              if (
                message.sampleStorage != null &&
                message.hasOwnProperty("sampleStorage")
              )
                object.sampleStorage =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.sampleStorage,
                    options,
                  );
              return object;
            };

            /**
             * Converts this Biosample to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Biosample.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Biosample
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Biosample
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Biosample.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.Biosample"
              );
            };

            return Biosample;
          })();

          core.Measurement = (function () {
            /**
             * Properties of a Measurement.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IMeasurement
             * @property {string|null} [description] Measurement description
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [assay] Measurement assay
             * @property {org.phenopackets.schema.v2.core.IValue|null} [value] Measurement value
             * @property {org.phenopackets.schema.v2.core.IComplexValue|null} [complexValue] Measurement complexValue
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [timeObserved] Measurement timeObserved
             * @property {org.phenopackets.schema.v2.core.IProcedure|null} [procedure] Measurement procedure
             */

            /**
             * Constructs a new Measurement.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a Measurement.
             * @implements IMeasurement
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IMeasurement=} [properties] Properties to set
             */
            function Measurement(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Measurement description.
             * @member {string} description
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @instance
             */
            Measurement.prototype.description = "";

            /**
             * Measurement assay.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} assay
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @instance
             */
            Measurement.prototype.assay = null;

            /**
             * Measurement value.
             * @member {org.phenopackets.schema.v2.core.IValue|null|undefined} value
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @instance
             */
            Measurement.prototype.value = null;

            /**
             * Measurement complexValue.
             * @member {org.phenopackets.schema.v2.core.IComplexValue|null|undefined} complexValue
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @instance
             */
            Measurement.prototype.complexValue = null;

            /**
             * Measurement timeObserved.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} timeObserved
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @instance
             */
            Measurement.prototype.timeObserved = null;

            /**
             * Measurement procedure.
             * @member {org.phenopackets.schema.v2.core.IProcedure|null|undefined} procedure
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @instance
             */
            Measurement.prototype.procedure = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Measurement measurementValue.
             * @member {"value"|"complexValue"|undefined} measurementValue
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @instance
             */
            Object.defineProperty(Measurement.prototype, "measurementValue", {
              get: $util.oneOfGetter(
                ($oneOfFields = ["value", "complexValue"]),
              ),
              set: $util.oneOfSetter($oneOfFields),
            });

            /**
             * Creates a new Measurement instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @static
             * @param {org.phenopackets.schema.v2.core.IMeasurement=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Measurement} Measurement instance
             */
            Measurement.create = function create(properties) {
              return new Measurement(properties);
            };

            /**
             * Encodes the specified Measurement message. Does not implicitly {@link org.phenopackets.schema.v2.core.Measurement.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @static
             * @param {org.phenopackets.schema.v2.core.IMeasurement} message Measurement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Measurement.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.description != null &&
                Object.hasOwnProperty.call(message, "description")
              )
                writer
                  .uint32(/* id 1, wireType 2 =*/ 10)
                  .string(message.description);
              if (
                message.assay != null &&
                Object.hasOwnProperty.call(message, "assay")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.assay,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (
                message.value != null &&
                Object.hasOwnProperty.call(message, "value")
              )
                $root.org.phenopackets.schema.v2.core.Value.encode(
                  message.value,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              if (
                message.complexValue != null &&
                Object.hasOwnProperty.call(message, "complexValue")
              )
                $root.org.phenopackets.schema.v2.core.ComplexValue.encode(
                  message.complexValue,
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
              if (
                message.timeObserved != null &&
                Object.hasOwnProperty.call(message, "timeObserved")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.timeObserved,
                  writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                ).ldelim();
              if (
                message.procedure != null &&
                Object.hasOwnProperty.call(message, "procedure")
              )
                $root.org.phenopackets.schema.v2.core.Procedure.encode(
                  message.procedure,
                  writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Measurement message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Measurement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @static
             * @param {org.phenopackets.schema.v2.core.IMeasurement} message Measurement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Measurement.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Measurement message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Measurement} Measurement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Measurement.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.Measurement();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.description = reader.string();
                    break;
                  }
                  case 2: {
                    message.assay =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 3: {
                    message.value =
                      $root.org.phenopackets.schema.v2.core.Value.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 4: {
                    message.complexValue =
                      $root.org.phenopackets.schema.v2.core.ComplexValue.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 5: {
                    message.timeObserved =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 6: {
                    message.procedure =
                      $root.org.phenopackets.schema.v2.core.Procedure.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Measurement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Measurement} Measurement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Measurement.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Measurement message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Measurement.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              let properties = {};
              if (
                message.description != null &&
                message.hasOwnProperty("description")
              )
                if (!$util.isString(message.description))
                  return "description: string expected";
              if (message.assay != null && message.hasOwnProperty("assay")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.assay,
                  );
                if (error) return "assay." + error;
              }
              if (message.value != null && message.hasOwnProperty("value")) {
                properties.measurementValue = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.Value.verify(
                      message.value,
                    );
                  if (error) return "value." + error;
                }
              }
              if (
                message.complexValue != null &&
                message.hasOwnProperty("complexValue")
              ) {
                if (properties.measurementValue === 1)
                  return "measurementValue: multiple values";
                properties.measurementValue = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.ComplexValue.verify(
                      message.complexValue,
                    );
                  if (error) return "complexValue." + error;
                }
              }
              if (
                message.timeObserved != null &&
                message.hasOwnProperty("timeObserved")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.timeObserved,
                  );
                if (error) return "timeObserved." + error;
              }
              if (
                message.procedure != null &&
                message.hasOwnProperty("procedure")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.Procedure.verify(
                    message.procedure,
                  );
                if (error) return "procedure." + error;
              }
              return null;
            };

            /**
             * Creates a Measurement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Measurement} Measurement
             */
            Measurement.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.Measurement
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Measurement();
              if (object.description != null)
                message.description = String(object.description);
              if (object.assay != null) {
                if (typeof object.assay !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Measurement.assay: object expected",
                  );
                message.assay =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.assay,
                  );
              }
              if (object.value != null) {
                if (typeof object.value !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Measurement.value: object expected",
                  );
                message.value =
                  $root.org.phenopackets.schema.v2.core.Value.fromObject(
                    object.value,
                  );
              }
              if (object.complexValue != null) {
                if (typeof object.complexValue !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Measurement.complexValue: object expected",
                  );
                message.complexValue =
                  $root.org.phenopackets.schema.v2.core.ComplexValue.fromObject(
                    object.complexValue,
                  );
              }
              if (object.timeObserved != null) {
                if (typeof object.timeObserved !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Measurement.timeObserved: object expected",
                  );
                message.timeObserved =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.timeObserved,
                  );
              }
              if (object.procedure != null) {
                if (typeof object.procedure !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Measurement.procedure: object expected",
                  );
                message.procedure =
                  $root.org.phenopackets.schema.v2.core.Procedure.fromObject(
                    object.procedure,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a Measurement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @static
             * @param {org.phenopackets.schema.v2.core.Measurement} message Measurement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Measurement.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.description = "";
                object.assay = null;
                object.timeObserved = null;
                object.procedure = null;
              }
              if (
                message.description != null &&
                message.hasOwnProperty("description")
              )
                object.description = message.description;
              if (message.assay != null && message.hasOwnProperty("assay"))
                object.assay =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.assay,
                    options,
                  );
              if (message.value != null && message.hasOwnProperty("value")) {
                object.value =
                  $root.org.phenopackets.schema.v2.core.Value.toObject(
                    message.value,
                    options,
                  );
                if (options.oneofs) object.measurementValue = "value";
              }
              if (
                message.complexValue != null &&
                message.hasOwnProperty("complexValue")
              ) {
                object.complexValue =
                  $root.org.phenopackets.schema.v2.core.ComplexValue.toObject(
                    message.complexValue,
                    options,
                  );
                if (options.oneofs) object.measurementValue = "complexValue";
              }
              if (
                message.timeObserved != null &&
                message.hasOwnProperty("timeObserved")
              )
                object.timeObserved =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.timeObserved,
                    options,
                  );
              if (
                message.procedure != null &&
                message.hasOwnProperty("procedure")
              )
                object.procedure =
                  $root.org.phenopackets.schema.v2.core.Procedure.toObject(
                    message.procedure,
                    options,
                  );
              return object;
            };

            /**
             * Converts this Measurement to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Measurement.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Measurement
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Measurement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Measurement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.Measurement"
              );
            };

            return Measurement;
          })();

          core.Value = (function () {
            /**
             * Properties of a Value.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IValue
             * @property {org.phenopackets.schema.v2.core.IQuantity|null} [quantity] Value quantity
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [ontologyClass] Value ontologyClass
             */

            /**
             * Constructs a new Value.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IValue=} [properties] Properties to set
             */
            function Value(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value quantity.
             * @member {org.phenopackets.schema.v2.core.IQuantity|null|undefined} quantity
             * @memberof org.phenopackets.schema.v2.core.Value
             * @instance
             */
            Value.prototype.quantity = null;

            /**
             * Value ontologyClass.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} ontologyClass
             * @memberof org.phenopackets.schema.v2.core.Value
             * @instance
             */
            Value.prototype.ontologyClass = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Value value.
             * @member {"quantity"|"ontologyClass"|undefined} value
             * @memberof org.phenopackets.schema.v2.core.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "value", {
              get: $util.oneOfGetter(
                ($oneOfFields = ["quantity", "ontologyClass"]),
              ),
              set: $util.oneOfSetter($oneOfFields),
            });

            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Value
             * @static
             * @param {org.phenopackets.schema.v2.core.IValue=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Value} Value instance
             */
            Value.create = function create(properties) {
              return new Value(properties);
            };

            /**
             * Encodes the specified Value message. Does not implicitly {@link org.phenopackets.schema.v2.core.Value.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Value
             * @static
             * @param {org.phenopackets.schema.v2.core.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.quantity != null &&
                Object.hasOwnProperty.call(message, "quantity")
              )
                $root.org.phenopackets.schema.v2.core.Quantity.encode(
                  message.quantity,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.ontologyClass != null &&
                Object.hasOwnProperty.call(message, "ontologyClass")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.ontologyClass,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Value
             * @static
             * @param {org.phenopackets.schema.v2.core.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Value();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.quantity =
                      $root.org.phenopackets.schema.v2.core.Quantity.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.ontologyClass =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              let properties = {};
              if (
                message.quantity != null &&
                message.hasOwnProperty("quantity")
              ) {
                properties.value = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.Quantity.verify(
                      message.quantity,
                    );
                  if (error) return "quantity." + error;
                }
              }
              if (
                message.ontologyClass != null &&
                message.hasOwnProperty("ontologyClass")
              ) {
                if (properties.value === 1) return "value: multiple values";
                properties.value = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                      message.ontologyClass,
                    );
                  if (error) return "ontologyClass." + error;
                }
              }
              return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Value} Value
             */
            Value.fromObject = function fromObject(object) {
              if (object instanceof $root.org.phenopackets.schema.v2.core.Value)
                return object;
              let message = new $root.org.phenopackets.schema.v2.core.Value();
              if (object.quantity != null) {
                if (typeof object.quantity !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Value.quantity: object expected",
                  );
                message.quantity =
                  $root.org.phenopackets.schema.v2.core.Quantity.fromObject(
                    object.quantity,
                  );
              }
              if (object.ontologyClass != null) {
                if (typeof object.ontologyClass !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Value.ontologyClass: object expected",
                  );
                message.ontologyClass =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.ontologyClass,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Value
             * @static
             * @param {org.phenopackets.schema.v2.core.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (
                message.quantity != null &&
                message.hasOwnProperty("quantity")
              ) {
                object.quantity =
                  $root.org.phenopackets.schema.v2.core.Quantity.toObject(
                    message.quantity,
                    options,
                  );
                if (options.oneofs) object.value = "quantity";
              }
              if (
                message.ontologyClass != null &&
                message.hasOwnProperty("ontologyClass")
              ) {
                object.ontologyClass =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.ontologyClass,
                    options,
                  );
                if (options.oneofs) object.value = "ontologyClass";
              }
              return object;
            };

            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Value
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Value
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/org.phenopackets.schema.v2.core.Value";
            };

            return Value;
          })();

          core.ComplexValue = (function () {
            /**
             * Properties of a ComplexValue.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IComplexValue
             * @property {Array.<org.phenopackets.schema.v2.core.ITypedQuantity>|null} [typedQuantities] ComplexValue typedQuantities
             */

            /**
             * Constructs a new ComplexValue.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a ComplexValue.
             * @implements IComplexValue
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IComplexValue=} [properties] Properties to set
             */
            function ComplexValue(properties) {
              this.typedQuantities = [];
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * ComplexValue typedQuantities.
             * @member {Array.<org.phenopackets.schema.v2.core.ITypedQuantity>} typedQuantities
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @instance
             */
            ComplexValue.prototype.typedQuantities = $util.emptyArray;

            /**
             * Creates a new ComplexValue instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @static
             * @param {org.phenopackets.schema.v2.core.IComplexValue=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.ComplexValue} ComplexValue instance
             */
            ComplexValue.create = function create(properties) {
              return new ComplexValue(properties);
            };

            /**
             * Encodes the specified ComplexValue message. Does not implicitly {@link org.phenopackets.schema.v2.core.ComplexValue.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @static
             * @param {org.phenopackets.schema.v2.core.IComplexValue} message ComplexValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComplexValue.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.typedQuantities != null &&
                message.typedQuantities.length
              )
                for (let i = 0; i < message.typedQuantities.length; ++i)
                  $root.org.phenopackets.schema.v2.core.TypedQuantity.encode(
                    message.typedQuantities[i],
                    writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified ComplexValue message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.ComplexValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @static
             * @param {org.phenopackets.schema.v2.core.IComplexValue} message ComplexValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComplexValue.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComplexValue message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.ComplexValue} ComplexValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComplexValue.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.ComplexValue();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (
                      !(
                        message.typedQuantities &&
                        message.typedQuantities.length
                      )
                    )
                      message.typedQuantities = [];
                    message.typedQuantities.push(
                      $root.org.phenopackets.schema.v2.core.TypedQuantity.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a ComplexValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.ComplexValue} ComplexValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComplexValue.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComplexValue message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComplexValue.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.typedQuantities != null &&
                message.hasOwnProperty("typedQuantities")
              ) {
                if (!Array.isArray(message.typedQuantities))
                  return "typedQuantities: array expected";
                for (let i = 0; i < message.typedQuantities.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.TypedQuantity.verify(
                      message.typedQuantities[i],
                    );
                  if (error) return "typedQuantities." + error;
                }
              }
              return null;
            };

            /**
             * Creates a ComplexValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.ComplexValue} ComplexValue
             */
            ComplexValue.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.ComplexValue
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.ComplexValue();
              if (object.typedQuantities) {
                if (!Array.isArray(object.typedQuantities))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.ComplexValue.typedQuantities: array expected",
                  );
                message.typedQuantities = [];
                for (let i = 0; i < object.typedQuantities.length; ++i) {
                  if (typeof object.typedQuantities[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.ComplexValue.typedQuantities: object expected",
                    );
                  message.typedQuantities[i] =
                    $root.org.phenopackets.schema.v2.core.TypedQuantity.fromObject(
                      object.typedQuantities[i],
                    );
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a ComplexValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @static
             * @param {org.phenopackets.schema.v2.core.ComplexValue} message ComplexValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComplexValue.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.arrays || options.defaults)
                object.typedQuantities = [];
              if (message.typedQuantities && message.typedQuantities.length) {
                object.typedQuantities = [];
                for (let j = 0; j < message.typedQuantities.length; ++j)
                  object.typedQuantities[j] =
                    $root.org.phenopackets.schema.v2.core.TypedQuantity.toObject(
                      message.typedQuantities[j],
                      options,
                    );
              }
              return object;
            };

            /**
             * Converts this ComplexValue to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComplexValue.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for ComplexValue
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.ComplexValue
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ComplexValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.ComplexValue"
              );
            };

            return ComplexValue;
          })();

          core.Quantity = (function () {
            /**
             * Properties of a Quantity.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IQuantity
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [unit] Quantity unit
             * @property {number|null} [value] Quantity value
             * @property {org.phenopackets.schema.v2.core.IReferenceRange|null} [referenceRange] Quantity referenceRange
             */

            /**
             * Constructs a new Quantity.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a Quantity.
             * @implements IQuantity
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IQuantity=} [properties] Properties to set
             */
            function Quantity(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Quantity unit.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} unit
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @instance
             */
            Quantity.prototype.unit = null;

            /**
             * Quantity value.
             * @member {number} value
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @instance
             */
            Quantity.prototype.value = 0;

            /**
             * Quantity referenceRange.
             * @member {org.phenopackets.schema.v2.core.IReferenceRange|null|undefined} referenceRange
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @instance
             */
            Quantity.prototype.referenceRange = null;

            /**
             * Creates a new Quantity instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @static
             * @param {org.phenopackets.schema.v2.core.IQuantity=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Quantity} Quantity instance
             */
            Quantity.create = function create(properties) {
              return new Quantity(properties);
            };

            /**
             * Encodes the specified Quantity message. Does not implicitly {@link org.phenopackets.schema.v2.core.Quantity.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @static
             * @param {org.phenopackets.schema.v2.core.IQuantity} message Quantity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Quantity.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.unit != null &&
                Object.hasOwnProperty.call(message, "unit")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.unit,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.value != null &&
                Object.hasOwnProperty.call(message, "value")
              )
                writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.value);
              if (
                message.referenceRange != null &&
                Object.hasOwnProperty.call(message, "referenceRange")
              )
                $root.org.phenopackets.schema.v2.core.ReferenceRange.encode(
                  message.referenceRange,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Quantity message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Quantity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @static
             * @param {org.phenopackets.schema.v2.core.IQuantity} message Quantity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Quantity.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Quantity message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Quantity} Quantity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Quantity.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Quantity();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.unit =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.value = reader.double();
                    break;
                  }
                  case 3: {
                    message.referenceRange =
                      $root.org.phenopackets.schema.v2.core.ReferenceRange.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Quantity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Quantity} Quantity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Quantity.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Quantity message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Quantity.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.unit != null && message.hasOwnProperty("unit")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.unit,
                  );
                if (error) return "unit." + error;
              }
              if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value !== "number")
                  return "value: number expected";
              if (
                message.referenceRange != null &&
                message.hasOwnProperty("referenceRange")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.ReferenceRange.verify(
                    message.referenceRange,
                  );
                if (error) return "referenceRange." + error;
              }
              return null;
            };

            /**
             * Creates a Quantity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Quantity} Quantity
             */
            Quantity.fromObject = function fromObject(object) {
              if (
                object instanceof $root.org.phenopackets.schema.v2.core.Quantity
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Quantity();
              if (object.unit != null) {
                if (typeof object.unit !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Quantity.unit: object expected",
                  );
                message.unit =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.unit,
                  );
              }
              if (object.value != null) message.value = Number(object.value);
              if (object.referenceRange != null) {
                if (typeof object.referenceRange !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Quantity.referenceRange: object expected",
                  );
                message.referenceRange =
                  $root.org.phenopackets.schema.v2.core.ReferenceRange.fromObject(
                    object.referenceRange,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a Quantity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @static
             * @param {org.phenopackets.schema.v2.core.Quantity} message Quantity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Quantity.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.unit = null;
                object.value = 0;
                object.referenceRange = null;
              }
              if (message.unit != null && message.hasOwnProperty("unit"))
                object.unit =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.unit,
                    options,
                  );
              if (message.value != null && message.hasOwnProperty("value"))
                object.value =
                  options.json && !isFinite(message.value)
                    ? String(message.value)
                    : message.value;
              if (
                message.referenceRange != null &&
                message.hasOwnProperty("referenceRange")
              )
                object.referenceRange =
                  $root.org.phenopackets.schema.v2.core.ReferenceRange.toObject(
                    message.referenceRange,
                    options,
                  );
              return object;
            };

            /**
             * Converts this Quantity to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Quantity.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Quantity
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Quantity
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Quantity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.Quantity"
              );
            };

            return Quantity;
          })();

          core.TypedQuantity = (function () {
            /**
             * Properties of a TypedQuantity.
             * @memberof org.phenopackets.schema.v2.core
             * @interface ITypedQuantity
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [type] TypedQuantity type
             * @property {org.phenopackets.schema.v2.core.IQuantity|null} [quantity] TypedQuantity quantity
             */

            /**
             * Constructs a new TypedQuantity.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a TypedQuantity.
             * @implements ITypedQuantity
             * @constructor
             * @param {org.phenopackets.schema.v2.core.ITypedQuantity=} [properties] Properties to set
             */
            function TypedQuantity(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * TypedQuantity type.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} type
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @instance
             */
            TypedQuantity.prototype.type = null;

            /**
             * TypedQuantity quantity.
             * @member {org.phenopackets.schema.v2.core.IQuantity|null|undefined} quantity
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @instance
             */
            TypedQuantity.prototype.quantity = null;

            /**
             * Creates a new TypedQuantity instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @static
             * @param {org.phenopackets.schema.v2.core.ITypedQuantity=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.TypedQuantity} TypedQuantity instance
             */
            TypedQuantity.create = function create(properties) {
              return new TypedQuantity(properties);
            };

            /**
             * Encodes the specified TypedQuantity message. Does not implicitly {@link org.phenopackets.schema.v2.core.TypedQuantity.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @static
             * @param {org.phenopackets.schema.v2.core.ITypedQuantity} message TypedQuantity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TypedQuantity.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.type != null &&
                Object.hasOwnProperty.call(message, "type")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.type,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.quantity != null &&
                Object.hasOwnProperty.call(message, "quantity")
              )
                $root.org.phenopackets.schema.v2.core.Quantity.encode(
                  message.quantity,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified TypedQuantity message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.TypedQuantity.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @static
             * @param {org.phenopackets.schema.v2.core.ITypedQuantity} message TypedQuantity message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TypedQuantity.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TypedQuantity message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.TypedQuantity} TypedQuantity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TypedQuantity.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.TypedQuantity();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.type =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.quantity =
                      $root.org.phenopackets.schema.v2.core.Quantity.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a TypedQuantity message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.TypedQuantity} TypedQuantity
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TypedQuantity.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TypedQuantity message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TypedQuantity.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.type != null && message.hasOwnProperty("type")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.type,
                  );
                if (error) return "type." + error;
              }
              if (
                message.quantity != null &&
                message.hasOwnProperty("quantity")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.Quantity.verify(
                    message.quantity,
                  );
                if (error) return "quantity." + error;
              }
              return null;
            };

            /**
             * Creates a TypedQuantity message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.TypedQuantity} TypedQuantity
             */
            TypedQuantity.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.TypedQuantity
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.TypedQuantity();
              if (object.type != null) {
                if (typeof object.type !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TypedQuantity.type: object expected",
                  );
                message.type =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.type,
                  );
              }
              if (object.quantity != null) {
                if (typeof object.quantity !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TypedQuantity.quantity: object expected",
                  );
                message.quantity =
                  $root.org.phenopackets.schema.v2.core.Quantity.fromObject(
                    object.quantity,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a TypedQuantity message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @static
             * @param {org.phenopackets.schema.v2.core.TypedQuantity} message TypedQuantity
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TypedQuantity.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.type = null;
                object.quantity = null;
              }
              if (message.type != null && message.hasOwnProperty("type"))
                object.type =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.type,
                    options,
                  );
              if (
                message.quantity != null &&
                message.hasOwnProperty("quantity")
              )
                object.quantity =
                  $root.org.phenopackets.schema.v2.core.Quantity.toObject(
                    message.quantity,
                    options,
                  );
              return object;
            };

            /**
             * Converts this TypedQuantity to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TypedQuantity.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for TypedQuantity
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.TypedQuantity
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TypedQuantity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.TypedQuantity"
              );
            };

            return TypedQuantity;
          })();

          core.ReferenceRange = (function () {
            /**
             * Properties of a ReferenceRange.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IReferenceRange
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [unit] ReferenceRange unit
             * @property {number|null} [low] ReferenceRange low
             * @property {number|null} [high] ReferenceRange high
             */

            /**
             * Constructs a new ReferenceRange.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a ReferenceRange.
             * @implements IReferenceRange
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IReferenceRange=} [properties] Properties to set
             */
            function ReferenceRange(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReferenceRange unit.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} unit
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @instance
             */
            ReferenceRange.prototype.unit = null;

            /**
             * ReferenceRange low.
             * @member {number} low
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @instance
             */
            ReferenceRange.prototype.low = 0;

            /**
             * ReferenceRange high.
             * @member {number} high
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @instance
             */
            ReferenceRange.prototype.high = 0;

            /**
             * Creates a new ReferenceRange instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @static
             * @param {org.phenopackets.schema.v2.core.IReferenceRange=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.ReferenceRange} ReferenceRange instance
             */
            ReferenceRange.create = function create(properties) {
              return new ReferenceRange(properties);
            };

            /**
             * Encodes the specified ReferenceRange message. Does not implicitly {@link org.phenopackets.schema.v2.core.ReferenceRange.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @static
             * @param {org.phenopackets.schema.v2.core.IReferenceRange} message ReferenceRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReferenceRange.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.unit != null &&
                Object.hasOwnProperty.call(message, "unit")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.unit,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.low != null &&
                Object.hasOwnProperty.call(message, "low")
              )
                writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.low);
              if (
                message.high != null &&
                Object.hasOwnProperty.call(message, "high")
              )
                writer.uint32(/* id 3, wireType 1 =*/ 25).double(message.high);
              return writer;
            };

            /**
             * Encodes the specified ReferenceRange message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.ReferenceRange.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @static
             * @param {org.phenopackets.schema.v2.core.IReferenceRange} message ReferenceRange message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReferenceRange.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReferenceRange message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.ReferenceRange} ReferenceRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReferenceRange.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.ReferenceRange();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.unit =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.low = reader.double();
                    break;
                  }
                  case 3: {
                    message.high = reader.double();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a ReferenceRange message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.ReferenceRange} ReferenceRange
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReferenceRange.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReferenceRange message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReferenceRange.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.unit != null && message.hasOwnProperty("unit")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.unit,
                  );
                if (error) return "unit." + error;
              }
              if (message.low != null && message.hasOwnProperty("low"))
                if (typeof message.low !== "number")
                  return "low: number expected";
              if (message.high != null && message.hasOwnProperty("high"))
                if (typeof message.high !== "number")
                  return "high: number expected";
              return null;
            };

            /**
             * Creates a ReferenceRange message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.ReferenceRange} ReferenceRange
             */
            ReferenceRange.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.ReferenceRange
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.ReferenceRange();
              if (object.unit != null) {
                if (typeof object.unit !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.ReferenceRange.unit: object expected",
                  );
                message.unit =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.unit,
                  );
              }
              if (object.low != null) message.low = Number(object.low);
              if (object.high != null) message.high = Number(object.high);
              return message;
            };

            /**
             * Creates a plain object from a ReferenceRange message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @static
             * @param {org.phenopackets.schema.v2.core.ReferenceRange} message ReferenceRange
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReferenceRange.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.unit = null;
                object.low = 0;
                object.high = 0;
              }
              if (message.unit != null && message.hasOwnProperty("unit"))
                object.unit =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.unit,
                    options,
                  );
              if (message.low != null && message.hasOwnProperty("low"))
                object.low =
                  options.json && !isFinite(message.low)
                    ? String(message.low)
                    : message.low;
              if (message.high != null && message.hasOwnProperty("high"))
                object.high =
                  options.json && !isFinite(message.high)
                    ? String(message.high)
                    : message.high;
              return object;
            };

            /**
             * Converts this ReferenceRange to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReferenceRange.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for ReferenceRange
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.ReferenceRange
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReferenceRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix +
                "/org.phenopackets.schema.v2.core.ReferenceRange"
              );
            };

            return ReferenceRange;
          })();

          core.PhenotypicFeature = (function () {
            /**
             * Properties of a PhenotypicFeature.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IPhenotypicFeature
             * @property {string|null} [description] PhenotypicFeature description
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [type] PhenotypicFeature type
             * @property {boolean|null} [excluded] PhenotypicFeature excluded
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [severity] PhenotypicFeature severity
             * @property {Array.<org.phenopackets.schema.v2.core.IOntologyClass>|null} [modifiers] PhenotypicFeature modifiers
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [onset] PhenotypicFeature onset
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [resolution] PhenotypicFeature resolution
             * @property {Array.<org.phenopackets.schema.v2.core.IEvidence>|null} [evidence] PhenotypicFeature evidence
             */

            /**
             * Constructs a new PhenotypicFeature.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a PhenotypicFeature.
             * @implements IPhenotypicFeature
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IPhenotypicFeature=} [properties] Properties to set
             */
            function PhenotypicFeature(properties) {
              this.modifiers = [];
              this.evidence = [];
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * PhenotypicFeature description.
             * @member {string} description
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @instance
             */
            PhenotypicFeature.prototype.description = "";

            /**
             * PhenotypicFeature type.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} type
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @instance
             */
            PhenotypicFeature.prototype.type = null;

            /**
             * PhenotypicFeature excluded.
             * @member {boolean} excluded
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @instance
             */
            PhenotypicFeature.prototype.excluded = false;

            /**
             * PhenotypicFeature severity.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} severity
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @instance
             */
            PhenotypicFeature.prototype.severity = null;

            /**
             * PhenotypicFeature modifiers.
             * @member {Array.<org.phenopackets.schema.v2.core.IOntologyClass>} modifiers
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @instance
             */
            PhenotypicFeature.prototype.modifiers = $util.emptyArray;

            /**
             * PhenotypicFeature onset.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} onset
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @instance
             */
            PhenotypicFeature.prototype.onset = null;

            /**
             * PhenotypicFeature resolution.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} resolution
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @instance
             */
            PhenotypicFeature.prototype.resolution = null;

            /**
             * PhenotypicFeature evidence.
             * @member {Array.<org.phenopackets.schema.v2.core.IEvidence>} evidence
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @instance
             */
            PhenotypicFeature.prototype.evidence = $util.emptyArray;

            /**
             * Creates a new PhenotypicFeature instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @static
             * @param {org.phenopackets.schema.v2.core.IPhenotypicFeature=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.PhenotypicFeature} PhenotypicFeature instance
             */
            PhenotypicFeature.create = function create(properties) {
              return new PhenotypicFeature(properties);
            };

            /**
             * Encodes the specified PhenotypicFeature message. Does not implicitly {@link org.phenopackets.schema.v2.core.PhenotypicFeature.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @static
             * @param {org.phenopackets.schema.v2.core.IPhenotypicFeature} message PhenotypicFeature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PhenotypicFeature.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.description != null &&
                Object.hasOwnProperty.call(message, "description")
              )
                writer
                  .uint32(/* id 1, wireType 2 =*/ 10)
                  .string(message.description);
              if (
                message.type != null &&
                Object.hasOwnProperty.call(message, "type")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.type,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (
                message.excluded != null &&
                Object.hasOwnProperty.call(message, "excluded")
              )
                writer
                  .uint32(/* id 3, wireType 0 =*/ 24)
                  .bool(message.excluded);
              if (
                message.severity != null &&
                Object.hasOwnProperty.call(message, "severity")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.severity,
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
              if (message.modifiers != null && message.modifiers.length)
                for (let i = 0; i < message.modifiers.length; ++i)
                  $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                    message.modifiers[i],
                    writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                  ).ldelim();
              if (
                message.onset != null &&
                Object.hasOwnProperty.call(message, "onset")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.onset,
                  writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
                ).ldelim();
              if (
                message.resolution != null &&
                Object.hasOwnProperty.call(message, "resolution")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.resolution,
                  writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
                ).ldelim();
              if (message.evidence != null && message.evidence.length)
                for (let i = 0; i < message.evidence.length; ++i)
                  $root.org.phenopackets.schema.v2.core.Evidence.encode(
                    message.evidence[i],
                    writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified PhenotypicFeature message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.PhenotypicFeature.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @static
             * @param {org.phenopackets.schema.v2.core.IPhenotypicFeature} message PhenotypicFeature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PhenotypicFeature.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PhenotypicFeature message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.PhenotypicFeature} PhenotypicFeature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PhenotypicFeature.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.PhenotypicFeature();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.description = reader.string();
                    break;
                  }
                  case 2: {
                    message.type =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 3: {
                    message.excluded = reader.bool();
                    break;
                  }
                  case 4: {
                    message.severity =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 5: {
                    if (!(message.modifiers && message.modifiers.length))
                      message.modifiers = [];
                    message.modifiers.push(
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 6: {
                    message.onset =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 7: {
                    message.resolution =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 8: {
                    if (!(message.evidence && message.evidence.length))
                      message.evidence = [];
                    message.evidence.push(
                      $root.org.phenopackets.schema.v2.core.Evidence.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a PhenotypicFeature message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.PhenotypicFeature} PhenotypicFeature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PhenotypicFeature.decodeDelimited = function decodeDelimited(
              reader,
            ) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PhenotypicFeature message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PhenotypicFeature.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.description != null &&
                message.hasOwnProperty("description")
              )
                if (!$util.isString(message.description))
                  return "description: string expected";
              if (message.type != null && message.hasOwnProperty("type")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.type,
                  );
                if (error) return "type." + error;
              }
              if (
                message.excluded != null &&
                message.hasOwnProperty("excluded")
              )
                if (typeof message.excluded !== "boolean")
                  return "excluded: boolean expected";
              if (
                message.severity != null &&
                message.hasOwnProperty("severity")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.severity,
                  );
                if (error) return "severity." + error;
              }
              if (
                message.modifiers != null &&
                message.hasOwnProperty("modifiers")
              ) {
                if (!Array.isArray(message.modifiers))
                  return "modifiers: array expected";
                for (let i = 0; i < message.modifiers.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                      message.modifiers[i],
                    );
                  if (error) return "modifiers." + error;
                }
              }
              if (message.onset != null && message.hasOwnProperty("onset")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.onset,
                  );
                if (error) return "onset." + error;
              }
              if (
                message.resolution != null &&
                message.hasOwnProperty("resolution")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.resolution,
                  );
                if (error) return "resolution." + error;
              }
              if (
                message.evidence != null &&
                message.hasOwnProperty("evidence")
              ) {
                if (!Array.isArray(message.evidence))
                  return "evidence: array expected";
                for (let i = 0; i < message.evidence.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.Evidence.verify(
                      message.evidence[i],
                    );
                  if (error) return "evidence." + error;
                }
              }
              return null;
            };

            /**
             * Creates a PhenotypicFeature message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.PhenotypicFeature} PhenotypicFeature
             */
            PhenotypicFeature.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.PhenotypicFeature
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.PhenotypicFeature();
              if (object.description != null)
                message.description = String(object.description);
              if (object.type != null) {
                if (typeof object.type !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.PhenotypicFeature.type: object expected",
                  );
                message.type =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.type,
                  );
              }
              if (object.excluded != null)
                message.excluded = Boolean(object.excluded);
              if (object.severity != null) {
                if (typeof object.severity !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.PhenotypicFeature.severity: object expected",
                  );
                message.severity =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.severity,
                  );
              }
              if (object.modifiers) {
                if (!Array.isArray(object.modifiers))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.PhenotypicFeature.modifiers: array expected",
                  );
                message.modifiers = [];
                for (let i = 0; i < object.modifiers.length; ++i) {
                  if (typeof object.modifiers[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.PhenotypicFeature.modifiers: object expected",
                    );
                  message.modifiers[i] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                      object.modifiers[i],
                    );
                }
              }
              if (object.onset != null) {
                if (typeof object.onset !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.PhenotypicFeature.onset: object expected",
                  );
                message.onset =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.onset,
                  );
              }
              if (object.resolution != null) {
                if (typeof object.resolution !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.PhenotypicFeature.resolution: object expected",
                  );
                message.resolution =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.resolution,
                  );
              }
              if (object.evidence) {
                if (!Array.isArray(object.evidence))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.PhenotypicFeature.evidence: array expected",
                  );
                message.evidence = [];
                for (let i = 0; i < object.evidence.length; ++i) {
                  if (typeof object.evidence[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.PhenotypicFeature.evidence: object expected",
                    );
                  message.evidence[i] =
                    $root.org.phenopackets.schema.v2.core.Evidence.fromObject(
                      object.evidence[i],
                    );
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a PhenotypicFeature message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @static
             * @param {org.phenopackets.schema.v2.core.PhenotypicFeature} message PhenotypicFeature
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PhenotypicFeature.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.arrays || options.defaults) {
                object.modifiers = [];
                object.evidence = [];
              }
              if (options.defaults) {
                object.description = "";
                object.type = null;
                object.excluded = false;
                object.severity = null;
                object.onset = null;
                object.resolution = null;
              }
              if (
                message.description != null &&
                message.hasOwnProperty("description")
              )
                object.description = message.description;
              if (message.type != null && message.hasOwnProperty("type"))
                object.type =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.type,
                    options,
                  );
              if (
                message.excluded != null &&
                message.hasOwnProperty("excluded")
              )
                object.excluded = message.excluded;
              if (
                message.severity != null &&
                message.hasOwnProperty("severity")
              )
                object.severity =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.severity,
                    options,
                  );
              if (message.modifiers && message.modifiers.length) {
                object.modifiers = [];
                for (let j = 0; j < message.modifiers.length; ++j)
                  object.modifiers[j] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                      message.modifiers[j],
                      options,
                    );
              }
              if (message.onset != null && message.hasOwnProperty("onset"))
                object.onset =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.onset,
                    options,
                  );
              if (
                message.resolution != null &&
                message.hasOwnProperty("resolution")
              )
                object.resolution =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.resolution,
                    options,
                  );
              if (message.evidence && message.evidence.length) {
                object.evidence = [];
                for (let j = 0; j < message.evidence.length; ++j)
                  object.evidence[j] =
                    $root.org.phenopackets.schema.v2.core.Evidence.toObject(
                      message.evidence[j],
                      options,
                    );
              }
              return object;
            };

            /**
             * Converts this PhenotypicFeature to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PhenotypicFeature.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for PhenotypicFeature
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.PhenotypicFeature
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PhenotypicFeature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix +
                "/org.phenopackets.schema.v2.core.PhenotypicFeature"
              );
            };

            return PhenotypicFeature;
          })();

          core.Disease = (function () {
            /**
             * Properties of a Disease.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IDisease
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [term] Disease term
             * @property {boolean|null} [excluded] Disease excluded
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [onset] Disease onset
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [resolution] Disease resolution
             * @property {Array.<org.phenopackets.schema.v2.core.IOntologyClass>|null} [diseaseStage] Disease diseaseStage
             * @property {Array.<org.phenopackets.schema.v2.core.IOntologyClass>|null} [clinicalTnmFinding] Disease clinicalTnmFinding
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [primarySite] Disease primarySite
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [laterality] Disease laterality
             */

            /**
             * Constructs a new Disease.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a Disease.
             * @implements IDisease
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IDisease=} [properties] Properties to set
             */
            function Disease(properties) {
              this.diseaseStage = [];
              this.clinicalTnmFinding = [];
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Disease term.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} term
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @instance
             */
            Disease.prototype.term = null;

            /**
             * Disease excluded.
             * @member {boolean} excluded
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @instance
             */
            Disease.prototype.excluded = false;

            /**
             * Disease onset.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} onset
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @instance
             */
            Disease.prototype.onset = null;

            /**
             * Disease resolution.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} resolution
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @instance
             */
            Disease.prototype.resolution = null;

            /**
             * Disease diseaseStage.
             * @member {Array.<org.phenopackets.schema.v2.core.IOntologyClass>} diseaseStage
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @instance
             */
            Disease.prototype.diseaseStage = $util.emptyArray;

            /**
             * Disease clinicalTnmFinding.
             * @member {Array.<org.phenopackets.schema.v2.core.IOntologyClass>} clinicalTnmFinding
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @instance
             */
            Disease.prototype.clinicalTnmFinding = $util.emptyArray;

            /**
             * Disease primarySite.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} primarySite
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @instance
             */
            Disease.prototype.primarySite = null;

            /**
             * Disease laterality.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} laterality
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @instance
             */
            Disease.prototype.laterality = null;

            /**
             * Creates a new Disease instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @static
             * @param {org.phenopackets.schema.v2.core.IDisease=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Disease} Disease instance
             */
            Disease.create = function create(properties) {
              return new Disease(properties);
            };

            /**
             * Encodes the specified Disease message. Does not implicitly {@link org.phenopackets.schema.v2.core.Disease.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @static
             * @param {org.phenopackets.schema.v2.core.IDisease} message Disease message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Disease.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.term != null &&
                Object.hasOwnProperty.call(message, "term")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.term,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.excluded != null &&
                Object.hasOwnProperty.call(message, "excluded")
              )
                writer
                  .uint32(/* id 2, wireType 0 =*/ 16)
                  .bool(message.excluded);
              if (
                message.onset != null &&
                Object.hasOwnProperty.call(message, "onset")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.onset,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              if (
                message.resolution != null &&
                Object.hasOwnProperty.call(message, "resolution")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.resolution,
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
              if (message.diseaseStage != null && message.diseaseStage.length)
                for (let i = 0; i < message.diseaseStage.length; ++i)
                  $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                    message.diseaseStage[i],
                    writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                  ).ldelim();
              if (
                message.clinicalTnmFinding != null &&
                message.clinicalTnmFinding.length
              )
                for (let i = 0; i < message.clinicalTnmFinding.length; ++i)
                  $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                    message.clinicalTnmFinding[i],
                    writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
                  ).ldelim();
              if (
                message.primarySite != null &&
                Object.hasOwnProperty.call(message, "primarySite")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.primarySite,
                  writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
                ).ldelim();
              if (
                message.laterality != null &&
                Object.hasOwnProperty.call(message, "laterality")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.laterality,
                  writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Disease message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Disease.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @static
             * @param {org.phenopackets.schema.v2.core.IDisease} message Disease message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Disease.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Disease message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Disease} Disease
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Disease.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Disease();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.term =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.excluded = reader.bool();
                    break;
                  }
                  case 3: {
                    message.onset =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 4: {
                    message.resolution =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 5: {
                    if (!(message.diseaseStage && message.diseaseStage.length))
                      message.diseaseStage = [];
                    message.diseaseStage.push(
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 6: {
                    if (
                      !(
                        message.clinicalTnmFinding &&
                        message.clinicalTnmFinding.length
                      )
                    )
                      message.clinicalTnmFinding = [];
                    message.clinicalTnmFinding.push(
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 7: {
                    message.primarySite =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 8: {
                    message.laterality =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Disease message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Disease} Disease
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Disease.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Disease message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Disease.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.term != null && message.hasOwnProperty("term")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.term,
                  );
                if (error) return "term." + error;
              }
              if (
                message.excluded != null &&
                message.hasOwnProperty("excluded")
              )
                if (typeof message.excluded !== "boolean")
                  return "excluded: boolean expected";
              if (message.onset != null && message.hasOwnProperty("onset")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.onset,
                  );
                if (error) return "onset." + error;
              }
              if (
                message.resolution != null &&
                message.hasOwnProperty("resolution")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.resolution,
                  );
                if (error) return "resolution." + error;
              }
              if (
                message.diseaseStage != null &&
                message.hasOwnProperty("diseaseStage")
              ) {
                if (!Array.isArray(message.diseaseStage))
                  return "diseaseStage: array expected";
                for (let i = 0; i < message.diseaseStage.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                      message.diseaseStage[i],
                    );
                  if (error) return "diseaseStage." + error;
                }
              }
              if (
                message.clinicalTnmFinding != null &&
                message.hasOwnProperty("clinicalTnmFinding")
              ) {
                if (!Array.isArray(message.clinicalTnmFinding))
                  return "clinicalTnmFinding: array expected";
                for (let i = 0; i < message.clinicalTnmFinding.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                      message.clinicalTnmFinding[i],
                    );
                  if (error) return "clinicalTnmFinding." + error;
                }
              }
              if (
                message.primarySite != null &&
                message.hasOwnProperty("primarySite")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.primarySite,
                  );
                if (error) return "primarySite." + error;
              }
              if (
                message.laterality != null &&
                message.hasOwnProperty("laterality")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.laterality,
                  );
                if (error) return "laterality." + error;
              }
              return null;
            };

            /**
             * Creates a Disease message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Disease} Disease
             */
            Disease.fromObject = function fromObject(object) {
              if (
                object instanceof $root.org.phenopackets.schema.v2.core.Disease
              )
                return object;
              let message = new $root.org.phenopackets.schema.v2.core.Disease();
              if (object.term != null) {
                if (typeof object.term !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Disease.term: object expected",
                  );
                message.term =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.term,
                  );
              }
              if (object.excluded != null)
                message.excluded = Boolean(object.excluded);
              if (object.onset != null) {
                if (typeof object.onset !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Disease.onset: object expected",
                  );
                message.onset =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.onset,
                  );
              }
              if (object.resolution != null) {
                if (typeof object.resolution !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Disease.resolution: object expected",
                  );
                message.resolution =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.resolution,
                  );
              }
              if (object.diseaseStage) {
                if (!Array.isArray(object.diseaseStage))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Disease.diseaseStage: array expected",
                  );
                message.diseaseStage = [];
                for (let i = 0; i < object.diseaseStage.length; ++i) {
                  if (typeof object.diseaseStage[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.Disease.diseaseStage: object expected",
                    );
                  message.diseaseStage[i] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                      object.diseaseStage[i],
                    );
                }
              }
              if (object.clinicalTnmFinding) {
                if (!Array.isArray(object.clinicalTnmFinding))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Disease.clinicalTnmFinding: array expected",
                  );
                message.clinicalTnmFinding = [];
                for (let i = 0; i < object.clinicalTnmFinding.length; ++i) {
                  if (typeof object.clinicalTnmFinding[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.Disease.clinicalTnmFinding: object expected",
                    );
                  message.clinicalTnmFinding[i] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                      object.clinicalTnmFinding[i],
                    );
                }
              }
              if (object.primarySite != null) {
                if (typeof object.primarySite !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Disease.primarySite: object expected",
                  );
                message.primarySite =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.primarySite,
                  );
              }
              if (object.laterality != null) {
                if (typeof object.laterality !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Disease.laterality: object expected",
                  );
                message.laterality =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.laterality,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a Disease message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @static
             * @param {org.phenopackets.schema.v2.core.Disease} message Disease
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Disease.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.arrays || options.defaults) {
                object.diseaseStage = [];
                object.clinicalTnmFinding = [];
              }
              if (options.defaults) {
                object.term = null;
                object.excluded = false;
                object.onset = null;
                object.resolution = null;
                object.primarySite = null;
                object.laterality = null;
              }
              if (message.term != null && message.hasOwnProperty("term"))
                object.term =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.term,
                    options,
                  );
              if (
                message.excluded != null &&
                message.hasOwnProperty("excluded")
              )
                object.excluded = message.excluded;
              if (message.onset != null && message.hasOwnProperty("onset"))
                object.onset =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.onset,
                    options,
                  );
              if (
                message.resolution != null &&
                message.hasOwnProperty("resolution")
              )
                object.resolution =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.resolution,
                    options,
                  );
              if (message.diseaseStage && message.diseaseStage.length) {
                object.diseaseStage = [];
                for (let j = 0; j < message.diseaseStage.length; ++j)
                  object.diseaseStage[j] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                      message.diseaseStage[j],
                      options,
                    );
              }
              if (
                message.clinicalTnmFinding &&
                message.clinicalTnmFinding.length
              ) {
                object.clinicalTnmFinding = [];
                for (let j = 0; j < message.clinicalTnmFinding.length; ++j)
                  object.clinicalTnmFinding[j] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                      message.clinicalTnmFinding[j],
                      options,
                    );
              }
              if (
                message.primarySite != null &&
                message.hasOwnProperty("primarySite")
              )
                object.primarySite =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.primarySite,
                    options,
                  );
              if (
                message.laterality != null &&
                message.hasOwnProperty("laterality")
              )
                object.laterality =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.laterality,
                    options,
                  );
              return object;
            };

            /**
             * Converts this Disease to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Disease.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Disease
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Disease
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Disease.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/org.phenopackets.schema.v2.core.Disease";
            };

            return Disease;
          })();

          core.Interpretation = (function () {
            /**
             * Properties of an Interpretation.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IInterpretation
             * @property {string|null} [id] Interpretation id
             * @property {org.phenopackets.schema.v2.core.Interpretation.ProgressStatus|null} [progressStatus] Interpretation progressStatus
             * @property {org.phenopackets.schema.v2.core.IDiagnosis|null} [diagnosis] Interpretation diagnosis
             * @property {string|null} [summary] Interpretation summary
             */

            /**
             * Constructs a new Interpretation.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents an Interpretation.
             * @implements IInterpretation
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IInterpretation=} [properties] Properties to set
             */
            function Interpretation(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Interpretation id.
             * @member {string} id
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @instance
             */
            Interpretation.prototype.id = "";

            /**
             * Interpretation progressStatus.
             * @member {org.phenopackets.schema.v2.core.Interpretation.ProgressStatus} progressStatus
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @instance
             */
            Interpretation.prototype.progressStatus = 0;

            /**
             * Interpretation diagnosis.
             * @member {org.phenopackets.schema.v2.core.IDiagnosis|null|undefined} diagnosis
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @instance
             */
            Interpretation.prototype.diagnosis = null;

            /**
             * Interpretation summary.
             * @member {string} summary
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @instance
             */
            Interpretation.prototype.summary = "";

            /**
             * Creates a new Interpretation instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.IInterpretation=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Interpretation} Interpretation instance
             */
            Interpretation.create = function create(properties) {
              return new Interpretation(properties);
            };

            /**
             * Encodes the specified Interpretation message. Does not implicitly {@link org.phenopackets.schema.v2.core.Interpretation.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.IInterpretation} message Interpretation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Interpretation.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.id != null &&
                Object.hasOwnProperty.call(message, "id")
              )
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
              if (
                message.progressStatus != null &&
                Object.hasOwnProperty.call(message, "progressStatus")
              )
                writer
                  .uint32(/* id 2, wireType 0 =*/ 16)
                  .int32(message.progressStatus);
              if (
                message.diagnosis != null &&
                Object.hasOwnProperty.call(message, "diagnosis")
              )
                $root.org.phenopackets.schema.v2.core.Diagnosis.encode(
                  message.diagnosis,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              if (
                message.summary != null &&
                Object.hasOwnProperty.call(message, "summary")
              )
                writer
                  .uint32(/* id 4, wireType 2 =*/ 34)
                  .string(message.summary);
              return writer;
            };

            /**
             * Encodes the specified Interpretation message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Interpretation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.IInterpretation} message Interpretation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Interpretation.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Interpretation message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Interpretation} Interpretation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Interpretation.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.Interpretation();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.id = reader.string();
                    break;
                  }
                  case 2: {
                    message.progressStatus = reader.int32();
                    break;
                  }
                  case 3: {
                    message.diagnosis =
                      $root.org.phenopackets.schema.v2.core.Diagnosis.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 4: {
                    message.summary = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes an Interpretation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Interpretation} Interpretation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Interpretation.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Interpretation message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Interpretation.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id)) return "id: string expected";
              if (
                message.progressStatus != null &&
                message.hasOwnProperty("progressStatus")
              )
                switch (message.progressStatus) {
                  default:
                    return "progressStatus: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                    break;
                }
              if (
                message.diagnosis != null &&
                message.hasOwnProperty("diagnosis")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.Diagnosis.verify(
                    message.diagnosis,
                  );
                if (error) return "diagnosis." + error;
              }
              if (message.summary != null && message.hasOwnProperty("summary"))
                if (!$util.isString(message.summary))
                  return "summary: string expected";
              return null;
            };

            /**
             * Creates an Interpretation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Interpretation} Interpretation
             */
            Interpretation.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.Interpretation
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Interpretation();
              if (object.id != null) message.id = String(object.id);
              switch (object.progressStatus) {
                case "UNKNOWN_PROGRESS":
                case 0:
                  message.progressStatus = 0;
                  break;
                case "IN_PROGRESS":
                case 1:
                  message.progressStatus = 1;
                  break;
                case "COMPLETED":
                case 2:
                  message.progressStatus = 2;
                  break;
                case "SOLVED":
                case 3:
                  message.progressStatus = 3;
                  break;
                case "UNSOLVED":
                case 4:
                  message.progressStatus = 4;
                  break;
              }
              if (object.diagnosis != null) {
                if (typeof object.diagnosis !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Interpretation.diagnosis: object expected",
                  );
                message.diagnosis =
                  $root.org.phenopackets.schema.v2.core.Diagnosis.fromObject(
                    object.diagnosis,
                  );
              }
              if (object.summary != null)
                message.summary = String(object.summary);
              return message;
            };

            /**
             * Creates a plain object from an Interpretation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.Interpretation} message Interpretation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Interpretation.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.id = "";
                object.progressStatus =
                  options.enums === String ? "UNKNOWN_PROGRESS" : 0;
                object.diagnosis = null;
                object.summary = "";
              }
              if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
              if (
                message.progressStatus != null &&
                message.hasOwnProperty("progressStatus")
              )
                object.progressStatus =
                  options.enums === String
                    ? $root.org.phenopackets.schema.v2.core.Interpretation
                        .ProgressStatus[message.progressStatus]
                    : message.progressStatus;
              if (
                message.diagnosis != null &&
                message.hasOwnProperty("diagnosis")
              )
                object.diagnosis =
                  $root.org.phenopackets.schema.v2.core.Diagnosis.toObject(
                    message.diagnosis,
                    options,
                  );
              if (message.summary != null && message.hasOwnProperty("summary"))
                object.summary = message.summary;
              return object;
            };

            /**
             * Converts this Interpretation to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Interpretation.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Interpretation
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Interpretation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Interpretation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix +
                "/org.phenopackets.schema.v2.core.Interpretation"
              );
            };

            /**
             * ProgressStatus enum.
             * @name org.phenopackets.schema.v2.core.Interpretation.ProgressStatus
             * @enum {number}
             * @property {number} UNKNOWN_PROGRESS=0 UNKNOWN_PROGRESS value
             * @property {number} IN_PROGRESS=1 IN_PROGRESS value
             * @property {number} COMPLETED=2 COMPLETED value
             * @property {number} SOLVED=3 SOLVED value
             * @property {number} UNSOLVED=4 UNSOLVED value
             */
            Interpretation.ProgressStatus = (function () {
              const valuesById = {},
                values = Object.create(valuesById);
              values[(valuesById[0] = "UNKNOWN_PROGRESS")] = 0;
              values[(valuesById[1] = "IN_PROGRESS")] = 1;
              values[(valuesById[2] = "COMPLETED")] = 2;
              values[(valuesById[3] = "SOLVED")] = 3;
              values[(valuesById[4] = "UNSOLVED")] = 4;
              return values;
            })();

            return Interpretation;
          })();

          core.Diagnosis = (function () {
            /**
             * Properties of a Diagnosis.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IDiagnosis
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [disease] Diagnosis disease
             * @property {Array.<org.phenopackets.schema.v2.core.IGenomicInterpretation>|null} [genomicInterpretations] Diagnosis genomicInterpretations
             */

            /**
             * Constructs a new Diagnosis.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a Diagnosis.
             * @implements IDiagnosis
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IDiagnosis=} [properties] Properties to set
             */
            function Diagnosis(properties) {
              this.genomicInterpretations = [];
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Diagnosis disease.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} disease
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @instance
             */
            Diagnosis.prototype.disease = null;

            /**
             * Diagnosis genomicInterpretations.
             * @member {Array.<org.phenopackets.schema.v2.core.IGenomicInterpretation>} genomicInterpretations
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @instance
             */
            Diagnosis.prototype.genomicInterpretations = $util.emptyArray;

            /**
             * Creates a new Diagnosis instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @static
             * @param {org.phenopackets.schema.v2.core.IDiagnosis=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Diagnosis} Diagnosis instance
             */
            Diagnosis.create = function create(properties) {
              return new Diagnosis(properties);
            };

            /**
             * Encodes the specified Diagnosis message. Does not implicitly {@link org.phenopackets.schema.v2.core.Diagnosis.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @static
             * @param {org.phenopackets.schema.v2.core.IDiagnosis} message Diagnosis message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Diagnosis.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.disease != null &&
                Object.hasOwnProperty.call(message, "disease")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.disease,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.genomicInterpretations != null &&
                message.genomicInterpretations.length
              )
                for (let i = 0; i < message.genomicInterpretations.length; ++i)
                  $root.org.phenopackets.schema.v2.core.GenomicInterpretation.encode(
                    message.genomicInterpretations[i],
                    writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Diagnosis message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Diagnosis.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @static
             * @param {org.phenopackets.schema.v2.core.IDiagnosis} message Diagnosis message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Diagnosis.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Diagnosis message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Diagnosis} Diagnosis
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Diagnosis.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Diagnosis();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.disease =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    if (
                      !(
                        message.genomicInterpretations &&
                        message.genomicInterpretations.length
                      )
                    )
                      message.genomicInterpretations = [];
                    message.genomicInterpretations.push(
                      $root.org.phenopackets.schema.v2.core.GenomicInterpretation.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Diagnosis message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Diagnosis} Diagnosis
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Diagnosis.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Diagnosis message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Diagnosis.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.disease != null &&
                message.hasOwnProperty("disease")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.disease,
                  );
                if (error) return "disease." + error;
              }
              if (
                message.genomicInterpretations != null &&
                message.hasOwnProperty("genomicInterpretations")
              ) {
                if (!Array.isArray(message.genomicInterpretations))
                  return "genomicInterpretations: array expected";
                for (
                  let i = 0;
                  i < message.genomicInterpretations.length;
                  ++i
                ) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.GenomicInterpretation.verify(
                      message.genomicInterpretations[i],
                    );
                  if (error) return "genomicInterpretations." + error;
                }
              }
              return null;
            };

            /**
             * Creates a Diagnosis message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Diagnosis} Diagnosis
             */
            Diagnosis.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.Diagnosis
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Diagnosis();
              if (object.disease != null) {
                if (typeof object.disease !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Diagnosis.disease: object expected",
                  );
                message.disease =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.disease,
                  );
              }
              if (object.genomicInterpretations) {
                if (!Array.isArray(object.genomicInterpretations))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Diagnosis.genomicInterpretations: array expected",
                  );
                message.genomicInterpretations = [];
                for (let i = 0; i < object.genomicInterpretations.length; ++i) {
                  if (typeof object.genomicInterpretations[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.Diagnosis.genomicInterpretations: object expected",
                    );
                  message.genomicInterpretations[i] =
                    $root.org.phenopackets.schema.v2.core.GenomicInterpretation.fromObject(
                      object.genomicInterpretations[i],
                    );
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a Diagnosis message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @static
             * @param {org.phenopackets.schema.v2.core.Diagnosis} message Diagnosis
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Diagnosis.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.arrays || options.defaults)
                object.genomicInterpretations = [];
              if (options.defaults) object.disease = null;
              if (message.disease != null && message.hasOwnProperty("disease"))
                object.disease =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.disease,
                    options,
                  );
              if (
                message.genomicInterpretations &&
                message.genomicInterpretations.length
              ) {
                object.genomicInterpretations = [];
                for (let j = 0; j < message.genomicInterpretations.length; ++j)
                  object.genomicInterpretations[j] =
                    $root.org.phenopackets.schema.v2.core.GenomicInterpretation.toObject(
                      message.genomicInterpretations[j],
                      options,
                    );
              }
              return object;
            };

            /**
             * Converts this Diagnosis to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Diagnosis.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Diagnosis
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Diagnosis
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Diagnosis.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.Diagnosis"
              );
            };

            return Diagnosis;
          })();

          core.GenomicInterpretation = (function () {
            /**
             * Properties of a GenomicInterpretation.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IGenomicInterpretation
             * @property {string|null} [subjectOrBiosampleId] GenomicInterpretation subjectOrBiosampleId
             * @property {org.phenopackets.schema.v2.core.GenomicInterpretation.InterpretationStatus|null} [interpretationStatus] GenomicInterpretation interpretationStatus
             * @property {org.ga4gh.vrsatile.v1.IGeneDescriptor|null} [gene] GenomicInterpretation gene
             * @property {org.phenopackets.schema.v2.core.IVariantInterpretation|null} [variantInterpretation] GenomicInterpretation variantInterpretation
             */

            /**
             * Constructs a new GenomicInterpretation.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a GenomicInterpretation.
             * @implements IGenomicInterpretation
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IGenomicInterpretation=} [properties] Properties to set
             */
            function GenomicInterpretation(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * GenomicInterpretation subjectOrBiosampleId.
             * @member {string} subjectOrBiosampleId
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @instance
             */
            GenomicInterpretation.prototype.subjectOrBiosampleId = "";

            /**
             * GenomicInterpretation interpretationStatus.
             * @member {org.phenopackets.schema.v2.core.GenomicInterpretation.InterpretationStatus} interpretationStatus
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @instance
             */
            GenomicInterpretation.prototype.interpretationStatus = 0;

            /**
             * GenomicInterpretation gene.
             * @member {org.ga4gh.vrsatile.v1.IGeneDescriptor|null|undefined} gene
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @instance
             */
            GenomicInterpretation.prototype.gene = null;

            /**
             * GenomicInterpretation variantInterpretation.
             * @member {org.phenopackets.schema.v2.core.IVariantInterpretation|null|undefined} variantInterpretation
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @instance
             */
            GenomicInterpretation.prototype.variantInterpretation = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GenomicInterpretation call.
             * @member {"gene"|"variantInterpretation"|undefined} call
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @instance
             */
            Object.defineProperty(GenomicInterpretation.prototype, "call", {
              get: $util.oneOfGetter(
                ($oneOfFields = ["gene", "variantInterpretation"]),
              ),
              set: $util.oneOfSetter($oneOfFields),
            });

            /**
             * Creates a new GenomicInterpretation instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.IGenomicInterpretation=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.GenomicInterpretation} GenomicInterpretation instance
             */
            GenomicInterpretation.create = function create(properties) {
              return new GenomicInterpretation(properties);
            };

            /**
             * Encodes the specified GenomicInterpretation message. Does not implicitly {@link org.phenopackets.schema.v2.core.GenomicInterpretation.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.IGenomicInterpretation} message GenomicInterpretation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GenomicInterpretation.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.subjectOrBiosampleId != null &&
                Object.hasOwnProperty.call(message, "subjectOrBiosampleId")
              )
                writer
                  .uint32(/* id 1, wireType 2 =*/ 10)
                  .string(message.subjectOrBiosampleId);
              if (
                message.interpretationStatus != null &&
                Object.hasOwnProperty.call(message, "interpretationStatus")
              )
                writer
                  .uint32(/* id 2, wireType 0 =*/ 16)
                  .int32(message.interpretationStatus);
              if (
                message.gene != null &&
                Object.hasOwnProperty.call(message, "gene")
              )
                $root.org.ga4gh.vrsatile.v1.GeneDescriptor.encode(
                  message.gene,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              if (
                message.variantInterpretation != null &&
                Object.hasOwnProperty.call(message, "variantInterpretation")
              )
                $root.org.phenopackets.schema.v2.core.VariantInterpretation.encode(
                  message.variantInterpretation,
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified GenomicInterpretation message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.GenomicInterpretation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.IGenomicInterpretation} message GenomicInterpretation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GenomicInterpretation.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GenomicInterpretation message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.GenomicInterpretation} GenomicInterpretation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GenomicInterpretation.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.GenomicInterpretation();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.subjectOrBiosampleId = reader.string();
                    break;
                  }
                  case 2: {
                    message.interpretationStatus = reader.int32();
                    break;
                  }
                  case 3: {
                    message.gene =
                      $root.org.ga4gh.vrsatile.v1.GeneDescriptor.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 4: {
                    message.variantInterpretation =
                      $root.org.phenopackets.schema.v2.core.VariantInterpretation.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a GenomicInterpretation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.GenomicInterpretation} GenomicInterpretation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GenomicInterpretation.decodeDelimited = function decodeDelimited(
              reader,
            ) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GenomicInterpretation message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GenomicInterpretation.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              let properties = {};
              if (
                message.subjectOrBiosampleId != null &&
                message.hasOwnProperty("subjectOrBiosampleId")
              )
                if (!$util.isString(message.subjectOrBiosampleId))
                  return "subjectOrBiosampleId: string expected";
              if (
                message.interpretationStatus != null &&
                message.hasOwnProperty("interpretationStatus")
              )
                switch (message.interpretationStatus) {
                  default:
                    return "interpretationStatus: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                    break;
                }
              if (message.gene != null && message.hasOwnProperty("gene")) {
                properties.call = 1;
                {
                  let error = $root.org.ga4gh.vrsatile.v1.GeneDescriptor.verify(
                    message.gene,
                  );
                  if (error) return "gene." + error;
                }
              }
              if (
                message.variantInterpretation != null &&
                message.hasOwnProperty("variantInterpretation")
              ) {
                if (properties.call === 1) return "call: multiple values";
                properties.call = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.VariantInterpretation.verify(
                      message.variantInterpretation,
                    );
                  if (error) return "variantInterpretation." + error;
                }
              }
              return null;
            };

            /**
             * Creates a GenomicInterpretation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.GenomicInterpretation} GenomicInterpretation
             */
            GenomicInterpretation.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.GenomicInterpretation
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.GenomicInterpretation();
              if (object.subjectOrBiosampleId != null)
                message.subjectOrBiosampleId = String(
                  object.subjectOrBiosampleId,
                );
              switch (object.interpretationStatus) {
                case "UNKNOWN_STATUS":
                case 0:
                  message.interpretationStatus = 0;
                  break;
                case "REJECTED":
                case 1:
                  message.interpretationStatus = 1;
                  break;
                case "CANDIDATE":
                case 2:
                  message.interpretationStatus = 2;
                  break;
                case "CONTRIBUTORY":
                case 3:
                  message.interpretationStatus = 3;
                  break;
                case "CAUSATIVE":
                case 4:
                  message.interpretationStatus = 4;
                  break;
              }
              if (object.gene != null) {
                if (typeof object.gene !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.GenomicInterpretation.gene: object expected",
                  );
                message.gene =
                  $root.org.ga4gh.vrsatile.v1.GeneDescriptor.fromObject(
                    object.gene,
                  );
              }
              if (object.variantInterpretation != null) {
                if (typeof object.variantInterpretation !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.GenomicInterpretation.variantInterpretation: object expected",
                  );
                message.variantInterpretation =
                  $root.org.phenopackets.schema.v2.core.VariantInterpretation.fromObject(
                    object.variantInterpretation,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a GenomicInterpretation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.GenomicInterpretation} message GenomicInterpretation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GenomicInterpretation.toObject = function toObject(
              message,
              options,
            ) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.subjectOrBiosampleId = "";
                object.interpretationStatus =
                  options.enums === String ? "UNKNOWN_STATUS" : 0;
              }
              if (
                message.subjectOrBiosampleId != null &&
                message.hasOwnProperty("subjectOrBiosampleId")
              )
                object.subjectOrBiosampleId = message.subjectOrBiosampleId;
              if (
                message.interpretationStatus != null &&
                message.hasOwnProperty("interpretationStatus")
              )
                object.interpretationStatus =
                  options.enums === String
                    ? $root.org.phenopackets.schema.v2.core
                        .GenomicInterpretation.InterpretationStatus[
                        message.interpretationStatus
                      ]
                    : message.interpretationStatus;
              if (message.gene != null && message.hasOwnProperty("gene")) {
                object.gene =
                  $root.org.ga4gh.vrsatile.v1.GeneDescriptor.toObject(
                    message.gene,
                    options,
                  );
                if (options.oneofs) object.call = "gene";
              }
              if (
                message.variantInterpretation != null &&
                message.hasOwnProperty("variantInterpretation")
              ) {
                object.variantInterpretation =
                  $root.org.phenopackets.schema.v2.core.VariantInterpretation.toObject(
                    message.variantInterpretation,
                    options,
                  );
                if (options.oneofs) object.call = "variantInterpretation";
              }
              return object;
            };

            /**
             * Converts this GenomicInterpretation to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GenomicInterpretation.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for GenomicInterpretation
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.GenomicInterpretation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GenomicInterpretation.getTypeUrl = function getTypeUrl(
              typeUrlPrefix,
            ) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix +
                "/org.phenopackets.schema.v2.core.GenomicInterpretation"
              );
            };

            /**
             * InterpretationStatus enum.
             * @name org.phenopackets.schema.v2.core.GenomicInterpretation.InterpretationStatus
             * @enum {number}
             * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
             * @property {number} REJECTED=1 REJECTED value
             * @property {number} CANDIDATE=2 CANDIDATE value
             * @property {number} CONTRIBUTORY=3 CONTRIBUTORY value
             * @property {number} CAUSATIVE=4 CAUSATIVE value
             */
            GenomicInterpretation.InterpretationStatus = (function () {
              const valuesById = {},
                values = Object.create(valuesById);
              values[(valuesById[0] = "UNKNOWN_STATUS")] = 0;
              values[(valuesById[1] = "REJECTED")] = 1;
              values[(valuesById[2] = "CANDIDATE")] = 2;
              values[(valuesById[3] = "CONTRIBUTORY")] = 3;
              values[(valuesById[4] = "CAUSATIVE")] = 4;
              return values;
            })();

            return GenomicInterpretation;
          })();

          /**
           * AcmgPathogenicityClassification enum.
           * @name org.phenopackets.schema.v2.core.AcmgPathogenicityClassification
           * @enum {number}
           * @property {number} NOT_PROVIDED=0 NOT_PROVIDED value
           * @property {number} BENIGN=1 BENIGN value
           * @property {number} LIKELY_BENIGN=2 LIKELY_BENIGN value
           * @property {number} UNCERTAIN_SIGNIFICANCE=3 UNCERTAIN_SIGNIFICANCE value
           * @property {number} LIKELY_PATHOGENIC=4 LIKELY_PATHOGENIC value
           * @property {number} PATHOGENIC=5 PATHOGENIC value
           */
          core.AcmgPathogenicityClassification = (function () {
            const valuesById = {},
              values = Object.create(valuesById);
            values[(valuesById[0] = "NOT_PROVIDED")] = 0;
            values[(valuesById[1] = "BENIGN")] = 1;
            values[(valuesById[2] = "LIKELY_BENIGN")] = 2;
            values[(valuesById[3] = "UNCERTAIN_SIGNIFICANCE")] = 3;
            values[(valuesById[4] = "LIKELY_PATHOGENIC")] = 4;
            values[(valuesById[5] = "PATHOGENIC")] = 5;
            return values;
          })();

          /**
           * TherapeuticActionability enum.
           * @name org.phenopackets.schema.v2.core.TherapeuticActionability
           * @enum {number}
           * @property {number} UNKNOWN_ACTIONABILITY=0 UNKNOWN_ACTIONABILITY value
           * @property {number} NOT_ACTIONABLE=1 NOT_ACTIONABLE value
           * @property {number} ACTIONABLE=2 ACTIONABLE value
           */
          core.TherapeuticActionability = (function () {
            const valuesById = {},
              values = Object.create(valuesById);
            values[(valuesById[0] = "UNKNOWN_ACTIONABILITY")] = 0;
            values[(valuesById[1] = "NOT_ACTIONABLE")] = 1;
            values[(valuesById[2] = "ACTIONABLE")] = 2;
            return values;
          })();

          core.VariantInterpretation = (function () {
            /**
             * Properties of a VariantInterpretation.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IVariantInterpretation
             * @property {org.phenopackets.schema.v2.core.AcmgPathogenicityClassification|null} [acmgPathogenicityClassification] VariantInterpretation acmgPathogenicityClassification
             * @property {org.phenopackets.schema.v2.core.TherapeuticActionability|null} [therapeuticActionability] VariantInterpretation therapeuticActionability
             * @property {org.ga4gh.vrsatile.v1.IVariationDescriptor|null} [variationDescriptor] VariantInterpretation variationDescriptor
             */

            /**
             * Constructs a new VariantInterpretation.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a VariantInterpretation.
             * @implements IVariantInterpretation
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IVariantInterpretation=} [properties] Properties to set
             */
            function VariantInterpretation(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * VariantInterpretation acmgPathogenicityClassification.
             * @member {org.phenopackets.schema.v2.core.AcmgPathogenicityClassification} acmgPathogenicityClassification
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @instance
             */
            VariantInterpretation.prototype.acmgPathogenicityClassification = 0;

            /**
             * VariantInterpretation therapeuticActionability.
             * @member {org.phenopackets.schema.v2.core.TherapeuticActionability} therapeuticActionability
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @instance
             */
            VariantInterpretation.prototype.therapeuticActionability = 0;

            /**
             * VariantInterpretation variationDescriptor.
             * @member {org.ga4gh.vrsatile.v1.IVariationDescriptor|null|undefined} variationDescriptor
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @instance
             */
            VariantInterpretation.prototype.variationDescriptor = null;

            /**
             * Creates a new VariantInterpretation instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.IVariantInterpretation=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.VariantInterpretation} VariantInterpretation instance
             */
            VariantInterpretation.create = function create(properties) {
              return new VariantInterpretation(properties);
            };

            /**
             * Encodes the specified VariantInterpretation message. Does not implicitly {@link org.phenopackets.schema.v2.core.VariantInterpretation.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.IVariantInterpretation} message VariantInterpretation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VariantInterpretation.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.acmgPathogenicityClassification != null &&
                Object.hasOwnProperty.call(
                  message,
                  "acmgPathogenicityClassification",
                )
              )
                writer
                  .uint32(/* id 1, wireType 0 =*/ 8)
                  .int32(message.acmgPathogenicityClassification);
              if (
                message.therapeuticActionability != null &&
                Object.hasOwnProperty.call(message, "therapeuticActionability")
              )
                writer
                  .uint32(/* id 2, wireType 0 =*/ 16)
                  .int32(message.therapeuticActionability);
              if (
                message.variationDescriptor != null &&
                Object.hasOwnProperty.call(message, "variationDescriptor")
              )
                $root.org.ga4gh.vrsatile.v1.VariationDescriptor.encode(
                  message.variationDescriptor,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified VariantInterpretation message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.VariantInterpretation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.IVariantInterpretation} message VariantInterpretation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VariantInterpretation.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VariantInterpretation message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.VariantInterpretation} VariantInterpretation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VariantInterpretation.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.VariantInterpretation();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.acmgPathogenicityClassification = reader.int32();
                    break;
                  }
                  case 2: {
                    message.therapeuticActionability = reader.int32();
                    break;
                  }
                  case 3: {
                    message.variationDescriptor =
                      $root.org.ga4gh.vrsatile.v1.VariationDescriptor.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a VariantInterpretation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.VariantInterpretation} VariantInterpretation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VariantInterpretation.decodeDelimited = function decodeDelimited(
              reader,
            ) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VariantInterpretation message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VariantInterpretation.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.acmgPathogenicityClassification != null &&
                message.hasOwnProperty("acmgPathogenicityClassification")
              )
                switch (message.acmgPathogenicityClassification) {
                  default:
                    return "acmgPathogenicityClassification: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                    break;
                }
              if (
                message.therapeuticActionability != null &&
                message.hasOwnProperty("therapeuticActionability")
              )
                switch (message.therapeuticActionability) {
                  default:
                    return "therapeuticActionability: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                    break;
                }
              if (
                message.variationDescriptor != null &&
                message.hasOwnProperty("variationDescriptor")
              ) {
                let error =
                  $root.org.ga4gh.vrsatile.v1.VariationDescriptor.verify(
                    message.variationDescriptor,
                  );
                if (error) return "variationDescriptor." + error;
              }
              return null;
            };

            /**
             * Creates a VariantInterpretation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.VariantInterpretation} VariantInterpretation
             */
            VariantInterpretation.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.VariantInterpretation
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.VariantInterpretation();
              switch (object.acmgPathogenicityClassification) {
                case "NOT_PROVIDED":
                case 0:
                  message.acmgPathogenicityClassification = 0;
                  break;
                case "BENIGN":
                case 1:
                  message.acmgPathogenicityClassification = 1;
                  break;
                case "LIKELY_BENIGN":
                case 2:
                  message.acmgPathogenicityClassification = 2;
                  break;
                case "UNCERTAIN_SIGNIFICANCE":
                case 3:
                  message.acmgPathogenicityClassification = 3;
                  break;
                case "LIKELY_PATHOGENIC":
                case 4:
                  message.acmgPathogenicityClassification = 4;
                  break;
                case "PATHOGENIC":
                case 5:
                  message.acmgPathogenicityClassification = 5;
                  break;
              }
              switch (object.therapeuticActionability) {
                case "UNKNOWN_ACTIONABILITY":
                case 0:
                  message.therapeuticActionability = 0;
                  break;
                case "NOT_ACTIONABLE":
                case 1:
                  message.therapeuticActionability = 1;
                  break;
                case "ACTIONABLE":
                case 2:
                  message.therapeuticActionability = 2;
                  break;
              }
              if (object.variationDescriptor != null) {
                if (typeof object.variationDescriptor !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.VariantInterpretation.variationDescriptor: object expected",
                  );
                message.variationDescriptor =
                  $root.org.ga4gh.vrsatile.v1.VariationDescriptor.fromObject(
                    object.variationDescriptor,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a VariantInterpretation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @static
             * @param {org.phenopackets.schema.v2.core.VariantInterpretation} message VariantInterpretation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VariantInterpretation.toObject = function toObject(
              message,
              options,
            ) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.acmgPathogenicityClassification =
                  options.enums === String ? "NOT_PROVIDED" : 0;
                object.therapeuticActionability =
                  options.enums === String ? "UNKNOWN_ACTIONABILITY" : 0;
                object.variationDescriptor = null;
              }
              if (
                message.acmgPathogenicityClassification != null &&
                message.hasOwnProperty("acmgPathogenicityClassification")
              )
                object.acmgPathogenicityClassification =
                  options.enums === String
                    ? $root.org.phenopackets.schema.v2.core
                        .AcmgPathogenicityClassification[
                        message.acmgPathogenicityClassification
                      ]
                    : message.acmgPathogenicityClassification;
              if (
                message.therapeuticActionability != null &&
                message.hasOwnProperty("therapeuticActionability")
              )
                object.therapeuticActionability =
                  options.enums === String
                    ? $root.org.phenopackets.schema.v2.core
                        .TherapeuticActionability[
                        message.therapeuticActionability
                      ]
                    : message.therapeuticActionability;
              if (
                message.variationDescriptor != null &&
                message.hasOwnProperty("variationDescriptor")
              )
                object.variationDescriptor =
                  $root.org.ga4gh.vrsatile.v1.VariationDescriptor.toObject(
                    message.variationDescriptor,
                    options,
                  );
              return object;
            };

            /**
             * Converts this VariantInterpretation to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VariantInterpretation.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for VariantInterpretation
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.VariantInterpretation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VariantInterpretation.getTypeUrl = function getTypeUrl(
              typeUrlPrefix,
            ) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix +
                "/org.phenopackets.schema.v2.core.VariantInterpretation"
              );
            };

            return VariantInterpretation;
          })();

          core.Individual = (function () {
            /**
             * Properties of an Individual.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IIndividual
             * @property {string|null} [id] Individual id
             * @property {Array.<string>|null} [alternateIds] Individual alternateIds
             * @property {google.protobuf.ITimestamp|null} [dateOfBirth] Individual dateOfBirth
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [timeAtLastEncounter] Individual timeAtLastEncounter
             * @property {org.phenopackets.schema.v2.core.IVitalStatus|null} [vitalStatus] Individual vitalStatus
             * @property {org.phenopackets.schema.v2.core.Sex|null} [sex] Individual sex
             * @property {org.phenopackets.schema.v2.core.KaryotypicSex|null} [karyotypicSex] Individual karyotypicSex
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [gender] Individual gender
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [taxonomy] Individual taxonomy
             */

            /**
             * Constructs a new Individual.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents an Individual.
             * @implements IIndividual
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IIndividual=} [properties] Properties to set
             */
            function Individual(properties) {
              this.alternateIds = [];
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Individual id.
             * @member {string} id
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @instance
             */
            Individual.prototype.id = "";

            /**
             * Individual alternateIds.
             * @member {Array.<string>} alternateIds
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @instance
             */
            Individual.prototype.alternateIds = $util.emptyArray;

            /**
             * Individual dateOfBirth.
             * @member {google.protobuf.ITimestamp|null|undefined} dateOfBirth
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @instance
             */
            Individual.prototype.dateOfBirth = null;

            /**
             * Individual timeAtLastEncounter.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} timeAtLastEncounter
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @instance
             */
            Individual.prototype.timeAtLastEncounter = null;

            /**
             * Individual vitalStatus.
             * @member {org.phenopackets.schema.v2.core.IVitalStatus|null|undefined} vitalStatus
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @instance
             */
            Individual.prototype.vitalStatus = null;

            /**
             * Individual sex.
             * @member {org.phenopackets.schema.v2.core.Sex} sex
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @instance
             */
            Individual.prototype.sex = 0;

            /**
             * Individual karyotypicSex.
             * @member {org.phenopackets.schema.v2.core.KaryotypicSex} karyotypicSex
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @instance
             */
            Individual.prototype.karyotypicSex = 0;

            /**
             * Individual gender.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} gender
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @instance
             */
            Individual.prototype.gender = null;

            /**
             * Individual taxonomy.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} taxonomy
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @instance
             */
            Individual.prototype.taxonomy = null;

            /**
             * Creates a new Individual instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @static
             * @param {org.phenopackets.schema.v2.core.IIndividual=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Individual} Individual instance
             */
            Individual.create = function create(properties) {
              return new Individual(properties);
            };

            /**
             * Encodes the specified Individual message. Does not implicitly {@link org.phenopackets.schema.v2.core.Individual.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @static
             * @param {org.phenopackets.schema.v2.core.IIndividual} message Individual message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Individual.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.id != null &&
                Object.hasOwnProperty.call(message, "id")
              )
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
              if (message.alternateIds != null && message.alternateIds.length)
                for (let i = 0; i < message.alternateIds.length; ++i)
                  writer
                    .uint32(/* id 2, wireType 2 =*/ 18)
                    .string(message.alternateIds[i]);
              if (
                message.dateOfBirth != null &&
                Object.hasOwnProperty.call(message, "dateOfBirth")
              )
                $root.google.protobuf.Timestamp.encode(
                  message.dateOfBirth,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              if (
                message.timeAtLastEncounter != null &&
                Object.hasOwnProperty.call(message, "timeAtLastEncounter")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.timeAtLastEncounter,
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
              if (
                message.vitalStatus != null &&
                Object.hasOwnProperty.call(message, "vitalStatus")
              )
                $root.org.phenopackets.schema.v2.core.VitalStatus.encode(
                  message.vitalStatus,
                  writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                ).ldelim();
              if (
                message.sex != null &&
                Object.hasOwnProperty.call(message, "sex")
              )
                writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.sex);
              if (
                message.karyotypicSex != null &&
                Object.hasOwnProperty.call(message, "karyotypicSex")
              )
                writer
                  .uint32(/* id 7, wireType 0 =*/ 56)
                  .int32(message.karyotypicSex);
              if (
                message.gender != null &&
                Object.hasOwnProperty.call(message, "gender")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.gender,
                  writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
                ).ldelim();
              if (
                message.taxonomy != null &&
                Object.hasOwnProperty.call(message, "taxonomy")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.taxonomy,
                  writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Individual message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Individual.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @static
             * @param {org.phenopackets.schema.v2.core.IIndividual} message Individual message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Individual.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Individual message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Individual} Individual
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Individual.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.Individual();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.id = reader.string();
                    break;
                  }
                  case 2: {
                    if (!(message.alternateIds && message.alternateIds.length))
                      message.alternateIds = [];
                    message.alternateIds.push(reader.string());
                    break;
                  }
                  case 3: {
                    message.dateOfBirth =
                      $root.google.protobuf.Timestamp.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 4: {
                    message.timeAtLastEncounter =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 5: {
                    message.vitalStatus =
                      $root.org.phenopackets.schema.v2.core.VitalStatus.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 6: {
                    message.sex = reader.int32();
                    break;
                  }
                  case 7: {
                    message.karyotypicSex = reader.int32();
                    break;
                  }
                  case 8: {
                    message.gender =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 9: {
                    message.taxonomy =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes an Individual message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Individual} Individual
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Individual.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Individual message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Individual.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id)) return "id: string expected";
              if (
                message.alternateIds != null &&
                message.hasOwnProperty("alternateIds")
              ) {
                if (!Array.isArray(message.alternateIds))
                  return "alternateIds: array expected";
                for (let i = 0; i < message.alternateIds.length; ++i)
                  if (!$util.isString(message.alternateIds[i]))
                    return "alternateIds: string[] expected";
              }
              if (
                message.dateOfBirth != null &&
                message.hasOwnProperty("dateOfBirth")
              ) {
                let error = $root.google.protobuf.Timestamp.verify(
                  message.dateOfBirth,
                );
                if (error) return "dateOfBirth." + error;
              }
              if (
                message.timeAtLastEncounter != null &&
                message.hasOwnProperty("timeAtLastEncounter")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.timeAtLastEncounter,
                  );
                if (error) return "timeAtLastEncounter." + error;
              }
              if (
                message.vitalStatus != null &&
                message.hasOwnProperty("vitalStatus")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.VitalStatus.verify(
                    message.vitalStatus,
                  );
                if (error) return "vitalStatus." + error;
              }
              if (message.sex != null && message.hasOwnProperty("sex"))
                switch (message.sex) {
                  default:
                    return "sex: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                    break;
                }
              if (
                message.karyotypicSex != null &&
                message.hasOwnProperty("karyotypicSex")
              )
                switch (message.karyotypicSex) {
                  default:
                    return "karyotypicSex: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                  case 4:
                  case 5:
                  case 6:
                  case 7:
                  case 8:
                  case 9:
                  case 10:
                    break;
                }
              if (message.gender != null && message.hasOwnProperty("gender")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.gender,
                  );
                if (error) return "gender." + error;
              }
              if (
                message.taxonomy != null &&
                message.hasOwnProperty("taxonomy")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.taxonomy,
                  );
                if (error) return "taxonomy." + error;
              }
              return null;
            };

            /**
             * Creates an Individual message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Individual} Individual
             */
            Individual.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.Individual
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Individual();
              if (object.id != null) message.id = String(object.id);
              if (object.alternateIds) {
                if (!Array.isArray(object.alternateIds))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Individual.alternateIds: array expected",
                  );
                message.alternateIds = [];
                for (let i = 0; i < object.alternateIds.length; ++i)
                  message.alternateIds[i] = String(object.alternateIds[i]);
              }
              if (object.dateOfBirth != null) {
                if (typeof object.dateOfBirth !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Individual.dateOfBirth: object expected",
                  );
                message.dateOfBirth =
                  $root.google.protobuf.Timestamp.fromObject(
                    object.dateOfBirth,
                  );
              }
              if (object.timeAtLastEncounter != null) {
                if (typeof object.timeAtLastEncounter !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Individual.timeAtLastEncounter: object expected",
                  );
                message.timeAtLastEncounter =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.timeAtLastEncounter,
                  );
              }
              if (object.vitalStatus != null) {
                if (typeof object.vitalStatus !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Individual.vitalStatus: object expected",
                  );
                message.vitalStatus =
                  $root.org.phenopackets.schema.v2.core.VitalStatus.fromObject(
                    object.vitalStatus,
                  );
              }
              switch (object.sex) {
                case "UNKNOWN_SEX":
                case 0:
                  message.sex = 0;
                  break;
                case "FEMALE":
                case 1:
                  message.sex = 1;
                  break;
                case "MALE":
                case 2:
                  message.sex = 2;
                  break;
                case "OTHER_SEX":
                case 3:
                  message.sex = 3;
                  break;
              }
              switch (object.karyotypicSex) {
                case "UNKNOWN_KARYOTYPE":
                case 0:
                  message.karyotypicSex = 0;
                  break;
                case "XX":
                case 1:
                  message.karyotypicSex = 1;
                  break;
                case "XY":
                case 2:
                  message.karyotypicSex = 2;
                  break;
                case "XO":
                case 3:
                  message.karyotypicSex = 3;
                  break;
                case "XXY":
                case 4:
                  message.karyotypicSex = 4;
                  break;
                case "XXX":
                case 5:
                  message.karyotypicSex = 5;
                  break;
                case "XXYY":
                case 6:
                  message.karyotypicSex = 6;
                  break;
                case "XXXY":
                case 7:
                  message.karyotypicSex = 7;
                  break;
                case "XXXX":
                case 8:
                  message.karyotypicSex = 8;
                  break;
                case "XYY":
                case 9:
                  message.karyotypicSex = 9;
                  break;
                case "OTHER_KARYOTYPE":
                case 10:
                  message.karyotypicSex = 10;
                  break;
              }
              if (object.gender != null) {
                if (typeof object.gender !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Individual.gender: object expected",
                  );
                message.gender =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.gender,
                  );
              }
              if (object.taxonomy != null) {
                if (typeof object.taxonomy !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Individual.taxonomy: object expected",
                  );
                message.taxonomy =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.taxonomy,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from an Individual message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @static
             * @param {org.phenopackets.schema.v2.core.Individual} message Individual
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Individual.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.arrays || options.defaults) object.alternateIds = [];
              if (options.defaults) {
                object.id = "";
                object.dateOfBirth = null;
                object.timeAtLastEncounter = null;
                object.vitalStatus = null;
                object.sex = options.enums === String ? "UNKNOWN_SEX" : 0;
                object.karyotypicSex =
                  options.enums === String ? "UNKNOWN_KARYOTYPE" : 0;
                object.gender = null;
                object.taxonomy = null;
              }
              if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
              if (message.alternateIds && message.alternateIds.length) {
                object.alternateIds = [];
                for (let j = 0; j < message.alternateIds.length; ++j)
                  object.alternateIds[j] = message.alternateIds[j];
              }
              if (
                message.dateOfBirth != null &&
                message.hasOwnProperty("dateOfBirth")
              )
                object.dateOfBirth = $root.google.protobuf.Timestamp.toObject(
                  message.dateOfBirth,
                  options,
                );
              if (
                message.timeAtLastEncounter != null &&
                message.hasOwnProperty("timeAtLastEncounter")
              )
                object.timeAtLastEncounter =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.timeAtLastEncounter,
                    options,
                  );
              if (
                message.vitalStatus != null &&
                message.hasOwnProperty("vitalStatus")
              )
                object.vitalStatus =
                  $root.org.phenopackets.schema.v2.core.VitalStatus.toObject(
                    message.vitalStatus,
                    options,
                  );
              if (message.sex != null && message.hasOwnProperty("sex"))
                object.sex =
                  options.enums === String
                    ? $root.org.phenopackets.schema.v2.core.Sex[message.sex]
                    : message.sex;
              if (
                message.karyotypicSex != null &&
                message.hasOwnProperty("karyotypicSex")
              )
                object.karyotypicSex =
                  options.enums === String
                    ? $root.org.phenopackets.schema.v2.core.KaryotypicSex[
                        message.karyotypicSex
                      ]
                    : message.karyotypicSex;
              if (message.gender != null && message.hasOwnProperty("gender"))
                object.gender =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.gender,
                    options,
                  );
              if (
                message.taxonomy != null &&
                message.hasOwnProperty("taxonomy")
              )
                object.taxonomy =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.taxonomy,
                    options,
                  );
              return object;
            };

            /**
             * Converts this Individual to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Individual.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Individual
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Individual
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Individual.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.Individual"
              );
            };

            return Individual;
          })();

          core.VitalStatus = (function () {
            /**
             * Properties of a VitalStatus.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IVitalStatus
             * @property {org.phenopackets.schema.v2.core.VitalStatus.Status|null} [status] VitalStatus status
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [timeOfDeath] VitalStatus timeOfDeath
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [causeOfDeath] VitalStatus causeOfDeath
             * @property {number|null} [survivalTimeInDays] VitalStatus survivalTimeInDays
             */

            /**
             * Constructs a new VitalStatus.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a VitalStatus.
             * @implements IVitalStatus
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IVitalStatus=} [properties] Properties to set
             */
            function VitalStatus(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * VitalStatus status.
             * @member {org.phenopackets.schema.v2.core.VitalStatus.Status} status
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @instance
             */
            VitalStatus.prototype.status = 0;

            /**
             * VitalStatus timeOfDeath.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} timeOfDeath
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @instance
             */
            VitalStatus.prototype.timeOfDeath = null;

            /**
             * VitalStatus causeOfDeath.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} causeOfDeath
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @instance
             */
            VitalStatus.prototype.causeOfDeath = null;

            /**
             * VitalStatus survivalTimeInDays.
             * @member {number} survivalTimeInDays
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @instance
             */
            VitalStatus.prototype.survivalTimeInDays = 0;

            /**
             * Creates a new VitalStatus instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @static
             * @param {org.phenopackets.schema.v2.core.IVitalStatus=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.VitalStatus} VitalStatus instance
             */
            VitalStatus.create = function create(properties) {
              return new VitalStatus(properties);
            };

            /**
             * Encodes the specified VitalStatus message. Does not implicitly {@link org.phenopackets.schema.v2.core.VitalStatus.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @static
             * @param {org.phenopackets.schema.v2.core.IVitalStatus} message VitalStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VitalStatus.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.status != null &&
                Object.hasOwnProperty.call(message, "status")
              )
                writer.uint32(/* id 1, wireType 0 =*/ 8).int32(message.status);
              if (
                message.timeOfDeath != null &&
                Object.hasOwnProperty.call(message, "timeOfDeath")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.timeOfDeath,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (
                message.causeOfDeath != null &&
                Object.hasOwnProperty.call(message, "causeOfDeath")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.causeOfDeath,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              if (
                message.survivalTimeInDays != null &&
                Object.hasOwnProperty.call(message, "survivalTimeInDays")
              )
                writer
                  .uint32(/* id 4, wireType 0 =*/ 32)
                  .uint32(message.survivalTimeInDays);
              return writer;
            };

            /**
             * Encodes the specified VitalStatus message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.VitalStatus.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @static
             * @param {org.phenopackets.schema.v2.core.IVitalStatus} message VitalStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VitalStatus.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VitalStatus message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.VitalStatus} VitalStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VitalStatus.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.VitalStatus();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.status = reader.int32();
                    break;
                  }
                  case 2: {
                    message.timeOfDeath =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 3: {
                    message.causeOfDeath =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 4: {
                    message.survivalTimeInDays = reader.uint32();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a VitalStatus message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.VitalStatus} VitalStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VitalStatus.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VitalStatus message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VitalStatus.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                  default:
                    return "status: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                    break;
                }
              if (
                message.timeOfDeath != null &&
                message.hasOwnProperty("timeOfDeath")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.timeOfDeath,
                  );
                if (error) return "timeOfDeath." + error;
              }
              if (
                message.causeOfDeath != null &&
                message.hasOwnProperty("causeOfDeath")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.causeOfDeath,
                  );
                if (error) return "causeOfDeath." + error;
              }
              if (
                message.survivalTimeInDays != null &&
                message.hasOwnProperty("survivalTimeInDays")
              )
                if (!$util.isInteger(message.survivalTimeInDays))
                  return "survivalTimeInDays: integer expected";
              return null;
            };

            /**
             * Creates a VitalStatus message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.VitalStatus} VitalStatus
             */
            VitalStatus.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.VitalStatus
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.VitalStatus();
              switch (object.status) {
                case "UNKNOWN_STATUS":
                case 0:
                  message.status = 0;
                  break;
                case "ALIVE":
                case 1:
                  message.status = 1;
                  break;
                case "DECEASED":
                case 2:
                  message.status = 2;
                  break;
              }
              if (object.timeOfDeath != null) {
                if (typeof object.timeOfDeath !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.VitalStatus.timeOfDeath: object expected",
                  );
                message.timeOfDeath =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.timeOfDeath,
                  );
              }
              if (object.causeOfDeath != null) {
                if (typeof object.causeOfDeath !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.VitalStatus.causeOfDeath: object expected",
                  );
                message.causeOfDeath =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.causeOfDeath,
                  );
              }
              if (object.survivalTimeInDays != null)
                message.survivalTimeInDays = object.survivalTimeInDays >>> 0;
              return message;
            };

            /**
             * Creates a plain object from a VitalStatus message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @static
             * @param {org.phenopackets.schema.v2.core.VitalStatus} message VitalStatus
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VitalStatus.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN_STATUS" : 0;
                object.timeOfDeath = null;
                object.causeOfDeath = null;
                object.survivalTimeInDays = 0;
              }
              if (message.status != null && message.hasOwnProperty("status"))
                object.status =
                  options.enums === String
                    ? $root.org.phenopackets.schema.v2.core.VitalStatus.Status[
                        message.status
                      ]
                    : message.status;
              if (
                message.timeOfDeath != null &&
                message.hasOwnProperty("timeOfDeath")
              )
                object.timeOfDeath =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.timeOfDeath,
                    options,
                  );
              if (
                message.causeOfDeath != null &&
                message.hasOwnProperty("causeOfDeath")
              )
                object.causeOfDeath =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.causeOfDeath,
                    options,
                  );
              if (
                message.survivalTimeInDays != null &&
                message.hasOwnProperty("survivalTimeInDays")
              )
                object.survivalTimeInDays = message.survivalTimeInDays;
              return object;
            };

            /**
             * Converts this VitalStatus to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VitalStatus.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for VitalStatus
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.VitalStatus
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VitalStatus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.VitalStatus"
              );
            };

            /**
             * Status enum.
             * @name org.phenopackets.schema.v2.core.VitalStatus.Status
             * @enum {number}
             * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
             * @property {number} ALIVE=1 ALIVE value
             * @property {number} DECEASED=2 DECEASED value
             */
            VitalStatus.Status = (function () {
              const valuesById = {},
                values = Object.create(valuesById);
              values[(valuesById[0] = "UNKNOWN_STATUS")] = 0;
              values[(valuesById[1] = "ALIVE")] = 1;
              values[(valuesById[2] = "DECEASED")] = 2;
              return values;
            })();

            return VitalStatus;
          })();

          /**
           * Sex enum.
           * @name org.phenopackets.schema.v2.core.Sex
           * @enum {number}
           * @property {number} UNKNOWN_SEX=0 UNKNOWN_SEX value
           * @property {number} FEMALE=1 FEMALE value
           * @property {number} MALE=2 MALE value
           * @property {number} OTHER_SEX=3 OTHER_SEX value
           */
          core.Sex = (function () {
            const valuesById = {},
              values = Object.create(valuesById);
            values[(valuesById[0] = "UNKNOWN_SEX")] = 0;
            values[(valuesById[1] = "FEMALE")] = 1;
            values[(valuesById[2] = "MALE")] = 2;
            values[(valuesById[3] = "OTHER_SEX")] = 3;
            return values;
          })();

          /**
           * KaryotypicSex enum.
           * @name org.phenopackets.schema.v2.core.KaryotypicSex
           * @enum {number}
           * @property {number} UNKNOWN_KARYOTYPE=0 UNKNOWN_KARYOTYPE value
           * @property {number} XX=1 XX value
           * @property {number} XY=2 XY value
           * @property {number} XO=3 XO value
           * @property {number} XXY=4 XXY value
           * @property {number} XXX=5 XXX value
           * @property {number} XXYY=6 XXYY value
           * @property {number} XXXY=7 XXXY value
           * @property {number} XXXX=8 XXXX value
           * @property {number} XYY=9 XYY value
           * @property {number} OTHER_KARYOTYPE=10 OTHER_KARYOTYPE value
           */
          core.KaryotypicSex = (function () {
            const valuesById = {},
              values = Object.create(valuesById);
            values[(valuesById[0] = "UNKNOWN_KARYOTYPE")] = 0;
            values[(valuesById[1] = "XX")] = 1;
            values[(valuesById[2] = "XY")] = 2;
            values[(valuesById[3] = "XO")] = 3;
            values[(valuesById[4] = "XXY")] = 4;
            values[(valuesById[5] = "XXX")] = 5;
            values[(valuesById[6] = "XXYY")] = 6;
            values[(valuesById[7] = "XXXY")] = 7;
            values[(valuesById[8] = "XXXX")] = 8;
            values[(valuesById[9] = "XYY")] = 9;
            values[(valuesById[10] = "OTHER_KARYOTYPE")] = 10;
            return values;
          })();

          core.MedicalAction = (function () {
            /**
             * Properties of a MedicalAction.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IMedicalAction
             * @property {org.phenopackets.schema.v2.core.IProcedure|null} [procedure] MedicalAction procedure
             * @property {org.phenopackets.schema.v2.core.ITreatment|null} [treatment] MedicalAction treatment
             * @property {org.phenopackets.schema.v2.core.IRadiationTherapy|null} [radiationTherapy] MedicalAction radiationTherapy
             * @property {org.phenopackets.schema.v2.core.ITherapeuticRegimen|null} [therapeuticRegimen] MedicalAction therapeuticRegimen
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [treatmentTarget] MedicalAction treatmentTarget
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [treatmentIntent] MedicalAction treatmentIntent
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [responseToTreatment] MedicalAction responseToTreatment
             * @property {Array.<org.phenopackets.schema.v2.core.IOntologyClass>|null} [adverseEvents] MedicalAction adverseEvents
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [treatmentTerminationReason] MedicalAction treatmentTerminationReason
             */

            /**
             * Constructs a new MedicalAction.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a MedicalAction.
             * @implements IMedicalAction
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IMedicalAction=} [properties] Properties to set
             */
            function MedicalAction(properties) {
              this.adverseEvents = [];
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * MedicalAction procedure.
             * @member {org.phenopackets.schema.v2.core.IProcedure|null|undefined} procedure
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             */
            MedicalAction.prototype.procedure = null;

            /**
             * MedicalAction treatment.
             * @member {org.phenopackets.schema.v2.core.ITreatment|null|undefined} treatment
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             */
            MedicalAction.prototype.treatment = null;

            /**
             * MedicalAction radiationTherapy.
             * @member {org.phenopackets.schema.v2.core.IRadiationTherapy|null|undefined} radiationTherapy
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             */
            MedicalAction.prototype.radiationTherapy = null;

            /**
             * MedicalAction therapeuticRegimen.
             * @member {org.phenopackets.schema.v2.core.ITherapeuticRegimen|null|undefined} therapeuticRegimen
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             */
            MedicalAction.prototype.therapeuticRegimen = null;

            /**
             * MedicalAction treatmentTarget.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} treatmentTarget
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             */
            MedicalAction.prototype.treatmentTarget = null;

            /**
             * MedicalAction treatmentIntent.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} treatmentIntent
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             */
            MedicalAction.prototype.treatmentIntent = null;

            /**
             * MedicalAction responseToTreatment.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} responseToTreatment
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             */
            MedicalAction.prototype.responseToTreatment = null;

            /**
             * MedicalAction adverseEvents.
             * @member {Array.<org.phenopackets.schema.v2.core.IOntologyClass>} adverseEvents
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             */
            MedicalAction.prototype.adverseEvents = $util.emptyArray;

            /**
             * MedicalAction treatmentTerminationReason.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} treatmentTerminationReason
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             */
            MedicalAction.prototype.treatmentTerminationReason = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * MedicalAction action.
             * @member {"procedure"|"treatment"|"radiationTherapy"|"therapeuticRegimen"|undefined} action
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             */
            Object.defineProperty(MedicalAction.prototype, "action", {
              get: $util.oneOfGetter(
                ($oneOfFields = [
                  "procedure",
                  "treatment",
                  "radiationTherapy",
                  "therapeuticRegimen",
                ]),
              ),
              set: $util.oneOfSetter($oneOfFields),
            });

            /**
             * Creates a new MedicalAction instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @static
             * @param {org.phenopackets.schema.v2.core.IMedicalAction=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.MedicalAction} MedicalAction instance
             */
            MedicalAction.create = function create(properties) {
              return new MedicalAction(properties);
            };

            /**
             * Encodes the specified MedicalAction message. Does not implicitly {@link org.phenopackets.schema.v2.core.MedicalAction.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @static
             * @param {org.phenopackets.schema.v2.core.IMedicalAction} message MedicalAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MedicalAction.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.procedure != null &&
                Object.hasOwnProperty.call(message, "procedure")
              )
                $root.org.phenopackets.schema.v2.core.Procedure.encode(
                  message.procedure,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.treatment != null &&
                Object.hasOwnProperty.call(message, "treatment")
              )
                $root.org.phenopackets.schema.v2.core.Treatment.encode(
                  message.treatment,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (
                message.radiationTherapy != null &&
                Object.hasOwnProperty.call(message, "radiationTherapy")
              )
                $root.org.phenopackets.schema.v2.core.RadiationTherapy.encode(
                  message.radiationTherapy,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              if (
                message.therapeuticRegimen != null &&
                Object.hasOwnProperty.call(message, "therapeuticRegimen")
              )
                $root.org.phenopackets.schema.v2.core.TherapeuticRegimen.encode(
                  message.therapeuticRegimen,
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
              if (
                message.treatmentTarget != null &&
                Object.hasOwnProperty.call(message, "treatmentTarget")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.treatmentTarget,
                  writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                ).ldelim();
              if (
                message.treatmentIntent != null &&
                Object.hasOwnProperty.call(message, "treatmentIntent")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.treatmentIntent,
                  writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
                ).ldelim();
              if (
                message.responseToTreatment != null &&
                Object.hasOwnProperty.call(message, "responseToTreatment")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.responseToTreatment,
                  writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
                ).ldelim();
              if (message.adverseEvents != null && message.adverseEvents.length)
                for (let i = 0; i < message.adverseEvents.length; ++i)
                  $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                    message.adverseEvents[i],
                    writer.uint32(/* id 8, wireType 2 =*/ 66).fork(),
                  ).ldelim();
              if (
                message.treatmentTerminationReason != null &&
                Object.hasOwnProperty.call(
                  message,
                  "treatmentTerminationReason",
                )
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.treatmentTerminationReason,
                  writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified MedicalAction message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.MedicalAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @static
             * @param {org.phenopackets.schema.v2.core.IMedicalAction} message MedicalAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MedicalAction.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MedicalAction message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.MedicalAction} MedicalAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MedicalAction.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.MedicalAction();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.procedure =
                      $root.org.phenopackets.schema.v2.core.Procedure.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.treatment =
                      $root.org.phenopackets.schema.v2.core.Treatment.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 3: {
                    message.radiationTherapy =
                      $root.org.phenopackets.schema.v2.core.RadiationTherapy.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 4: {
                    message.therapeuticRegimen =
                      $root.org.phenopackets.schema.v2.core.TherapeuticRegimen.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 5: {
                    message.treatmentTarget =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 6: {
                    message.treatmentIntent =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 7: {
                    message.responseToTreatment =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 8: {
                    if (
                      !(message.adverseEvents && message.adverseEvents.length)
                    )
                      message.adverseEvents = [];
                    message.adverseEvents.push(
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 9: {
                    message.treatmentTerminationReason =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a MedicalAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.MedicalAction} MedicalAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MedicalAction.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MedicalAction message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MedicalAction.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              let properties = {};
              if (
                message.procedure != null &&
                message.hasOwnProperty("procedure")
              ) {
                properties.action = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.Procedure.verify(
                      message.procedure,
                    );
                  if (error) return "procedure." + error;
                }
              }
              if (
                message.treatment != null &&
                message.hasOwnProperty("treatment")
              ) {
                if (properties.action === 1) return "action: multiple values";
                properties.action = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.Treatment.verify(
                      message.treatment,
                    );
                  if (error) return "treatment." + error;
                }
              }
              if (
                message.radiationTherapy != null &&
                message.hasOwnProperty("radiationTherapy")
              ) {
                if (properties.action === 1) return "action: multiple values";
                properties.action = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.RadiationTherapy.verify(
                      message.radiationTherapy,
                    );
                  if (error) return "radiationTherapy." + error;
                }
              }
              if (
                message.therapeuticRegimen != null &&
                message.hasOwnProperty("therapeuticRegimen")
              ) {
                if (properties.action === 1) return "action: multiple values";
                properties.action = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.TherapeuticRegimen.verify(
                      message.therapeuticRegimen,
                    );
                  if (error) return "therapeuticRegimen." + error;
                }
              }
              if (
                message.treatmentTarget != null &&
                message.hasOwnProperty("treatmentTarget")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.treatmentTarget,
                  );
                if (error) return "treatmentTarget." + error;
              }
              if (
                message.treatmentIntent != null &&
                message.hasOwnProperty("treatmentIntent")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.treatmentIntent,
                  );
                if (error) return "treatmentIntent." + error;
              }
              if (
                message.responseToTreatment != null &&
                message.hasOwnProperty("responseToTreatment")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.responseToTreatment,
                  );
                if (error) return "responseToTreatment." + error;
              }
              if (
                message.adverseEvents != null &&
                message.hasOwnProperty("adverseEvents")
              ) {
                if (!Array.isArray(message.adverseEvents))
                  return "adverseEvents: array expected";
                for (let i = 0; i < message.adverseEvents.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                      message.adverseEvents[i],
                    );
                  if (error) return "adverseEvents." + error;
                }
              }
              if (
                message.treatmentTerminationReason != null &&
                message.hasOwnProperty("treatmentTerminationReason")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.treatmentTerminationReason,
                  );
                if (error) return "treatmentTerminationReason." + error;
              }
              return null;
            };

            /**
             * Creates a MedicalAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.MedicalAction} MedicalAction
             */
            MedicalAction.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.MedicalAction
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.MedicalAction();
              if (object.procedure != null) {
                if (typeof object.procedure !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MedicalAction.procedure: object expected",
                  );
                message.procedure =
                  $root.org.phenopackets.schema.v2.core.Procedure.fromObject(
                    object.procedure,
                  );
              }
              if (object.treatment != null) {
                if (typeof object.treatment !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MedicalAction.treatment: object expected",
                  );
                message.treatment =
                  $root.org.phenopackets.schema.v2.core.Treatment.fromObject(
                    object.treatment,
                  );
              }
              if (object.radiationTherapy != null) {
                if (typeof object.radiationTherapy !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MedicalAction.radiationTherapy: object expected",
                  );
                message.radiationTherapy =
                  $root.org.phenopackets.schema.v2.core.RadiationTherapy.fromObject(
                    object.radiationTherapy,
                  );
              }
              if (object.therapeuticRegimen != null) {
                if (typeof object.therapeuticRegimen !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MedicalAction.therapeuticRegimen: object expected",
                  );
                message.therapeuticRegimen =
                  $root.org.phenopackets.schema.v2.core.TherapeuticRegimen.fromObject(
                    object.therapeuticRegimen,
                  );
              }
              if (object.treatmentTarget != null) {
                if (typeof object.treatmentTarget !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MedicalAction.treatmentTarget: object expected",
                  );
                message.treatmentTarget =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.treatmentTarget,
                  );
              }
              if (object.treatmentIntent != null) {
                if (typeof object.treatmentIntent !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MedicalAction.treatmentIntent: object expected",
                  );
                message.treatmentIntent =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.treatmentIntent,
                  );
              }
              if (object.responseToTreatment != null) {
                if (typeof object.responseToTreatment !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MedicalAction.responseToTreatment: object expected",
                  );
                message.responseToTreatment =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.responseToTreatment,
                  );
              }
              if (object.adverseEvents) {
                if (!Array.isArray(object.adverseEvents))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MedicalAction.adverseEvents: array expected",
                  );
                message.adverseEvents = [];
                for (let i = 0; i < object.adverseEvents.length; ++i) {
                  if (typeof object.adverseEvents[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.MedicalAction.adverseEvents: object expected",
                    );
                  message.adverseEvents[i] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                      object.adverseEvents[i],
                    );
                }
              }
              if (object.treatmentTerminationReason != null) {
                if (typeof object.treatmentTerminationReason !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MedicalAction.treatmentTerminationReason: object expected",
                  );
                message.treatmentTerminationReason =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.treatmentTerminationReason,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a MedicalAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @static
             * @param {org.phenopackets.schema.v2.core.MedicalAction} message MedicalAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MedicalAction.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.arrays || options.defaults) object.adverseEvents = [];
              if (options.defaults) {
                object.treatmentTarget = null;
                object.treatmentIntent = null;
                object.responseToTreatment = null;
                object.treatmentTerminationReason = null;
              }
              if (
                message.procedure != null &&
                message.hasOwnProperty("procedure")
              ) {
                object.procedure =
                  $root.org.phenopackets.schema.v2.core.Procedure.toObject(
                    message.procedure,
                    options,
                  );
                if (options.oneofs) object.action = "procedure";
              }
              if (
                message.treatment != null &&
                message.hasOwnProperty("treatment")
              ) {
                object.treatment =
                  $root.org.phenopackets.schema.v2.core.Treatment.toObject(
                    message.treatment,
                    options,
                  );
                if (options.oneofs) object.action = "treatment";
              }
              if (
                message.radiationTherapy != null &&
                message.hasOwnProperty("radiationTherapy")
              ) {
                object.radiationTherapy =
                  $root.org.phenopackets.schema.v2.core.RadiationTherapy.toObject(
                    message.radiationTherapy,
                    options,
                  );
                if (options.oneofs) object.action = "radiationTherapy";
              }
              if (
                message.therapeuticRegimen != null &&
                message.hasOwnProperty("therapeuticRegimen")
              ) {
                object.therapeuticRegimen =
                  $root.org.phenopackets.schema.v2.core.TherapeuticRegimen.toObject(
                    message.therapeuticRegimen,
                    options,
                  );
                if (options.oneofs) object.action = "therapeuticRegimen";
              }
              if (
                message.treatmentTarget != null &&
                message.hasOwnProperty("treatmentTarget")
              )
                object.treatmentTarget =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.treatmentTarget,
                    options,
                  );
              if (
                message.treatmentIntent != null &&
                message.hasOwnProperty("treatmentIntent")
              )
                object.treatmentIntent =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.treatmentIntent,
                    options,
                  );
              if (
                message.responseToTreatment != null &&
                message.hasOwnProperty("responseToTreatment")
              )
                object.responseToTreatment =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.responseToTreatment,
                    options,
                  );
              if (message.adverseEvents && message.adverseEvents.length) {
                object.adverseEvents = [];
                for (let j = 0; j < message.adverseEvents.length; ++j)
                  object.adverseEvents[j] =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                      message.adverseEvents[j],
                      options,
                    );
              }
              if (
                message.treatmentTerminationReason != null &&
                message.hasOwnProperty("treatmentTerminationReason")
              )
                object.treatmentTerminationReason =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.treatmentTerminationReason,
                    options,
                  );
              return object;
            };

            /**
             * Converts this MedicalAction to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MedicalAction.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for MedicalAction
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.MedicalAction
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MedicalAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.MedicalAction"
              );
            };

            return MedicalAction;
          })();

          core.Treatment = (function () {
            /**
             * Properties of a Treatment.
             * @memberof org.phenopackets.schema.v2.core
             * @interface ITreatment
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [agent] Treatment agent
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [routeOfAdministration] Treatment routeOfAdministration
             * @property {Array.<org.phenopackets.schema.v2.core.IDoseInterval>|null} [doseIntervals] Treatment doseIntervals
             * @property {org.phenopackets.schema.v2.core.DrugType|null} [drugType] Treatment drugType
             * @property {org.phenopackets.schema.v2.core.IQuantity|null} [cumulativeDose] Treatment cumulativeDose
             */

            /**
             * Constructs a new Treatment.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a Treatment.
             * @implements ITreatment
             * @constructor
             * @param {org.phenopackets.schema.v2.core.ITreatment=} [properties] Properties to set
             */
            function Treatment(properties) {
              this.doseIntervals = [];
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Treatment agent.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} agent
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @instance
             */
            Treatment.prototype.agent = null;

            /**
             * Treatment routeOfAdministration.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} routeOfAdministration
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @instance
             */
            Treatment.prototype.routeOfAdministration = null;

            /**
             * Treatment doseIntervals.
             * @member {Array.<org.phenopackets.schema.v2.core.IDoseInterval>} doseIntervals
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @instance
             */
            Treatment.prototype.doseIntervals = $util.emptyArray;

            /**
             * Treatment drugType.
             * @member {org.phenopackets.schema.v2.core.DrugType} drugType
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @instance
             */
            Treatment.prototype.drugType = 0;

            /**
             * Treatment cumulativeDose.
             * @member {org.phenopackets.schema.v2.core.IQuantity|null|undefined} cumulativeDose
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @instance
             */
            Treatment.prototype.cumulativeDose = null;

            /**
             * Creates a new Treatment instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @static
             * @param {org.phenopackets.schema.v2.core.ITreatment=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Treatment} Treatment instance
             */
            Treatment.create = function create(properties) {
              return new Treatment(properties);
            };

            /**
             * Encodes the specified Treatment message. Does not implicitly {@link org.phenopackets.schema.v2.core.Treatment.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @static
             * @param {org.phenopackets.schema.v2.core.ITreatment} message Treatment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Treatment.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.agent != null &&
                Object.hasOwnProperty.call(message, "agent")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.agent,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.routeOfAdministration != null &&
                Object.hasOwnProperty.call(message, "routeOfAdministration")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.routeOfAdministration,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (message.doseIntervals != null && message.doseIntervals.length)
                for (let i = 0; i < message.doseIntervals.length; ++i)
                  $root.org.phenopackets.schema.v2.core.DoseInterval.encode(
                    message.doseIntervals[i],
                    writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                  ).ldelim();
              if (
                message.drugType != null &&
                Object.hasOwnProperty.call(message, "drugType")
              )
                writer
                  .uint32(/* id 4, wireType 0 =*/ 32)
                  .int32(message.drugType);
              if (
                message.cumulativeDose != null &&
                Object.hasOwnProperty.call(message, "cumulativeDose")
              )
                $root.org.phenopackets.schema.v2.core.Quantity.encode(
                  message.cumulativeDose,
                  writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Treatment message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Treatment.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @static
             * @param {org.phenopackets.schema.v2.core.ITreatment} message Treatment message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Treatment.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Treatment message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Treatment} Treatment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Treatment.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Treatment();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.agent =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.routeOfAdministration =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 3: {
                    if (
                      !(message.doseIntervals && message.doseIntervals.length)
                    )
                      message.doseIntervals = [];
                    message.doseIntervals.push(
                      $root.org.phenopackets.schema.v2.core.DoseInterval.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 4: {
                    message.drugType = reader.int32();
                    break;
                  }
                  case 5: {
                    message.cumulativeDose =
                      $root.org.phenopackets.schema.v2.core.Quantity.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Treatment message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Treatment} Treatment
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Treatment.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Treatment message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Treatment.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.agent != null && message.hasOwnProperty("agent")) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.agent,
                  );
                if (error) return "agent." + error;
              }
              if (
                message.routeOfAdministration != null &&
                message.hasOwnProperty("routeOfAdministration")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.routeOfAdministration,
                  );
                if (error) return "routeOfAdministration." + error;
              }
              if (
                message.doseIntervals != null &&
                message.hasOwnProperty("doseIntervals")
              ) {
                if (!Array.isArray(message.doseIntervals))
                  return "doseIntervals: array expected";
                for (let i = 0; i < message.doseIntervals.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.DoseInterval.verify(
                      message.doseIntervals[i],
                    );
                  if (error) return "doseIntervals." + error;
                }
              }
              if (
                message.drugType != null &&
                message.hasOwnProperty("drugType")
              )
                switch (message.drugType) {
                  default:
                    return "drugType: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                    break;
                }
              if (
                message.cumulativeDose != null &&
                message.hasOwnProperty("cumulativeDose")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.Quantity.verify(
                    message.cumulativeDose,
                  );
                if (error) return "cumulativeDose." + error;
              }
              return null;
            };

            /**
             * Creates a Treatment message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Treatment} Treatment
             */
            Treatment.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.Treatment
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Treatment();
              if (object.agent != null) {
                if (typeof object.agent !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Treatment.agent: object expected",
                  );
                message.agent =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.agent,
                  );
              }
              if (object.routeOfAdministration != null) {
                if (typeof object.routeOfAdministration !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Treatment.routeOfAdministration: object expected",
                  );
                message.routeOfAdministration =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.routeOfAdministration,
                  );
              }
              if (object.doseIntervals) {
                if (!Array.isArray(object.doseIntervals))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Treatment.doseIntervals: array expected",
                  );
                message.doseIntervals = [];
                for (let i = 0; i < object.doseIntervals.length; ++i) {
                  if (typeof object.doseIntervals[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.Treatment.doseIntervals: object expected",
                    );
                  message.doseIntervals[i] =
                    $root.org.phenopackets.schema.v2.core.DoseInterval.fromObject(
                      object.doseIntervals[i],
                    );
                }
              }
              switch (object.drugType) {
                case "UNKNOWN_DRUG_TYPE":
                case 0:
                  message.drugType = 0;
                  break;
                case "PRESCRIPTION":
                case 1:
                  message.drugType = 1;
                  break;
                case "EHR_MEDICATION_LIST":
                case 2:
                  message.drugType = 2;
                  break;
                case "ADMINISTRATION_RELATED_TO_PROCEDURE":
                case 3:
                  message.drugType = 3;
                  break;
              }
              if (object.cumulativeDose != null) {
                if (typeof object.cumulativeDose !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Treatment.cumulativeDose: object expected",
                  );
                message.cumulativeDose =
                  $root.org.phenopackets.schema.v2.core.Quantity.fromObject(
                    object.cumulativeDose,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a Treatment message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @static
             * @param {org.phenopackets.schema.v2.core.Treatment} message Treatment
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Treatment.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.arrays || options.defaults) object.doseIntervals = [];
              if (options.defaults) {
                object.agent = null;
                object.routeOfAdministration = null;
                object.drugType =
                  options.enums === String ? "UNKNOWN_DRUG_TYPE" : 0;
                object.cumulativeDose = null;
              }
              if (message.agent != null && message.hasOwnProperty("agent"))
                object.agent =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.agent,
                    options,
                  );
              if (
                message.routeOfAdministration != null &&
                message.hasOwnProperty("routeOfAdministration")
              )
                object.routeOfAdministration =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.routeOfAdministration,
                    options,
                  );
              if (message.doseIntervals && message.doseIntervals.length) {
                object.doseIntervals = [];
                for (let j = 0; j < message.doseIntervals.length; ++j)
                  object.doseIntervals[j] =
                    $root.org.phenopackets.schema.v2.core.DoseInterval.toObject(
                      message.doseIntervals[j],
                      options,
                    );
              }
              if (
                message.drugType != null &&
                message.hasOwnProperty("drugType")
              )
                object.drugType =
                  options.enums === String
                    ? $root.org.phenopackets.schema.v2.core.DrugType[
                        message.drugType
                      ]
                    : message.drugType;
              if (
                message.cumulativeDose != null &&
                message.hasOwnProperty("cumulativeDose")
              )
                object.cumulativeDose =
                  $root.org.phenopackets.schema.v2.core.Quantity.toObject(
                    message.cumulativeDose,
                    options,
                  );
              return object;
            };

            /**
             * Converts this Treatment to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Treatment.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Treatment
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Treatment
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Treatment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.Treatment"
              );
            };

            return Treatment;
          })();

          core.DoseInterval = (function () {
            /**
             * Properties of a DoseInterval.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IDoseInterval
             * @property {org.phenopackets.schema.v2.core.IQuantity|null} [quantity] DoseInterval quantity
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [scheduleFrequency] DoseInterval scheduleFrequency
             * @property {org.phenopackets.schema.v2.core.ITimeInterval|null} [interval] DoseInterval interval
             */

            /**
             * Constructs a new DoseInterval.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a DoseInterval.
             * @implements IDoseInterval
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IDoseInterval=} [properties] Properties to set
             */
            function DoseInterval(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * DoseInterval quantity.
             * @member {org.phenopackets.schema.v2.core.IQuantity|null|undefined} quantity
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @instance
             */
            DoseInterval.prototype.quantity = null;

            /**
             * DoseInterval scheduleFrequency.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} scheduleFrequency
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @instance
             */
            DoseInterval.prototype.scheduleFrequency = null;

            /**
             * DoseInterval interval.
             * @member {org.phenopackets.schema.v2.core.ITimeInterval|null|undefined} interval
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @instance
             */
            DoseInterval.prototype.interval = null;

            /**
             * Creates a new DoseInterval instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @static
             * @param {org.phenopackets.schema.v2.core.IDoseInterval=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.DoseInterval} DoseInterval instance
             */
            DoseInterval.create = function create(properties) {
              return new DoseInterval(properties);
            };

            /**
             * Encodes the specified DoseInterval message. Does not implicitly {@link org.phenopackets.schema.v2.core.DoseInterval.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @static
             * @param {org.phenopackets.schema.v2.core.IDoseInterval} message DoseInterval message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoseInterval.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.quantity != null &&
                Object.hasOwnProperty.call(message, "quantity")
              )
                $root.org.phenopackets.schema.v2.core.Quantity.encode(
                  message.quantity,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.scheduleFrequency != null &&
                Object.hasOwnProperty.call(message, "scheduleFrequency")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.scheduleFrequency,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (
                message.interval != null &&
                Object.hasOwnProperty.call(message, "interval")
              )
                $root.org.phenopackets.schema.v2.core.TimeInterval.encode(
                  message.interval,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified DoseInterval message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.DoseInterval.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @static
             * @param {org.phenopackets.schema.v2.core.IDoseInterval} message DoseInterval message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DoseInterval.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DoseInterval message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.DoseInterval} DoseInterval
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoseInterval.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.DoseInterval();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.quantity =
                      $root.org.phenopackets.schema.v2.core.Quantity.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.scheduleFrequency =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 3: {
                    message.interval =
                      $root.org.phenopackets.schema.v2.core.TimeInterval.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a DoseInterval message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.DoseInterval} DoseInterval
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DoseInterval.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DoseInterval message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DoseInterval.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.quantity != null &&
                message.hasOwnProperty("quantity")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.Quantity.verify(
                    message.quantity,
                  );
                if (error) return "quantity." + error;
              }
              if (
                message.scheduleFrequency != null &&
                message.hasOwnProperty("scheduleFrequency")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.scheduleFrequency,
                  );
                if (error) return "scheduleFrequency." + error;
              }
              if (
                message.interval != null &&
                message.hasOwnProperty("interval")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeInterval.verify(
                    message.interval,
                  );
                if (error) return "interval." + error;
              }
              return null;
            };

            /**
             * Creates a DoseInterval message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.DoseInterval} DoseInterval
             */
            DoseInterval.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.DoseInterval
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.DoseInterval();
              if (object.quantity != null) {
                if (typeof object.quantity !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.DoseInterval.quantity: object expected",
                  );
                message.quantity =
                  $root.org.phenopackets.schema.v2.core.Quantity.fromObject(
                    object.quantity,
                  );
              }
              if (object.scheduleFrequency != null) {
                if (typeof object.scheduleFrequency !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.DoseInterval.scheduleFrequency: object expected",
                  );
                message.scheduleFrequency =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.scheduleFrequency,
                  );
              }
              if (object.interval != null) {
                if (typeof object.interval !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.DoseInterval.interval: object expected",
                  );
                message.interval =
                  $root.org.phenopackets.schema.v2.core.TimeInterval.fromObject(
                    object.interval,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a DoseInterval message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @static
             * @param {org.phenopackets.schema.v2.core.DoseInterval} message DoseInterval
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DoseInterval.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.quantity = null;
                object.scheduleFrequency = null;
                object.interval = null;
              }
              if (
                message.quantity != null &&
                message.hasOwnProperty("quantity")
              )
                object.quantity =
                  $root.org.phenopackets.schema.v2.core.Quantity.toObject(
                    message.quantity,
                    options,
                  );
              if (
                message.scheduleFrequency != null &&
                message.hasOwnProperty("scheduleFrequency")
              )
                object.scheduleFrequency =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.scheduleFrequency,
                    options,
                  );
              if (
                message.interval != null &&
                message.hasOwnProperty("interval")
              )
                object.interval =
                  $root.org.phenopackets.schema.v2.core.TimeInterval.toObject(
                    message.interval,
                    options,
                  );
              return object;
            };

            /**
             * Converts this DoseInterval to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DoseInterval.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for DoseInterval
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.DoseInterval
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DoseInterval.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.DoseInterval"
              );
            };

            return DoseInterval;
          })();

          /**
           * DrugType enum.
           * @name org.phenopackets.schema.v2.core.DrugType
           * @enum {number}
           * @property {number} UNKNOWN_DRUG_TYPE=0 UNKNOWN_DRUG_TYPE value
           * @property {number} PRESCRIPTION=1 PRESCRIPTION value
           * @property {number} EHR_MEDICATION_LIST=2 EHR_MEDICATION_LIST value
           * @property {number} ADMINISTRATION_RELATED_TO_PROCEDURE=3 ADMINISTRATION_RELATED_TO_PROCEDURE value
           */
          core.DrugType = (function () {
            const valuesById = {},
              values = Object.create(valuesById);
            values[(valuesById[0] = "UNKNOWN_DRUG_TYPE")] = 0;
            values[(valuesById[1] = "PRESCRIPTION")] = 1;
            values[(valuesById[2] = "EHR_MEDICATION_LIST")] = 2;
            values[(valuesById[3] = "ADMINISTRATION_RELATED_TO_PROCEDURE")] = 3;
            return values;
          })();

          core.RadiationTherapy = (function () {
            /**
             * Properties of a RadiationTherapy.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IRadiationTherapy
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [modality] RadiationTherapy modality
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [bodySite] RadiationTherapy bodySite
             * @property {number|null} [dosage] RadiationTherapy dosage
             * @property {number|null} [fractions] RadiationTherapy fractions
             */

            /**
             * Constructs a new RadiationTherapy.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a RadiationTherapy.
             * @implements IRadiationTherapy
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IRadiationTherapy=} [properties] Properties to set
             */
            function RadiationTherapy(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * RadiationTherapy modality.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} modality
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @instance
             */
            RadiationTherapy.prototype.modality = null;

            /**
             * RadiationTherapy bodySite.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} bodySite
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @instance
             */
            RadiationTherapy.prototype.bodySite = null;

            /**
             * RadiationTherapy dosage.
             * @member {number} dosage
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @instance
             */
            RadiationTherapy.prototype.dosage = 0;

            /**
             * RadiationTherapy fractions.
             * @member {number} fractions
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @instance
             */
            RadiationTherapy.prototype.fractions = 0;

            /**
             * Creates a new RadiationTherapy instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @static
             * @param {org.phenopackets.schema.v2.core.IRadiationTherapy=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.RadiationTherapy} RadiationTherapy instance
             */
            RadiationTherapy.create = function create(properties) {
              return new RadiationTherapy(properties);
            };

            /**
             * Encodes the specified RadiationTherapy message. Does not implicitly {@link org.phenopackets.schema.v2.core.RadiationTherapy.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @static
             * @param {org.phenopackets.schema.v2.core.IRadiationTherapy} message RadiationTherapy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RadiationTherapy.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.modality != null &&
                Object.hasOwnProperty.call(message, "modality")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.modality,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.bodySite != null &&
                Object.hasOwnProperty.call(message, "bodySite")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.bodySite,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (
                message.dosage != null &&
                Object.hasOwnProperty.call(message, "dosage")
              )
                writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.dosage);
              if (
                message.fractions != null &&
                Object.hasOwnProperty.call(message, "fractions")
              )
                writer
                  .uint32(/* id 4, wireType 0 =*/ 32)
                  .int32(message.fractions);
              return writer;
            };

            /**
             * Encodes the specified RadiationTherapy message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.RadiationTherapy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @static
             * @param {org.phenopackets.schema.v2.core.IRadiationTherapy} message RadiationTherapy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RadiationTherapy.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RadiationTherapy message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.RadiationTherapy} RadiationTherapy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RadiationTherapy.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.RadiationTherapy();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.modality =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.bodySite =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 3: {
                    message.dosage = reader.int32();
                    break;
                  }
                  case 4: {
                    message.fractions = reader.int32();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a RadiationTherapy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.RadiationTherapy} RadiationTherapy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RadiationTherapy.decodeDelimited = function decodeDelimited(
              reader,
            ) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RadiationTherapy message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RadiationTherapy.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.modality != null &&
                message.hasOwnProperty("modality")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.modality,
                  );
                if (error) return "modality." + error;
              }
              if (
                message.bodySite != null &&
                message.hasOwnProperty("bodySite")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                    message.bodySite,
                  );
                if (error) return "bodySite." + error;
              }
              if (message.dosage != null && message.hasOwnProperty("dosage"))
                if (!$util.isInteger(message.dosage))
                  return "dosage: integer expected";
              if (
                message.fractions != null &&
                message.hasOwnProperty("fractions")
              )
                if (!$util.isInteger(message.fractions))
                  return "fractions: integer expected";
              return null;
            };

            /**
             * Creates a RadiationTherapy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.RadiationTherapy} RadiationTherapy
             */
            RadiationTherapy.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.RadiationTherapy
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.RadiationTherapy();
              if (object.modality != null) {
                if (typeof object.modality !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.RadiationTherapy.modality: object expected",
                  );
                message.modality =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.modality,
                  );
              }
              if (object.bodySite != null) {
                if (typeof object.bodySite !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.RadiationTherapy.bodySite: object expected",
                  );
                message.bodySite =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.bodySite,
                  );
              }
              if (object.dosage != null) message.dosage = object.dosage | 0;
              if (object.fractions != null)
                message.fractions = object.fractions | 0;
              return message;
            };

            /**
             * Creates a plain object from a RadiationTherapy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @static
             * @param {org.phenopackets.schema.v2.core.RadiationTherapy} message RadiationTherapy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RadiationTherapy.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.modality = null;
                object.bodySite = null;
                object.dosage = 0;
                object.fractions = 0;
              }
              if (
                message.modality != null &&
                message.hasOwnProperty("modality")
              )
                object.modality =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.modality,
                    options,
                  );
              if (
                message.bodySite != null &&
                message.hasOwnProperty("bodySite")
              )
                object.bodySite =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.bodySite,
                    options,
                  );
              if (message.dosage != null && message.hasOwnProperty("dosage"))
                object.dosage = message.dosage;
              if (
                message.fractions != null &&
                message.hasOwnProperty("fractions")
              )
                object.fractions = message.fractions;
              return object;
            };

            /**
             * Converts this RadiationTherapy to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RadiationTherapy.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for RadiationTherapy
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.RadiationTherapy
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RadiationTherapy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix +
                "/org.phenopackets.schema.v2.core.RadiationTherapy"
              );
            };

            return RadiationTherapy;
          })();

          core.TherapeuticRegimen = (function () {
            /**
             * Properties of a TherapeuticRegimen.
             * @memberof org.phenopackets.schema.v2.core
             * @interface ITherapeuticRegimen
             * @property {org.phenopackets.schema.v2.core.IExternalReference|null} [externalReference] TherapeuticRegimen externalReference
             * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [ontologyClass] TherapeuticRegimen ontologyClass
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [startTime] TherapeuticRegimen startTime
             * @property {org.phenopackets.schema.v2.core.ITimeElement|null} [endTime] TherapeuticRegimen endTime
             * @property {org.phenopackets.schema.v2.core.TherapeuticRegimen.RegimenStatus|null} [regimenStatus] TherapeuticRegimen regimenStatus
             */

            /**
             * Constructs a new TherapeuticRegimen.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a TherapeuticRegimen.
             * @implements ITherapeuticRegimen
             * @constructor
             * @param {org.phenopackets.schema.v2.core.ITherapeuticRegimen=} [properties] Properties to set
             */
            function TherapeuticRegimen(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * TherapeuticRegimen externalReference.
             * @member {org.phenopackets.schema.v2.core.IExternalReference|null|undefined} externalReference
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @instance
             */
            TherapeuticRegimen.prototype.externalReference = null;

            /**
             * TherapeuticRegimen ontologyClass.
             * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} ontologyClass
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @instance
             */
            TherapeuticRegimen.prototype.ontologyClass = null;

            /**
             * TherapeuticRegimen startTime.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} startTime
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @instance
             */
            TherapeuticRegimen.prototype.startTime = null;

            /**
             * TherapeuticRegimen endTime.
             * @member {org.phenopackets.schema.v2.core.ITimeElement|null|undefined} endTime
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @instance
             */
            TherapeuticRegimen.prototype.endTime = null;

            /**
             * TherapeuticRegimen regimenStatus.
             * @member {org.phenopackets.schema.v2.core.TherapeuticRegimen.RegimenStatus} regimenStatus
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @instance
             */
            TherapeuticRegimen.prototype.regimenStatus = 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * TherapeuticRegimen identifier.
             * @member {"externalReference"|"ontologyClass"|undefined} identifier
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @instance
             */
            Object.defineProperty(TherapeuticRegimen.prototype, "identifier", {
              get: $util.oneOfGetter(
                ($oneOfFields = ["externalReference", "ontologyClass"]),
              ),
              set: $util.oneOfSetter($oneOfFields),
            });

            /**
             * Creates a new TherapeuticRegimen instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @static
             * @param {org.phenopackets.schema.v2.core.ITherapeuticRegimen=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.TherapeuticRegimen} TherapeuticRegimen instance
             */
            TherapeuticRegimen.create = function create(properties) {
              return new TherapeuticRegimen(properties);
            };

            /**
             * Encodes the specified TherapeuticRegimen message. Does not implicitly {@link org.phenopackets.schema.v2.core.TherapeuticRegimen.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @static
             * @param {org.phenopackets.schema.v2.core.ITherapeuticRegimen} message TherapeuticRegimen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TherapeuticRegimen.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.externalReference != null &&
                Object.hasOwnProperty.call(message, "externalReference")
              )
                $root.org.phenopackets.schema.v2.core.ExternalReference.encode(
                  message.externalReference,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.ontologyClass != null &&
                Object.hasOwnProperty.call(message, "ontologyClass")
              )
                $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                  message.ontologyClass,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (
                message.startTime != null &&
                Object.hasOwnProperty.call(message, "startTime")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.startTime,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              if (
                message.endTime != null &&
                Object.hasOwnProperty.call(message, "endTime")
              )
                $root.org.phenopackets.schema.v2.core.TimeElement.encode(
                  message.endTime,
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
              if (
                message.regimenStatus != null &&
                Object.hasOwnProperty.call(message, "regimenStatus")
              )
                writer
                  .uint32(/* id 5, wireType 0 =*/ 40)
                  .int32(message.regimenStatus);
              return writer;
            };

            /**
             * Encodes the specified TherapeuticRegimen message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.TherapeuticRegimen.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @static
             * @param {org.phenopackets.schema.v2.core.ITherapeuticRegimen} message TherapeuticRegimen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TherapeuticRegimen.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TherapeuticRegimen message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.TherapeuticRegimen} TherapeuticRegimen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TherapeuticRegimen.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message =
                  new $root.org.phenopackets.schema.v2.core.TherapeuticRegimen();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.externalReference =
                      $root.org.phenopackets.schema.v2.core.ExternalReference.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 2: {
                    message.ontologyClass =
                      $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 3: {
                    message.startTime =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 4: {
                    message.endTime =
                      $root.org.phenopackets.schema.v2.core.TimeElement.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 5: {
                    message.regimenStatus = reader.int32();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a TherapeuticRegimen message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.TherapeuticRegimen} TherapeuticRegimen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TherapeuticRegimen.decodeDelimited = function decodeDelimited(
              reader,
            ) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TherapeuticRegimen message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TherapeuticRegimen.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              let properties = {};
              if (
                message.externalReference != null &&
                message.hasOwnProperty("externalReference")
              ) {
                properties.identifier = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.ExternalReference.verify(
                      message.externalReference,
                    );
                  if (error) return "externalReference." + error;
                }
              }
              if (
                message.ontologyClass != null &&
                message.hasOwnProperty("ontologyClass")
              ) {
                if (properties.identifier === 1)
                  return "identifier: multiple values";
                properties.identifier = 1;
                {
                  let error =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                      message.ontologyClass,
                    );
                  if (error) return "ontologyClass." + error;
                }
              }
              if (
                message.startTime != null &&
                message.hasOwnProperty("startTime")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.startTime,
                  );
                if (error) return "startTime." + error;
              }
              if (
                message.endTime != null &&
                message.hasOwnProperty("endTime")
              ) {
                let error =
                  $root.org.phenopackets.schema.v2.core.TimeElement.verify(
                    message.endTime,
                  );
                if (error) return "endTime." + error;
              }
              if (
                message.regimenStatus != null &&
                message.hasOwnProperty("regimenStatus")
              )
                switch (message.regimenStatus) {
                  default:
                    return "regimenStatus: enum value expected";
                  case 0:
                  case 1:
                  case 2:
                  case 3:
                    break;
                }
              return null;
            };

            /**
             * Creates a TherapeuticRegimen message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.TherapeuticRegimen} TherapeuticRegimen
             */
            TherapeuticRegimen.fromObject = function fromObject(object) {
              if (
                object instanceof
                $root.org.phenopackets.schema.v2.core.TherapeuticRegimen
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.TherapeuticRegimen();
              if (object.externalReference != null) {
                if (typeof object.externalReference !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TherapeuticRegimen.externalReference: object expected",
                  );
                message.externalReference =
                  $root.org.phenopackets.schema.v2.core.ExternalReference.fromObject(
                    object.externalReference,
                  );
              }
              if (object.ontologyClass != null) {
                if (typeof object.ontologyClass !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TherapeuticRegimen.ontologyClass: object expected",
                  );
                message.ontologyClass =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                    object.ontologyClass,
                  );
              }
              if (object.startTime != null) {
                if (typeof object.startTime !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TherapeuticRegimen.startTime: object expected",
                  );
                message.startTime =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.startTime,
                  );
              }
              if (object.endTime != null) {
                if (typeof object.endTime !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.TherapeuticRegimen.endTime: object expected",
                  );
                message.endTime =
                  $root.org.phenopackets.schema.v2.core.TimeElement.fromObject(
                    object.endTime,
                  );
              }
              switch (object.regimenStatus) {
                case "UNKNOWN_STATUS":
                case 0:
                  message.regimenStatus = 0;
                  break;
                case "STARTED":
                case 1:
                  message.regimenStatus = 1;
                  break;
                case "COMPLETED":
                case 2:
                  message.regimenStatus = 2;
                  break;
                case "DISCONTINUED":
                case 3:
                  message.regimenStatus = 3;
                  break;
              }
              return message;
            };

            /**
             * Creates a plain object from a TherapeuticRegimen message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @static
             * @param {org.phenopackets.schema.v2.core.TherapeuticRegimen} message TherapeuticRegimen
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TherapeuticRegimen.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.startTime = null;
                object.endTime = null;
                object.regimenStatus =
                  options.enums === String ? "UNKNOWN_STATUS" : 0;
              }
              if (
                message.externalReference != null &&
                message.hasOwnProperty("externalReference")
              ) {
                object.externalReference =
                  $root.org.phenopackets.schema.v2.core.ExternalReference.toObject(
                    message.externalReference,
                    options,
                  );
                if (options.oneofs) object.identifier = "externalReference";
              }
              if (
                message.ontologyClass != null &&
                message.hasOwnProperty("ontologyClass")
              ) {
                object.ontologyClass =
                  $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                    message.ontologyClass,
                    options,
                  );
                if (options.oneofs) object.identifier = "ontologyClass";
              }
              if (
                message.startTime != null &&
                message.hasOwnProperty("startTime")
              )
                object.startTime =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.startTime,
                    options,
                  );
              if (message.endTime != null && message.hasOwnProperty("endTime"))
                object.endTime =
                  $root.org.phenopackets.schema.v2.core.TimeElement.toObject(
                    message.endTime,
                    options,
                  );
              if (
                message.regimenStatus != null &&
                message.hasOwnProperty("regimenStatus")
              )
                object.regimenStatus =
                  options.enums === String
                    ? $root.org.phenopackets.schema.v2.core.TherapeuticRegimen
                        .RegimenStatus[message.regimenStatus]
                    : message.regimenStatus;
              return object;
            };

            /**
             * Converts this TherapeuticRegimen to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TherapeuticRegimen.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for TherapeuticRegimen
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.TherapeuticRegimen
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TherapeuticRegimen.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix +
                "/org.phenopackets.schema.v2.core.TherapeuticRegimen"
              );
            };

            /**
             * RegimenStatus enum.
             * @name org.phenopackets.schema.v2.core.TherapeuticRegimen.RegimenStatus
             * @enum {number}
             * @property {number} UNKNOWN_STATUS=0 UNKNOWN_STATUS value
             * @property {number} STARTED=1 STARTED value
             * @property {number} COMPLETED=2 COMPLETED value
             * @property {number} DISCONTINUED=3 DISCONTINUED value
             */
            TherapeuticRegimen.RegimenStatus = (function () {
              const valuesById = {},
                values = Object.create(valuesById);
              values[(valuesById[0] = "UNKNOWN_STATUS")] = 0;
              values[(valuesById[1] = "STARTED")] = 1;
              values[(valuesById[2] = "COMPLETED")] = 2;
              values[(valuesById[3] = "DISCONTINUED")] = 3;
              return values;
            })();

            return TherapeuticRegimen;
          })();

          core.MetaData = (function () {
            /**
             * Properties of a MetaData.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IMetaData
             * @property {google.protobuf.ITimestamp|null} [created] MetaData created
             * @property {string|null} [createdBy] MetaData createdBy
             * @property {string|null} [submittedBy] MetaData submittedBy
             * @property {Array.<org.phenopackets.schema.v2.core.IResource>|null} [resources] MetaData resources
             * @property {Array.<org.phenopackets.schema.v2.core.IUpdate>|null} [updates] MetaData updates
             * @property {string|null} [phenopacketSchemaVersion] MetaData phenopacketSchemaVersion
             * @property {Array.<org.phenopackets.schema.v2.core.IExternalReference>|null} [externalReferences] MetaData externalReferences
             */

            /**
             * Constructs a new MetaData.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a MetaData.
             * @implements IMetaData
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IMetaData=} [properties] Properties to set
             */
            function MetaData(properties) {
              this.resources = [];
              this.updates = [];
              this.externalReferences = [];
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * MetaData created.
             * @member {google.protobuf.ITimestamp|null|undefined} created
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @instance
             */
            MetaData.prototype.created = null;

            /**
             * MetaData createdBy.
             * @member {string} createdBy
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @instance
             */
            MetaData.prototype.createdBy = "";

            /**
             * MetaData submittedBy.
             * @member {string} submittedBy
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @instance
             */
            MetaData.prototype.submittedBy = "";

            /**
             * MetaData resources.
             * @member {Array.<org.phenopackets.schema.v2.core.IResource>} resources
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @instance
             */
            MetaData.prototype.resources = $util.emptyArray;

            /**
             * MetaData updates.
             * @member {Array.<org.phenopackets.schema.v2.core.IUpdate>} updates
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @instance
             */
            MetaData.prototype.updates = $util.emptyArray;

            /**
             * MetaData phenopacketSchemaVersion.
             * @member {string} phenopacketSchemaVersion
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @instance
             */
            MetaData.prototype.phenopacketSchemaVersion = "";

            /**
             * MetaData externalReferences.
             * @member {Array.<org.phenopackets.schema.v2.core.IExternalReference>} externalReferences
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @instance
             */
            MetaData.prototype.externalReferences = $util.emptyArray;

            /**
             * Creates a new MetaData instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @static
             * @param {org.phenopackets.schema.v2.core.IMetaData=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.MetaData} MetaData instance
             */
            MetaData.create = function create(properties) {
              return new MetaData(properties);
            };

            /**
             * Encodes the specified MetaData message. Does not implicitly {@link org.phenopackets.schema.v2.core.MetaData.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @static
             * @param {org.phenopackets.schema.v2.core.IMetaData} message MetaData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetaData.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.created != null &&
                Object.hasOwnProperty.call(message, "created")
              )
                $root.google.protobuf.Timestamp.encode(
                  message.created,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.createdBy != null &&
                Object.hasOwnProperty.call(message, "createdBy")
              )
                writer
                  .uint32(/* id 2, wireType 2 =*/ 18)
                  .string(message.createdBy);
              if (
                message.submittedBy != null &&
                Object.hasOwnProperty.call(message, "submittedBy")
              )
                writer
                  .uint32(/* id 3, wireType 2 =*/ 26)
                  .string(message.submittedBy);
              if (message.resources != null && message.resources.length)
                for (let i = 0; i < message.resources.length; ++i)
                  $root.org.phenopackets.schema.v2.core.Resource.encode(
                    message.resources[i],
                    writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                  ).ldelim();
              if (message.updates != null && message.updates.length)
                for (let i = 0; i < message.updates.length; ++i)
                  $root.org.phenopackets.schema.v2.core.Update.encode(
                    message.updates[i],
                    writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                  ).ldelim();
              if (
                message.phenopacketSchemaVersion != null &&
                Object.hasOwnProperty.call(message, "phenopacketSchemaVersion")
              )
                writer
                  .uint32(/* id 6, wireType 2 =*/ 50)
                  .string(message.phenopacketSchemaVersion);
              if (
                message.externalReferences != null &&
                message.externalReferences.length
              )
                for (let i = 0; i < message.externalReferences.length; ++i)
                  $root.org.phenopackets.schema.v2.core.ExternalReference.encode(
                    message.externalReferences[i],
                    writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified MetaData message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.MetaData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @static
             * @param {org.phenopackets.schema.v2.core.IMetaData} message MetaData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetaData.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MetaData message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.MetaData} MetaData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetaData.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.MetaData();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.created = $root.google.protobuf.Timestamp.decode(
                      reader,
                      reader.uint32(),
                    );
                    break;
                  }
                  case 2: {
                    message.createdBy = reader.string();
                    break;
                  }
                  case 3: {
                    message.submittedBy = reader.string();
                    break;
                  }
                  case 4: {
                    if (!(message.resources && message.resources.length))
                      message.resources = [];
                    message.resources.push(
                      $root.org.phenopackets.schema.v2.core.Resource.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 5: {
                    if (!(message.updates && message.updates.length))
                      message.updates = [];
                    message.updates.push(
                      $root.org.phenopackets.schema.v2.core.Update.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  case 6: {
                    message.phenopacketSchemaVersion = reader.string();
                    break;
                  }
                  case 7: {
                    if (
                      !(
                        message.externalReferences &&
                        message.externalReferences.length
                      )
                    )
                      message.externalReferences = [];
                    message.externalReferences.push(
                      $root.org.phenopackets.schema.v2.core.ExternalReference.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a MetaData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.MetaData} MetaData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetaData.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MetaData message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MetaData.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.created != null &&
                message.hasOwnProperty("created")
              ) {
                let error = $root.google.protobuf.Timestamp.verify(
                  message.created,
                );
                if (error) return "created." + error;
              }
              if (
                message.createdBy != null &&
                message.hasOwnProperty("createdBy")
              )
                if (!$util.isString(message.createdBy))
                  return "createdBy: string expected";
              if (
                message.submittedBy != null &&
                message.hasOwnProperty("submittedBy")
              )
                if (!$util.isString(message.submittedBy))
                  return "submittedBy: string expected";
              if (
                message.resources != null &&
                message.hasOwnProperty("resources")
              ) {
                if (!Array.isArray(message.resources))
                  return "resources: array expected";
                for (let i = 0; i < message.resources.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.Resource.verify(
                      message.resources[i],
                    );
                  if (error) return "resources." + error;
                }
              }
              if (
                message.updates != null &&
                message.hasOwnProperty("updates")
              ) {
                if (!Array.isArray(message.updates))
                  return "updates: array expected";
                for (let i = 0; i < message.updates.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.Update.verify(
                      message.updates[i],
                    );
                  if (error) return "updates." + error;
                }
              }
              if (
                message.phenopacketSchemaVersion != null &&
                message.hasOwnProperty("phenopacketSchemaVersion")
              )
                if (!$util.isString(message.phenopacketSchemaVersion))
                  return "phenopacketSchemaVersion: string expected";
              if (
                message.externalReferences != null &&
                message.hasOwnProperty("externalReferences")
              ) {
                if (!Array.isArray(message.externalReferences))
                  return "externalReferences: array expected";
                for (let i = 0; i < message.externalReferences.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.ExternalReference.verify(
                      message.externalReferences[i],
                    );
                  if (error) return "externalReferences." + error;
                }
              }
              return null;
            };

            /**
             * Creates a MetaData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.MetaData} MetaData
             */
            MetaData.fromObject = function fromObject(object) {
              if (
                object instanceof $root.org.phenopackets.schema.v2.core.MetaData
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.MetaData();
              if (object.created != null) {
                if (typeof object.created !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MetaData.created: object expected",
                  );
                message.created = $root.google.protobuf.Timestamp.fromObject(
                  object.created,
                );
              }
              if (object.createdBy != null)
                message.createdBy = String(object.createdBy);
              if (object.submittedBy != null)
                message.submittedBy = String(object.submittedBy);
              if (object.resources) {
                if (!Array.isArray(object.resources))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MetaData.resources: array expected",
                  );
                message.resources = [];
                for (let i = 0; i < object.resources.length; ++i) {
                  if (typeof object.resources[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.MetaData.resources: object expected",
                    );
                  message.resources[i] =
                    $root.org.phenopackets.schema.v2.core.Resource.fromObject(
                      object.resources[i],
                    );
                }
              }
              if (object.updates) {
                if (!Array.isArray(object.updates))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MetaData.updates: array expected",
                  );
                message.updates = [];
                for (let i = 0; i < object.updates.length; ++i) {
                  if (typeof object.updates[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.MetaData.updates: object expected",
                    );
                  message.updates[i] =
                    $root.org.phenopackets.schema.v2.core.Update.fromObject(
                      object.updates[i],
                    );
                }
              }
              if (object.phenopacketSchemaVersion != null)
                message.phenopacketSchemaVersion = String(
                  object.phenopacketSchemaVersion,
                );
              if (object.externalReferences) {
                if (!Array.isArray(object.externalReferences))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.MetaData.externalReferences: array expected",
                  );
                message.externalReferences = [];
                for (let i = 0; i < object.externalReferences.length; ++i) {
                  if (typeof object.externalReferences[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.MetaData.externalReferences: object expected",
                    );
                  message.externalReferences[i] =
                    $root.org.phenopackets.schema.v2.core.ExternalReference.fromObject(
                      object.externalReferences[i],
                    );
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a MetaData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @static
             * @param {org.phenopackets.schema.v2.core.MetaData} message MetaData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MetaData.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.arrays || options.defaults) {
                object.resources = [];
                object.updates = [];
                object.externalReferences = [];
              }
              if (options.defaults) {
                object.created = null;
                object.createdBy = "";
                object.submittedBy = "";
                object.phenopacketSchemaVersion = "";
              }
              if (message.created != null && message.hasOwnProperty("created"))
                object.created = $root.google.protobuf.Timestamp.toObject(
                  message.created,
                  options,
                );
              if (
                message.createdBy != null &&
                message.hasOwnProperty("createdBy")
              )
                object.createdBy = message.createdBy;
              if (
                message.submittedBy != null &&
                message.hasOwnProperty("submittedBy")
              )
                object.submittedBy = message.submittedBy;
              if (message.resources && message.resources.length) {
                object.resources = [];
                for (let j = 0; j < message.resources.length; ++j)
                  object.resources[j] =
                    $root.org.phenopackets.schema.v2.core.Resource.toObject(
                      message.resources[j],
                      options,
                    );
              }
              if (message.updates && message.updates.length) {
                object.updates = [];
                for (let j = 0; j < message.updates.length; ++j)
                  object.updates[j] =
                    $root.org.phenopackets.schema.v2.core.Update.toObject(
                      message.updates[j],
                      options,
                    );
              }
              if (
                message.phenopacketSchemaVersion != null &&
                message.hasOwnProperty("phenopacketSchemaVersion")
              )
                object.phenopacketSchemaVersion =
                  message.phenopacketSchemaVersion;
              if (
                message.externalReferences &&
                message.externalReferences.length
              ) {
                object.externalReferences = [];
                for (let j = 0; j < message.externalReferences.length; ++j)
                  object.externalReferences[j] =
                    $root.org.phenopackets.schema.v2.core.ExternalReference.toObject(
                      message.externalReferences[j],
                      options,
                    );
              }
              return object;
            };

            /**
             * Converts this MetaData to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MetaData.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for MetaData
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.MetaData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MetaData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.MetaData"
              );
            };

            return MetaData;
          })();

          core.Resource = (function () {
            /**
             * Properties of a Resource.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IResource
             * @property {string|null} [id] Resource id
             * @property {string|null} [name] Resource name
             * @property {string|null} [url] Resource url
             * @property {string|null} [version] Resource version
             * @property {string|null} [namespacePrefix] Resource namespacePrefix
             * @property {string|null} [iriPrefix] Resource iriPrefix
             */

            /**
             * Constructs a new Resource.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a Resource.
             * @implements IResource
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IResource=} [properties] Properties to set
             */
            function Resource(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Resource id.
             * @member {string} id
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @instance
             */
            Resource.prototype.id = "";

            /**
             * Resource name.
             * @member {string} name
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @instance
             */
            Resource.prototype.name = "";

            /**
             * Resource url.
             * @member {string} url
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @instance
             */
            Resource.prototype.url = "";

            /**
             * Resource version.
             * @member {string} version
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @instance
             */
            Resource.prototype.version = "";

            /**
             * Resource namespacePrefix.
             * @member {string} namespacePrefix
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @instance
             */
            Resource.prototype.namespacePrefix = "";

            /**
             * Resource iriPrefix.
             * @member {string} iriPrefix
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @instance
             */
            Resource.prototype.iriPrefix = "";

            /**
             * Creates a new Resource instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @static
             * @param {org.phenopackets.schema.v2.core.IResource=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Resource} Resource instance
             */
            Resource.create = function create(properties) {
              return new Resource(properties);
            };

            /**
             * Encodes the specified Resource message. Does not implicitly {@link org.phenopackets.schema.v2.core.Resource.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @static
             * @param {org.phenopackets.schema.v2.core.IResource} message Resource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Resource.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.id != null &&
                Object.hasOwnProperty.call(message, "id")
              )
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
              if (
                message.name != null &&
                Object.hasOwnProperty.call(message, "name")
              )
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
              if (
                message.url != null &&
                Object.hasOwnProperty.call(message, "url")
              )
                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.url);
              if (
                message.version != null &&
                Object.hasOwnProperty.call(message, "version")
              )
                writer
                  .uint32(/* id 4, wireType 2 =*/ 34)
                  .string(message.version);
              if (
                message.namespacePrefix != null &&
                Object.hasOwnProperty.call(message, "namespacePrefix")
              )
                writer
                  .uint32(/* id 5, wireType 2 =*/ 42)
                  .string(message.namespacePrefix);
              if (
                message.iriPrefix != null &&
                Object.hasOwnProperty.call(message, "iriPrefix")
              )
                writer
                  .uint32(/* id 6, wireType 2 =*/ 50)
                  .string(message.iriPrefix);
              return writer;
            };

            /**
             * Encodes the specified Resource message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Resource.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @static
             * @param {org.phenopackets.schema.v2.core.IResource} message Resource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Resource.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Resource message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Resource} Resource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Resource.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Resource();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.id = reader.string();
                    break;
                  }
                  case 2: {
                    message.name = reader.string();
                    break;
                  }
                  case 3: {
                    message.url = reader.string();
                    break;
                  }
                  case 4: {
                    message.version = reader.string();
                    break;
                  }
                  case 5: {
                    message.namespacePrefix = reader.string();
                    break;
                  }
                  case 6: {
                    message.iriPrefix = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Resource message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Resource} Resource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Resource.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Resource message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Resource.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id)) return "id: string expected";
              if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                  return "name: string expected";
              if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url)) return "url: string expected";
              if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                  return "version: string expected";
              if (
                message.namespacePrefix != null &&
                message.hasOwnProperty("namespacePrefix")
              )
                if (!$util.isString(message.namespacePrefix))
                  return "namespacePrefix: string expected";
              if (
                message.iriPrefix != null &&
                message.hasOwnProperty("iriPrefix")
              )
                if (!$util.isString(message.iriPrefix))
                  return "iriPrefix: string expected";
              return null;
            };

            /**
             * Creates a Resource message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Resource} Resource
             */
            Resource.fromObject = function fromObject(object) {
              if (
                object instanceof $root.org.phenopackets.schema.v2.core.Resource
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Resource();
              if (object.id != null) message.id = String(object.id);
              if (object.name != null) message.name = String(object.name);
              if (object.url != null) message.url = String(object.url);
              if (object.version != null)
                message.version = String(object.version);
              if (object.namespacePrefix != null)
                message.namespacePrefix = String(object.namespacePrefix);
              if (object.iriPrefix != null)
                message.iriPrefix = String(object.iriPrefix);
              return message;
            };

            /**
             * Creates a plain object from a Resource message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @static
             * @param {org.phenopackets.schema.v2.core.Resource} message Resource
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Resource.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.id = "";
                object.name = "";
                object.url = "";
                object.version = "";
                object.namespacePrefix = "";
                object.iriPrefix = "";
              }
              if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
              if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
              if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
              if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
              if (
                message.namespacePrefix != null &&
                message.hasOwnProperty("namespacePrefix")
              )
                object.namespacePrefix = message.namespacePrefix;
              if (
                message.iriPrefix != null &&
                message.hasOwnProperty("iriPrefix")
              )
                object.iriPrefix = message.iriPrefix;
              return object;
            };

            /**
             * Converts this Resource to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Resource.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Resource
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Resource
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Resource.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.Resource"
              );
            };

            return Resource;
          })();

          core.Update = (function () {
            /**
             * Properties of an Update.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IUpdate
             * @property {google.protobuf.ITimestamp|null} [timestamp] Update timestamp
             * @property {string|null} [updatedBy] Update updatedBy
             * @property {string|null} [comment] Update comment
             */

            /**
             * Constructs a new Update.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents an Update.
             * @implements IUpdate
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IUpdate=} [properties] Properties to set
             */
            function Update(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Update timestamp.
             * @member {google.protobuf.ITimestamp|null|undefined} timestamp
             * @memberof org.phenopackets.schema.v2.core.Update
             * @instance
             */
            Update.prototype.timestamp = null;

            /**
             * Update updatedBy.
             * @member {string} updatedBy
             * @memberof org.phenopackets.schema.v2.core.Update
             * @instance
             */
            Update.prototype.updatedBy = "";

            /**
             * Update comment.
             * @member {string} comment
             * @memberof org.phenopackets.schema.v2.core.Update
             * @instance
             */
            Update.prototype.comment = "";

            /**
             * Creates a new Update instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Update
             * @static
             * @param {org.phenopackets.schema.v2.core.IUpdate=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Update} Update instance
             */
            Update.create = function create(properties) {
              return new Update(properties);
            };

            /**
             * Encodes the specified Update message. Does not implicitly {@link org.phenopackets.schema.v2.core.Update.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Update
             * @static
             * @param {org.phenopackets.schema.v2.core.IUpdate} message Update message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Update.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.timestamp != null &&
                Object.hasOwnProperty.call(message, "timestamp")
              )
                $root.google.protobuf.Timestamp.encode(
                  message.timestamp,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.updatedBy != null &&
                Object.hasOwnProperty.call(message, "updatedBy")
              )
                writer
                  .uint32(/* id 2, wireType 2 =*/ 18)
                  .string(message.updatedBy);
              if (
                message.comment != null &&
                Object.hasOwnProperty.call(message, "comment")
              )
                writer
                  .uint32(/* id 3, wireType 2 =*/ 26)
                  .string(message.comment);
              return writer;
            };

            /**
             * Encodes the specified Update message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Update.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Update
             * @static
             * @param {org.phenopackets.schema.v2.core.IUpdate} message Update message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Update.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Update message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Update
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Update} Update
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Update.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Update();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.timestamp = $root.google.protobuf.Timestamp.decode(
                      reader,
                      reader.uint32(),
                    );
                    break;
                  }
                  case 2: {
                    message.updatedBy = reader.string();
                    break;
                  }
                  case 3: {
                    message.comment = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes an Update message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Update
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Update} Update
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Update.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Update message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Update
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Update.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.timestamp != null &&
                message.hasOwnProperty("timestamp")
              ) {
                let error = $root.google.protobuf.Timestamp.verify(
                  message.timestamp,
                );
                if (error) return "timestamp." + error;
              }
              if (
                message.updatedBy != null &&
                message.hasOwnProperty("updatedBy")
              )
                if (!$util.isString(message.updatedBy))
                  return "updatedBy: string expected";
              if (message.comment != null && message.hasOwnProperty("comment"))
                if (!$util.isString(message.comment))
                  return "comment: string expected";
              return null;
            };

            /**
             * Creates an Update message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Update
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Update} Update
             */
            Update.fromObject = function fromObject(object) {
              if (
                object instanceof $root.org.phenopackets.schema.v2.core.Update
              )
                return object;
              let message = new $root.org.phenopackets.schema.v2.core.Update();
              if (object.timestamp != null) {
                if (typeof object.timestamp !== "object")
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Update.timestamp: object expected",
                  );
                message.timestamp = $root.google.protobuf.Timestamp.fromObject(
                  object.timestamp,
                );
              }
              if (object.updatedBy != null)
                message.updatedBy = String(object.updatedBy);
              if (object.comment != null)
                message.comment = String(object.comment);
              return message;
            };

            /**
             * Creates a plain object from an Update message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Update
             * @static
             * @param {org.phenopackets.schema.v2.core.Update} message Update
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Update.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.defaults) {
                object.timestamp = null;
                object.updatedBy = "";
                object.comment = "";
              }
              if (
                message.timestamp != null &&
                message.hasOwnProperty("timestamp")
              )
                object.timestamp = $root.google.protobuf.Timestamp.toObject(
                  message.timestamp,
                  options,
                );
              if (
                message.updatedBy != null &&
                message.hasOwnProperty("updatedBy")
              )
                object.updatedBy = message.updatedBy;
              if (message.comment != null && message.hasOwnProperty("comment"))
                object.comment = message.comment;
              return object;
            };

            /**
             * Converts this Update to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Update
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Update.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Update
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Update
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Update.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/org.phenopackets.schema.v2.core.Update";
            };

            return Update;
          })();

          core.Pedigree = (function () {
            /**
             * Properties of a Pedigree.
             * @memberof org.phenopackets.schema.v2.core
             * @interface IPedigree
             * @property {Array.<org.phenopackets.schema.v2.core.Pedigree.IPerson>|null} [persons] Pedigree persons
             */

            /**
             * Constructs a new Pedigree.
             * @memberof org.phenopackets.schema.v2.core
             * @classdesc Represents a Pedigree.
             * @implements IPedigree
             * @constructor
             * @param {org.phenopackets.schema.v2.core.IPedigree=} [properties] Properties to set
             */
            function Pedigree(properties) {
              this.persons = [];
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Pedigree persons.
             * @member {Array.<org.phenopackets.schema.v2.core.Pedigree.IPerson>} persons
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @instance
             */
            Pedigree.prototype.persons = $util.emptyArray;

            /**
             * Creates a new Pedigree instance using the specified properties.
             * @function create
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @static
             * @param {org.phenopackets.schema.v2.core.IPedigree=} [properties] Properties to set
             * @returns {org.phenopackets.schema.v2.core.Pedigree} Pedigree instance
             */
            Pedigree.create = function create(properties) {
              return new Pedigree(properties);
            };

            /**
             * Encodes the specified Pedigree message. Does not implicitly {@link org.phenopackets.schema.v2.core.Pedigree.verify|verify} messages.
             * @function encode
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @static
             * @param {org.phenopackets.schema.v2.core.IPedigree} message Pedigree message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pedigree.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (message.persons != null && message.persons.length)
                for (let i = 0; i < message.persons.length; ++i)
                  $root.org.phenopackets.schema.v2.core.Pedigree.Person.encode(
                    message.persons[i],
                    writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                  ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Pedigree message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Pedigree.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @static
             * @param {org.phenopackets.schema.v2.core.IPedigree} message Pedigree message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Pedigree.encodeDelimited = function encodeDelimited(
              message,
              writer,
            ) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Pedigree message from the specified reader or buffer.
             * @function decode
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.phenopackets.schema.v2.core.Pedigree} Pedigree
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pedigree.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.phenopackets.schema.v2.core.Pedigree();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    if (!(message.persons && message.persons.length))
                      message.persons = [];
                    message.persons.push(
                      $root.org.phenopackets.schema.v2.core.Pedigree.Person.decode(
                        reader,
                        reader.uint32(),
                      ),
                    );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Pedigree message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.phenopackets.schema.v2.core.Pedigree} Pedigree
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Pedigree.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Pedigree message.
             * @function verify
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Pedigree.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (
                message.persons != null &&
                message.hasOwnProperty("persons")
              ) {
                if (!Array.isArray(message.persons))
                  return "persons: array expected";
                for (let i = 0; i < message.persons.length; ++i) {
                  let error =
                    $root.org.phenopackets.schema.v2.core.Pedigree.Person.verify(
                      message.persons[i],
                    );
                  if (error) return "persons." + error;
                }
              }
              return null;
            };

            /**
             * Creates a Pedigree message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.phenopackets.schema.v2.core.Pedigree} Pedigree
             */
            Pedigree.fromObject = function fromObject(object) {
              if (
                object instanceof $root.org.phenopackets.schema.v2.core.Pedigree
              )
                return object;
              let message =
                new $root.org.phenopackets.schema.v2.core.Pedigree();
              if (object.persons) {
                if (!Array.isArray(object.persons))
                  throw TypeError(
                    ".org.phenopackets.schema.v2.core.Pedigree.persons: array expected",
                  );
                message.persons = [];
                for (let i = 0; i < object.persons.length; ++i) {
                  if (typeof object.persons[i] !== "object")
                    throw TypeError(
                      ".org.phenopackets.schema.v2.core.Pedigree.persons: object expected",
                    );
                  message.persons[i] =
                    $root.org.phenopackets.schema.v2.core.Pedigree.Person.fromObject(
                      object.persons[i],
                    );
                }
              }
              return message;
            };

            /**
             * Creates a plain object from a Pedigree message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @static
             * @param {org.phenopackets.schema.v2.core.Pedigree} message Pedigree
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Pedigree.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (options.arrays || options.defaults) object.persons = [];
              if (message.persons && message.persons.length) {
                object.persons = [];
                for (let j = 0; j < message.persons.length; ++j)
                  object.persons[j] =
                    $root.org.phenopackets.schema.v2.core.Pedigree.Person.toObject(
                      message.persons[j],
                      options,
                    );
              }
              return object;
            };

            /**
             * Converts this Pedigree to JSON.
             * @function toJSON
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Pedigree.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Pedigree
             * @function getTypeUrl
             * @memberof org.phenopackets.schema.v2.core.Pedigree
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Pedigree.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return (
                typeUrlPrefix + "/org.phenopackets.schema.v2.core.Pedigree"
              );
            };

            Pedigree.Person = (function () {
              /**
               * Properties of a Person.
               * @memberof org.phenopackets.schema.v2.core.Pedigree
               * @interface IPerson
               * @property {string|null} [familyId] Person familyId
               * @property {string|null} [individualId] Person individualId
               * @property {string|null} [paternalId] Person paternalId
               * @property {string|null} [maternalId] Person maternalId
               * @property {org.phenopackets.schema.v2.core.Sex|null} [sex] Person sex
               * @property {org.phenopackets.schema.v2.core.Pedigree.Person.AffectedStatus|null} [affectedStatus] Person affectedStatus
               */

              /**
               * Constructs a new Person.
               * @memberof org.phenopackets.schema.v2.core.Pedigree
               * @classdesc Represents a Person.
               * @implements IPerson
               * @constructor
               * @param {org.phenopackets.schema.v2.core.Pedigree.IPerson=} [properties] Properties to set
               */
              function Person(properties) {
                if (properties)
                  for (
                    let keys = Object.keys(properties), i = 0;
                    i < keys.length;
                    ++i
                  )
                    if (properties[keys[i]] != null)
                      this[keys[i]] = properties[keys[i]];
              }

              /**
               * Person familyId.
               * @member {string} familyId
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @instance
               */
              Person.prototype.familyId = "";

              /**
               * Person individualId.
               * @member {string} individualId
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @instance
               */
              Person.prototype.individualId = "";

              /**
               * Person paternalId.
               * @member {string} paternalId
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @instance
               */
              Person.prototype.paternalId = "";

              /**
               * Person maternalId.
               * @member {string} maternalId
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @instance
               */
              Person.prototype.maternalId = "";

              /**
               * Person sex.
               * @member {org.phenopackets.schema.v2.core.Sex} sex
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @instance
               */
              Person.prototype.sex = 0;

              /**
               * Person affectedStatus.
               * @member {org.phenopackets.schema.v2.core.Pedigree.Person.AffectedStatus} affectedStatus
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @instance
               */
              Person.prototype.affectedStatus = 0;

              /**
               * Creates a new Person instance using the specified properties.
               * @function create
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @static
               * @param {org.phenopackets.schema.v2.core.Pedigree.IPerson=} [properties] Properties to set
               * @returns {org.phenopackets.schema.v2.core.Pedigree.Person} Person instance
               */
              Person.create = function create(properties) {
                return new Person(properties);
              };

              /**
               * Encodes the specified Person message. Does not implicitly {@link org.phenopackets.schema.v2.core.Pedigree.Person.verify|verify} messages.
               * @function encode
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @static
               * @param {org.phenopackets.schema.v2.core.Pedigree.IPerson} message Person message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Person.encode = function encode(message, writer) {
                if (!writer) writer = $Writer.create();
                if (
                  message.familyId != null &&
                  Object.hasOwnProperty.call(message, "familyId")
                )
                  writer
                    .uint32(/* id 1, wireType 2 =*/ 10)
                    .string(message.familyId);
                if (
                  message.individualId != null &&
                  Object.hasOwnProperty.call(message, "individualId")
                )
                  writer
                    .uint32(/* id 2, wireType 2 =*/ 18)
                    .string(message.individualId);
                if (
                  message.paternalId != null &&
                  Object.hasOwnProperty.call(message, "paternalId")
                )
                  writer
                    .uint32(/* id 3, wireType 2 =*/ 26)
                    .string(message.paternalId);
                if (
                  message.maternalId != null &&
                  Object.hasOwnProperty.call(message, "maternalId")
                )
                  writer
                    .uint32(/* id 4, wireType 2 =*/ 34)
                    .string(message.maternalId);
                if (
                  message.sex != null &&
                  Object.hasOwnProperty.call(message, "sex")
                )
                  writer.uint32(/* id 5, wireType 0 =*/ 40).int32(message.sex);
                if (
                  message.affectedStatus != null &&
                  Object.hasOwnProperty.call(message, "affectedStatus")
                )
                  writer
                    .uint32(/* id 6, wireType 0 =*/ 48)
                    .int32(message.affectedStatus);
                return writer;
              };

              /**
               * Encodes the specified Person message, length delimited. Does not implicitly {@link org.phenopackets.schema.v2.core.Pedigree.Person.verify|verify} messages.
               * @function encodeDelimited
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @static
               * @param {org.phenopackets.schema.v2.core.Pedigree.IPerson} message Person message or plain object to encode
               * @param {$protobuf.Writer} [writer] Writer to encode to
               * @returns {$protobuf.Writer} Writer
               */
              Person.encodeDelimited = function encodeDelimited(
                message,
                writer,
              ) {
                return this.encode(message, writer).ldelim();
              };

              /**
               * Decodes a Person message from the specified reader or buffer.
               * @function decode
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @param {number} [length] Message length if known beforehand
               * @returns {org.phenopackets.schema.v2.core.Pedigree.Person} Person
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Person.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                  reader = $Reader.create(reader);
                let end =
                    length === undefined ? reader.len : reader.pos + length,
                  message =
                    new $root.org.phenopackets.schema.v2.core.Pedigree.Person();
                while (reader.pos < end) {
                  let tag = reader.uint32();
                  switch (tag >>> 3) {
                    case 1: {
                      message.familyId = reader.string();
                      break;
                    }
                    case 2: {
                      message.individualId = reader.string();
                      break;
                    }
                    case 3: {
                      message.paternalId = reader.string();
                      break;
                    }
                    case 4: {
                      message.maternalId = reader.string();
                      break;
                    }
                    case 5: {
                      message.sex = reader.int32();
                      break;
                    }
                    case 6: {
                      message.affectedStatus = reader.int32();
                      break;
                    }
                    default:
                      reader.skipType(tag & 7);
                      break;
                  }
                }
                return message;
              };

              /**
               * Decodes a Person message from the specified reader or buffer, length delimited.
               * @function decodeDelimited
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @static
               * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
               * @returns {org.phenopackets.schema.v2.core.Pedigree.Person} Person
               * @throws {Error} If the payload is not a reader or valid buffer
               * @throws {$protobuf.util.ProtocolError} If required fields are missing
               */
              Person.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader)) reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
              };

              /**
               * Verifies a Person message.
               * @function verify
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @static
               * @param {Object.<string,*>} message Plain object to verify
               * @returns {string|null} `null` if valid, otherwise the reason why it is not
               */
              Person.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                  return "object expected";
                if (
                  message.familyId != null &&
                  message.hasOwnProperty("familyId")
                )
                  if (!$util.isString(message.familyId))
                    return "familyId: string expected";
                if (
                  message.individualId != null &&
                  message.hasOwnProperty("individualId")
                )
                  if (!$util.isString(message.individualId))
                    return "individualId: string expected";
                if (
                  message.paternalId != null &&
                  message.hasOwnProperty("paternalId")
                )
                  if (!$util.isString(message.paternalId))
                    return "paternalId: string expected";
                if (
                  message.maternalId != null &&
                  message.hasOwnProperty("maternalId")
                )
                  if (!$util.isString(message.maternalId))
                    return "maternalId: string expected";
                if (message.sex != null && message.hasOwnProperty("sex"))
                  switch (message.sex) {
                    default:
                      return "sex: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                      break;
                  }
                if (
                  message.affectedStatus != null &&
                  message.hasOwnProperty("affectedStatus")
                )
                  switch (message.affectedStatus) {
                    default:
                      return "affectedStatus: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                      break;
                  }
                return null;
              };

              /**
               * Creates a Person message from a plain object. Also converts values to their respective internal types.
               * @function fromObject
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @static
               * @param {Object.<string,*>} object Plain object
               * @returns {org.phenopackets.schema.v2.core.Pedigree.Person} Person
               */
              Person.fromObject = function fromObject(object) {
                if (
                  object instanceof
                  $root.org.phenopackets.schema.v2.core.Pedigree.Person
                )
                  return object;
                let message =
                  new $root.org.phenopackets.schema.v2.core.Pedigree.Person();
                if (object.familyId != null)
                  message.familyId = String(object.familyId);
                if (object.individualId != null)
                  message.individualId = String(object.individualId);
                if (object.paternalId != null)
                  message.paternalId = String(object.paternalId);
                if (object.maternalId != null)
                  message.maternalId = String(object.maternalId);
                switch (object.sex) {
                  case "UNKNOWN_SEX":
                  case 0:
                    message.sex = 0;
                    break;
                  case "FEMALE":
                  case 1:
                    message.sex = 1;
                    break;
                  case "MALE":
                  case 2:
                    message.sex = 2;
                    break;
                  case "OTHER_SEX":
                  case 3:
                    message.sex = 3;
                    break;
                }
                switch (object.affectedStatus) {
                  case "MISSING":
                  case 0:
                    message.affectedStatus = 0;
                    break;
                  case "UNAFFECTED":
                  case 1:
                    message.affectedStatus = 1;
                    break;
                  case "AFFECTED":
                  case 2:
                    message.affectedStatus = 2;
                    break;
                }
                return message;
              };

              /**
               * Creates a plain object from a Person message. Also converts values to other types if specified.
               * @function toObject
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @static
               * @param {org.phenopackets.schema.v2.core.Pedigree.Person} message Person
               * @param {$protobuf.IConversionOptions} [options] Conversion options
               * @returns {Object.<string,*>} Plain object
               */
              Person.toObject = function toObject(message, options) {
                if (!options) options = {};
                let object = {};
                if (options.defaults) {
                  object.familyId = "";
                  object.individualId = "";
                  object.paternalId = "";
                  object.maternalId = "";
                  object.sex = options.enums === String ? "UNKNOWN_SEX" : 0;
                  object.affectedStatus =
                    options.enums === String ? "MISSING" : 0;
                }
                if (
                  message.familyId != null &&
                  message.hasOwnProperty("familyId")
                )
                  object.familyId = message.familyId;
                if (
                  message.individualId != null &&
                  message.hasOwnProperty("individualId")
                )
                  object.individualId = message.individualId;
                if (
                  message.paternalId != null &&
                  message.hasOwnProperty("paternalId")
                )
                  object.paternalId = message.paternalId;
                if (
                  message.maternalId != null &&
                  message.hasOwnProperty("maternalId")
                )
                  object.maternalId = message.maternalId;
                if (message.sex != null && message.hasOwnProperty("sex"))
                  object.sex =
                    options.enums === String
                      ? $root.org.phenopackets.schema.v2.core.Sex[message.sex]
                      : message.sex;
                if (
                  message.affectedStatus != null &&
                  message.hasOwnProperty("affectedStatus")
                )
                  object.affectedStatus =
                    options.enums === String
                      ? $root.org.phenopackets.schema.v2.core.Pedigree.Person
                          .AffectedStatus[message.affectedStatus]
                      : message.affectedStatus;
                return object;
              };

              /**
               * Converts this Person to JSON.
               * @function toJSON
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @instance
               * @returns {Object.<string,*>} JSON object
               */
              Person.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(
                  this,
                  $protobuf.util.toJSONOptions,
                );
              };

              /**
               * Gets the default type url for Person
               * @function getTypeUrl
               * @memberof org.phenopackets.schema.v2.core.Pedigree.Person
               * @static
               * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
               * @returns {string} The default type url
               */
              Person.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                  typeUrlPrefix = "type.googleapis.com";
                }
                return (
                  typeUrlPrefix +
                  "/org.phenopackets.schema.v2.core.Pedigree.Person"
                );
              };

              /**
               * AffectedStatus enum.
               * @name org.phenopackets.schema.v2.core.Pedigree.Person.AffectedStatus
               * @enum {number}
               * @property {number} MISSING=0 MISSING value
               * @property {number} UNAFFECTED=1 UNAFFECTED value
               * @property {number} AFFECTED=2 AFFECTED value
               */
              Person.AffectedStatus = (function () {
                const valuesById = {},
                  values = Object.create(valuesById);
                values[(valuesById[0] = "MISSING")] = 0;
                values[(valuesById[1] = "UNAFFECTED")] = 1;
                values[(valuesById[2] = "AFFECTED")] = 2;
                return values;
              })();

              return Person;
            })();

            return Pedigree;
          })();

          return core;
        })();

        return v2;
      })();

      return schema;
    })();

    return phenopackets;
  })();

  org.ga4gh = (function () {
    /**
     * Namespace ga4gh.
     * @memberof org
     * @namespace
     */
    const ga4gh = {};

    ga4gh.vrsatile = (function () {
      /**
       * Namespace vrsatile.
       * @memberof org.ga4gh
       * @namespace
       */
      const vrsatile = {};

      vrsatile.v1 = (function () {
        /**
         * Namespace v1.
         * @memberof org.ga4gh.vrsatile
         * @namespace
         */
        const v1 = {};

        v1.Extension = (function () {
          /**
           * Properties of an Extension.
           * @memberof org.ga4gh.vrsatile.v1
           * @interface IExtension
           * @property {string|null} [name] Extension name
           * @property {string|null} [value] Extension value
           */

          /**
           * Constructs a new Extension.
           * @memberof org.ga4gh.vrsatile.v1
           * @classdesc Represents an Extension.
           * @implements IExtension
           * @constructor
           * @param {org.ga4gh.vrsatile.v1.IExtension=} [properties] Properties to set
           */
          function Extension(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Extension name.
           * @member {string} name
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @instance
           */
          Extension.prototype.name = "";

          /**
           * Extension value.
           * @member {string} value
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @instance
           */
          Extension.prototype.value = "";

          /**
           * Creates a new Extension instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @static
           * @param {org.ga4gh.vrsatile.v1.IExtension=} [properties] Properties to set
           * @returns {org.ga4gh.vrsatile.v1.Extension} Extension instance
           */
          Extension.create = function create(properties) {
            return new Extension(properties);
          };

          /**
           * Encodes the specified Extension message. Does not implicitly {@link org.ga4gh.vrsatile.v1.Extension.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @static
           * @param {org.ga4gh.vrsatile.v1.IExtension} message Extension message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Extension.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.name != null &&
              Object.hasOwnProperty.call(message, "name")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
            if (
              message.value != null &&
              Object.hasOwnProperty.call(message, "value")
            )
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);
            return writer;
          };

          /**
           * Encodes the specified Extension message, length delimited. Does not implicitly {@link org.ga4gh.vrsatile.v1.Extension.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @static
           * @param {org.ga4gh.vrsatile.v1.IExtension} message Extension message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Extension.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an Extension message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrsatile.v1.Extension} Extension
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Extension.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrsatile.v1.Extension();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.name = reader.string();
                  break;
                }
                case 2: {
                  message.value = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an Extension message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrsatile.v1.Extension} Extension
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Extension.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an Extension message.
           * @function verify
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Extension.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
              if (!$util.isString(message.name)) return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
              if (!$util.isString(message.value))
                return "value: string expected";
            return null;
          };

          /**
           * Creates an Extension message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrsatile.v1.Extension} Extension
           */
          Extension.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrsatile.v1.Extension)
              return object;
            let message = new $root.org.ga4gh.vrsatile.v1.Extension();
            if (object.name != null) message.name = String(object.name);
            if (object.value != null) message.value = String(object.value);
            return message;
          };

          /**
           * Creates a plain object from an Extension message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @static
           * @param {org.ga4gh.vrsatile.v1.Extension} message Extension
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Extension.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              object.name = "";
              object.value = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
              object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
              object.value = message.value;
            return object;
          };

          /**
           * Converts this Extension to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Extension.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Extension
           * @function getTypeUrl
           * @memberof org.ga4gh.vrsatile.v1.Extension
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Extension.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrsatile.v1.Extension";
          };

          return Extension;
        })();

        v1.Expression = (function () {
          /**
           * Properties of an Expression.
           * @memberof org.ga4gh.vrsatile.v1
           * @interface IExpression
           * @property {string|null} [syntax] Expression syntax
           * @property {string|null} [value] Expression value
           * @property {string|null} [version] Expression version
           */

          /**
           * Constructs a new Expression.
           * @memberof org.ga4gh.vrsatile.v1
           * @classdesc Represents an Expression.
           * @implements IExpression
           * @constructor
           * @param {org.ga4gh.vrsatile.v1.IExpression=} [properties] Properties to set
           */
          function Expression(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Expression syntax.
           * @member {string} syntax
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @instance
           */
          Expression.prototype.syntax = "";

          /**
           * Expression value.
           * @member {string} value
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @instance
           */
          Expression.prototype.value = "";

          /**
           * Expression version.
           * @member {string} version
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @instance
           */
          Expression.prototype.version = "";

          /**
           * Creates a new Expression instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @static
           * @param {org.ga4gh.vrsatile.v1.IExpression=} [properties] Properties to set
           * @returns {org.ga4gh.vrsatile.v1.Expression} Expression instance
           */
          Expression.create = function create(properties) {
            return new Expression(properties);
          };

          /**
           * Encodes the specified Expression message. Does not implicitly {@link org.ga4gh.vrsatile.v1.Expression.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @static
           * @param {org.ga4gh.vrsatile.v1.IExpression} message Expression message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Expression.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.syntax != null &&
              Object.hasOwnProperty.call(message, "syntax")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.syntax);
            if (
              message.value != null &&
              Object.hasOwnProperty.call(message, "value")
            )
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.value);
            if (
              message.version != null &&
              Object.hasOwnProperty.call(message, "version")
            )
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.version);
            return writer;
          };

          /**
           * Encodes the specified Expression message, length delimited. Does not implicitly {@link org.ga4gh.vrsatile.v1.Expression.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @static
           * @param {org.ga4gh.vrsatile.v1.IExpression} message Expression message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Expression.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an Expression message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrsatile.v1.Expression} Expression
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Expression.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrsatile.v1.Expression();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.syntax = reader.string();
                  break;
                }
                case 2: {
                  message.value = reader.string();
                  break;
                }
                case 3: {
                  message.version = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an Expression message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrsatile.v1.Expression} Expression
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Expression.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an Expression message.
           * @function verify
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Expression.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.syntax != null && message.hasOwnProperty("syntax"))
              if (!$util.isString(message.syntax))
                return "syntax: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
              if (!$util.isString(message.value))
                return "value: string expected";
            if (message.version != null && message.hasOwnProperty("version"))
              if (!$util.isString(message.version))
                return "version: string expected";
            return null;
          };

          /**
           * Creates an Expression message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrsatile.v1.Expression} Expression
           */
          Expression.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrsatile.v1.Expression)
              return object;
            let message = new $root.org.ga4gh.vrsatile.v1.Expression();
            if (object.syntax != null) message.syntax = String(object.syntax);
            if (object.value != null) message.value = String(object.value);
            if (object.version != null)
              message.version = String(object.version);
            return message;
          };

          /**
           * Creates a plain object from an Expression message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @static
           * @param {org.ga4gh.vrsatile.v1.Expression} message Expression
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Expression.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              object.syntax = "";
              object.value = "";
              object.version = "";
            }
            if (message.syntax != null && message.hasOwnProperty("syntax"))
              object.syntax = message.syntax;
            if (message.value != null && message.hasOwnProperty("value"))
              object.value = message.value;
            if (message.version != null && message.hasOwnProperty("version"))
              object.version = message.version;
            return object;
          };

          /**
           * Converts this Expression to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Expression.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Expression
           * @function getTypeUrl
           * @memberof org.ga4gh.vrsatile.v1.Expression
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Expression.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrsatile.v1.Expression";
          };

          return Expression;
        })();

        v1.VcfRecord = (function () {
          /**
           * Properties of a VcfRecord.
           * @memberof org.ga4gh.vrsatile.v1
           * @interface IVcfRecord
           * @property {string|null} [genomeAssembly] VcfRecord genomeAssembly
           * @property {string|null} [chrom] VcfRecord chrom
           * @property {number|Long|null} [pos] VcfRecord pos
           * @property {string|null} [id] VcfRecord id
           * @property {string|null} [ref] VcfRecord ref
           * @property {string|null} [alt] VcfRecord alt
           * @property {string|null} [qual] VcfRecord qual
           * @property {string|null} [filter] VcfRecord filter
           * @property {string|null} [info] VcfRecord info
           */

          /**
           * Constructs a new VcfRecord.
           * @memberof org.ga4gh.vrsatile.v1
           * @classdesc Represents a VcfRecord.
           * @implements IVcfRecord
           * @constructor
           * @param {org.ga4gh.vrsatile.v1.IVcfRecord=} [properties] Properties to set
           */
          function VcfRecord(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * VcfRecord genomeAssembly.
           * @member {string} genomeAssembly
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @instance
           */
          VcfRecord.prototype.genomeAssembly = "";

          /**
           * VcfRecord chrom.
           * @member {string} chrom
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @instance
           */
          VcfRecord.prototype.chrom = "";

          /**
           * VcfRecord pos.
           * @member {number|Long} pos
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @instance
           */
          VcfRecord.prototype.pos = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;

          /**
           * VcfRecord id.
           * @member {string} id
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @instance
           */
          VcfRecord.prototype.id = "";

          /**
           * VcfRecord ref.
           * @member {string} ref
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @instance
           */
          VcfRecord.prototype.ref = "";

          /**
           * VcfRecord alt.
           * @member {string} alt
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @instance
           */
          VcfRecord.prototype.alt = "";

          /**
           * VcfRecord qual.
           * @member {string} qual
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @instance
           */
          VcfRecord.prototype.qual = "";

          /**
           * VcfRecord filter.
           * @member {string} filter
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @instance
           */
          VcfRecord.prototype.filter = "";

          /**
           * VcfRecord info.
           * @member {string} info
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @instance
           */
          VcfRecord.prototype.info = "";

          /**
           * Creates a new VcfRecord instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @static
           * @param {org.ga4gh.vrsatile.v1.IVcfRecord=} [properties] Properties to set
           * @returns {org.ga4gh.vrsatile.v1.VcfRecord} VcfRecord instance
           */
          VcfRecord.create = function create(properties) {
            return new VcfRecord(properties);
          };

          /**
           * Encodes the specified VcfRecord message. Does not implicitly {@link org.ga4gh.vrsatile.v1.VcfRecord.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @static
           * @param {org.ga4gh.vrsatile.v1.IVcfRecord} message VcfRecord message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          VcfRecord.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.genomeAssembly != null &&
              Object.hasOwnProperty.call(message, "genomeAssembly")
            )
              writer
                .uint32(/* id 1, wireType 2 =*/ 10)
                .string(message.genomeAssembly);
            if (
              message.chrom != null &&
              Object.hasOwnProperty.call(message, "chrom")
            )
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.chrom);
            if (
              message.pos != null &&
              Object.hasOwnProperty.call(message, "pos")
            )
              writer.uint32(/* id 3, wireType 0 =*/ 24).uint64(message.pos);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(/* id 4, wireType 2 =*/ 34).string(message.id);
            if (
              message.ref != null &&
              Object.hasOwnProperty.call(message, "ref")
            )
              writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.ref);
            if (
              message.alt != null &&
              Object.hasOwnProperty.call(message, "alt")
            )
              writer.uint32(/* id 6, wireType 2 =*/ 50).string(message.alt);
            if (
              message.qual != null &&
              Object.hasOwnProperty.call(message, "qual")
            )
              writer.uint32(/* id 7, wireType 2 =*/ 58).string(message.qual);
            if (
              message.filter != null &&
              Object.hasOwnProperty.call(message, "filter")
            )
              writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.filter);
            if (
              message.info != null &&
              Object.hasOwnProperty.call(message, "info")
            )
              writer.uint32(/* id 9, wireType 2 =*/ 74).string(message.info);
            return writer;
          };

          /**
           * Encodes the specified VcfRecord message, length delimited. Does not implicitly {@link org.ga4gh.vrsatile.v1.VcfRecord.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @static
           * @param {org.ga4gh.vrsatile.v1.IVcfRecord} message VcfRecord message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          VcfRecord.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a VcfRecord message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrsatile.v1.VcfRecord} VcfRecord
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          VcfRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrsatile.v1.VcfRecord();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.genomeAssembly = reader.string();
                  break;
                }
                case 2: {
                  message.chrom = reader.string();
                  break;
                }
                case 3: {
                  message.pos = reader.uint64();
                  break;
                }
                case 4: {
                  message.id = reader.string();
                  break;
                }
                case 5: {
                  message.ref = reader.string();
                  break;
                }
                case 6: {
                  message.alt = reader.string();
                  break;
                }
                case 7: {
                  message.qual = reader.string();
                  break;
                }
                case 8: {
                  message.filter = reader.string();
                  break;
                }
                case 9: {
                  message.info = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a VcfRecord message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrsatile.v1.VcfRecord} VcfRecord
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          VcfRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a VcfRecord message.
           * @function verify
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          VcfRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (
              message.genomeAssembly != null &&
              message.hasOwnProperty("genomeAssembly")
            )
              if (!$util.isString(message.genomeAssembly))
                return "genomeAssembly: string expected";
            if (message.chrom != null && message.hasOwnProperty("chrom"))
              if (!$util.isString(message.chrom))
                return "chrom: string expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
              if (
                !$util.isInteger(message.pos) &&
                !(
                  message.pos &&
                  $util.isInteger(message.pos.low) &&
                  $util.isInteger(message.pos.high)
                )
              )
                return "pos: integer|Long expected";
            if (message.id != null && message.hasOwnProperty("id"))
              if (!$util.isString(message.id)) return "id: string expected";
            if (message.ref != null && message.hasOwnProperty("ref"))
              if (!$util.isString(message.ref)) return "ref: string expected";
            if (message.alt != null && message.hasOwnProperty("alt"))
              if (!$util.isString(message.alt)) return "alt: string expected";
            if (message.qual != null && message.hasOwnProperty("qual"))
              if (!$util.isString(message.qual)) return "qual: string expected";
            if (message.filter != null && message.hasOwnProperty("filter"))
              if (!$util.isString(message.filter))
                return "filter: string expected";
            if (message.info != null && message.hasOwnProperty("info"))
              if (!$util.isString(message.info)) return "info: string expected";
            return null;
          };

          /**
           * Creates a VcfRecord message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrsatile.v1.VcfRecord} VcfRecord
           */
          VcfRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrsatile.v1.VcfRecord)
              return object;
            let message = new $root.org.ga4gh.vrsatile.v1.VcfRecord();
            if (object.genomeAssembly != null)
              message.genomeAssembly = String(object.genomeAssembly);
            if (object.chrom != null) message.chrom = String(object.chrom);
            if (object.pos != null)
              if ($util.Long)
                (message.pos = $util.Long.fromValue(
                  object.pos,
                )).unsigned = true;
              else if (typeof object.pos === "string")
                message.pos = parseInt(object.pos, 10);
              else if (typeof object.pos === "number") message.pos = object.pos;
              else if (typeof object.pos === "object")
                message.pos = new $util.LongBits(
                  object.pos.low >>> 0,
                  object.pos.high >>> 0,
                ).toNumber(true);
            if (object.id != null) message.id = String(object.id);
            if (object.ref != null) message.ref = String(object.ref);
            if (object.alt != null) message.alt = String(object.alt);
            if (object.qual != null) message.qual = String(object.qual);
            if (object.filter != null) message.filter = String(object.filter);
            if (object.info != null) message.info = String(object.info);
            return message;
          };

          /**
           * Creates a plain object from a VcfRecord message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @static
           * @param {org.ga4gh.vrsatile.v1.VcfRecord} message VcfRecord
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          VcfRecord.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              object.genomeAssembly = "";
              object.chrom = "";
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.pos =
                  options.longs === String
                    ? long.toString()
                    : options.longs === Number
                    ? long.toNumber()
                    : long;
              } else object.pos = options.longs === String ? "0" : 0;
              object.id = "";
              object.ref = "";
              object.alt = "";
              object.qual = "";
              object.filter = "";
              object.info = "";
            }
            if (
              message.genomeAssembly != null &&
              message.hasOwnProperty("genomeAssembly")
            )
              object.genomeAssembly = message.genomeAssembly;
            if (message.chrom != null && message.hasOwnProperty("chrom"))
              object.chrom = message.chrom;
            if (message.pos != null && message.hasOwnProperty("pos"))
              if (typeof message.pos === "number")
                object.pos =
                  options.longs === String ? String(message.pos) : message.pos;
              else
                object.pos =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.pos)
                    : options.longs === Number
                    ? new $util.LongBits(
                        message.pos.low >>> 0,
                        message.pos.high >>> 0,
                      ).toNumber(true)
                    : message.pos;
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (message.ref != null && message.hasOwnProperty("ref"))
              object.ref = message.ref;
            if (message.alt != null && message.hasOwnProperty("alt"))
              object.alt = message.alt;
            if (message.qual != null && message.hasOwnProperty("qual"))
              object.qual = message.qual;
            if (message.filter != null && message.hasOwnProperty("filter"))
              object.filter = message.filter;
            if (message.info != null && message.hasOwnProperty("info"))
              object.info = message.info;
            return object;
          };

          /**
           * Converts this VcfRecord to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          VcfRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for VcfRecord
           * @function getTypeUrl
           * @memberof org.ga4gh.vrsatile.v1.VcfRecord
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          VcfRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrsatile.v1.VcfRecord";
          };

          return VcfRecord;
        })();

        v1.VariationDescriptor = (function () {
          /**
           * Properties of a VariationDescriptor.
           * @memberof org.ga4gh.vrsatile.v1
           * @interface IVariationDescriptor
           * @property {string|null} [id] VariationDescriptor id
           * @property {org.ga4gh.vrs.v1.IVariation|null} [variation] VariationDescriptor variation
           * @property {string|null} [label] VariationDescriptor label
           * @property {string|null} [description] VariationDescriptor description
           * @property {org.ga4gh.vrsatile.v1.IGeneDescriptor|null} [geneContext] VariationDescriptor geneContext
           * @property {Array.<org.ga4gh.vrsatile.v1.IExpression>|null} [expressions] VariationDescriptor expressions
           * @property {org.ga4gh.vrsatile.v1.IVcfRecord|null} [vcfRecord] VariationDescriptor vcfRecord
           * @property {Array.<string>|null} [xrefs] VariationDescriptor xrefs
           * @property {Array.<string>|null} [alternateLabels] VariationDescriptor alternateLabels
           * @property {Array.<org.ga4gh.vrsatile.v1.IExtension>|null} [extensions] VariationDescriptor extensions
           * @property {org.ga4gh.vrsatile.v1.MoleculeContext|null} [moleculeContext] VariationDescriptor moleculeContext
           * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [structuralType] VariationDescriptor structuralType
           * @property {string|null} [vrsRefAlleleSeq] VariationDescriptor vrsRefAlleleSeq
           * @property {org.phenopackets.schema.v2.core.IOntologyClass|null} [allelicState] VariationDescriptor allelicState
           */

          /**
           * Constructs a new VariationDescriptor.
           * @memberof org.ga4gh.vrsatile.v1
           * @classdesc Represents a VariationDescriptor.
           * @implements IVariationDescriptor
           * @constructor
           * @param {org.ga4gh.vrsatile.v1.IVariationDescriptor=} [properties] Properties to set
           */
          function VariationDescriptor(properties) {
            this.expressions = [];
            this.xrefs = [];
            this.alternateLabels = [];
            this.extensions = [];
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * VariationDescriptor id.
           * @member {string} id
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.id = "";

          /**
           * VariationDescriptor variation.
           * @member {org.ga4gh.vrs.v1.IVariation|null|undefined} variation
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.variation = null;

          /**
           * VariationDescriptor label.
           * @member {string} label
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.label = "";

          /**
           * VariationDescriptor description.
           * @member {string} description
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.description = "";

          /**
           * VariationDescriptor geneContext.
           * @member {org.ga4gh.vrsatile.v1.IGeneDescriptor|null|undefined} geneContext
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.geneContext = null;

          /**
           * VariationDescriptor expressions.
           * @member {Array.<org.ga4gh.vrsatile.v1.IExpression>} expressions
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.expressions = $util.emptyArray;

          /**
           * VariationDescriptor vcfRecord.
           * @member {org.ga4gh.vrsatile.v1.IVcfRecord|null|undefined} vcfRecord
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.vcfRecord = null;

          /**
           * VariationDescriptor xrefs.
           * @member {Array.<string>} xrefs
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.xrefs = $util.emptyArray;

          /**
           * VariationDescriptor alternateLabels.
           * @member {Array.<string>} alternateLabels
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.alternateLabels = $util.emptyArray;

          /**
           * VariationDescriptor extensions.
           * @member {Array.<org.ga4gh.vrsatile.v1.IExtension>} extensions
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.extensions = $util.emptyArray;

          /**
           * VariationDescriptor moleculeContext.
           * @member {org.ga4gh.vrsatile.v1.MoleculeContext} moleculeContext
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.moleculeContext = 0;

          /**
           * VariationDescriptor structuralType.
           * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} structuralType
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.structuralType = null;

          /**
           * VariationDescriptor vrsRefAlleleSeq.
           * @member {string} vrsRefAlleleSeq
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.vrsRefAlleleSeq = "";

          /**
           * VariationDescriptor allelicState.
           * @member {org.phenopackets.schema.v2.core.IOntologyClass|null|undefined} allelicState
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           */
          VariationDescriptor.prototype.allelicState = null;

          /**
           * Creates a new VariationDescriptor instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @static
           * @param {org.ga4gh.vrsatile.v1.IVariationDescriptor=} [properties] Properties to set
           * @returns {org.ga4gh.vrsatile.v1.VariationDescriptor} VariationDescriptor instance
           */
          VariationDescriptor.create = function create(properties) {
            return new VariationDescriptor(properties);
          };

          /**
           * Encodes the specified VariationDescriptor message. Does not implicitly {@link org.ga4gh.vrsatile.v1.VariationDescriptor.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @static
           * @param {org.ga4gh.vrsatile.v1.IVariationDescriptor} message VariationDescriptor message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          VariationDescriptor.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.id);
            if (
              message.variation != null &&
              Object.hasOwnProperty.call(message, "variation")
            )
              $root.org.ga4gh.vrs.v1.Variation.encode(
                message.variation,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            if (
              message.label != null &&
              Object.hasOwnProperty.call(message, "label")
            )
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.label);
            if (
              message.description != null &&
              Object.hasOwnProperty.call(message, "description")
            )
              writer
                .uint32(/* id 4, wireType 2 =*/ 34)
                .string(message.description);
            if (
              message.geneContext != null &&
              Object.hasOwnProperty.call(message, "geneContext")
            )
              $root.org.ga4gh.vrsatile.v1.GeneDescriptor.encode(
                message.geneContext,
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
            if (message.expressions != null && message.expressions.length)
              for (let i = 0; i < message.expressions.length; ++i)
                $root.org.ga4gh.vrsatile.v1.Expression.encode(
                  message.expressions[i],
                  writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
                ).ldelim();
            if (
              message.vcfRecord != null &&
              Object.hasOwnProperty.call(message, "vcfRecord")
            )
              $root.org.ga4gh.vrsatile.v1.VcfRecord.encode(
                message.vcfRecord,
                writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
              ).ldelim();
            if (message.xrefs != null && message.xrefs.length)
              for (let i = 0; i < message.xrefs.length; ++i)
                writer
                  .uint32(/* id 8, wireType 2 =*/ 66)
                  .string(message.xrefs[i]);
            if (
              message.alternateLabels != null &&
              message.alternateLabels.length
            )
              for (let i = 0; i < message.alternateLabels.length; ++i)
                writer
                  .uint32(/* id 9, wireType 2 =*/ 74)
                  .string(message.alternateLabels[i]);
            if (message.extensions != null && message.extensions.length)
              for (let i = 0; i < message.extensions.length; ++i)
                $root.org.ga4gh.vrsatile.v1.Extension.encode(
                  message.extensions[i],
                  writer.uint32(/* id 10, wireType 2 =*/ 82).fork(),
                ).ldelim();
            if (
              message.moleculeContext != null &&
              Object.hasOwnProperty.call(message, "moleculeContext")
            )
              writer
                .uint32(/* id 11, wireType 0 =*/ 88)
                .int32(message.moleculeContext);
            if (
              message.structuralType != null &&
              Object.hasOwnProperty.call(message, "structuralType")
            )
              $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                message.structuralType,
                writer.uint32(/* id 12, wireType 2 =*/ 98).fork(),
              ).ldelim();
            if (
              message.vrsRefAlleleSeq != null &&
              Object.hasOwnProperty.call(message, "vrsRefAlleleSeq")
            )
              writer
                .uint32(/* id 13, wireType 2 =*/ 106)
                .string(message.vrsRefAlleleSeq);
            if (
              message.allelicState != null &&
              Object.hasOwnProperty.call(message, "allelicState")
            )
              $root.org.phenopackets.schema.v2.core.OntologyClass.encode(
                message.allelicState,
                writer.uint32(/* id 14, wireType 2 =*/ 114).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified VariationDescriptor message, length delimited. Does not implicitly {@link org.ga4gh.vrsatile.v1.VariationDescriptor.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @static
           * @param {org.ga4gh.vrsatile.v1.IVariationDescriptor} message VariationDescriptor message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          VariationDescriptor.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a VariationDescriptor message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrsatile.v1.VariationDescriptor} VariationDescriptor
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          VariationDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrsatile.v1.VariationDescriptor();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.id = reader.string();
                  break;
                }
                case 2: {
                  message.variation = $root.org.ga4gh.vrs.v1.Variation.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 3: {
                  message.label = reader.string();
                  break;
                }
                case 4: {
                  message.description = reader.string();
                  break;
                }
                case 5: {
                  message.geneContext =
                    $root.org.ga4gh.vrsatile.v1.GeneDescriptor.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 6: {
                  if (!(message.expressions && message.expressions.length))
                    message.expressions = [];
                  message.expressions.push(
                    $root.org.ga4gh.vrsatile.v1.Expression.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 7: {
                  message.vcfRecord =
                    $root.org.ga4gh.vrsatile.v1.VcfRecord.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 8: {
                  if (!(message.xrefs && message.xrefs.length))
                    message.xrefs = [];
                  message.xrefs.push(reader.string());
                  break;
                }
                case 9: {
                  if (
                    !(message.alternateLabels && message.alternateLabels.length)
                  )
                    message.alternateLabels = [];
                  message.alternateLabels.push(reader.string());
                  break;
                }
                case 10: {
                  if (!(message.extensions && message.extensions.length))
                    message.extensions = [];
                  message.extensions.push(
                    $root.org.ga4gh.vrsatile.v1.Extension.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                case 11: {
                  message.moleculeContext = reader.int32();
                  break;
                }
                case 12: {
                  message.structuralType =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 13: {
                  message.vrsRefAlleleSeq = reader.string();
                  break;
                }
                case 14: {
                  message.allelicState =
                    $root.org.phenopackets.schema.v2.core.OntologyClass.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a VariationDescriptor message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrsatile.v1.VariationDescriptor} VariationDescriptor
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          VariationDescriptor.decodeDelimited = function decodeDelimited(
            reader,
          ) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a VariationDescriptor message.
           * @function verify
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          VariationDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
              if (!$util.isString(message.id)) return "id: string expected";
            if (
              message.variation != null &&
              message.hasOwnProperty("variation")
            ) {
              let error = $root.org.ga4gh.vrs.v1.Variation.verify(
                message.variation,
              );
              if (error) return "variation." + error;
            }
            if (message.label != null && message.hasOwnProperty("label"))
              if (!$util.isString(message.label))
                return "label: string expected";
            if (
              message.description != null &&
              message.hasOwnProperty("description")
            )
              if (!$util.isString(message.description))
                return "description: string expected";
            if (
              message.geneContext != null &&
              message.hasOwnProperty("geneContext")
            ) {
              let error = $root.org.ga4gh.vrsatile.v1.GeneDescriptor.verify(
                message.geneContext,
              );
              if (error) return "geneContext." + error;
            }
            if (
              message.expressions != null &&
              message.hasOwnProperty("expressions")
            ) {
              if (!Array.isArray(message.expressions))
                return "expressions: array expected";
              for (let i = 0; i < message.expressions.length; ++i) {
                let error = $root.org.ga4gh.vrsatile.v1.Expression.verify(
                  message.expressions[i],
                );
                if (error) return "expressions." + error;
              }
            }
            if (
              message.vcfRecord != null &&
              message.hasOwnProperty("vcfRecord")
            ) {
              let error = $root.org.ga4gh.vrsatile.v1.VcfRecord.verify(
                message.vcfRecord,
              );
              if (error) return "vcfRecord." + error;
            }
            if (message.xrefs != null && message.hasOwnProperty("xrefs")) {
              if (!Array.isArray(message.xrefs)) return "xrefs: array expected";
              for (let i = 0; i < message.xrefs.length; ++i)
                if (!$util.isString(message.xrefs[i]))
                  return "xrefs: string[] expected";
            }
            if (
              message.alternateLabels != null &&
              message.hasOwnProperty("alternateLabels")
            ) {
              if (!Array.isArray(message.alternateLabels))
                return "alternateLabels: array expected";
              for (let i = 0; i < message.alternateLabels.length; ++i)
                if (!$util.isString(message.alternateLabels[i]))
                  return "alternateLabels: string[] expected";
            }
            if (
              message.extensions != null &&
              message.hasOwnProperty("extensions")
            ) {
              if (!Array.isArray(message.extensions))
                return "extensions: array expected";
              for (let i = 0; i < message.extensions.length; ++i) {
                let error = $root.org.ga4gh.vrsatile.v1.Extension.verify(
                  message.extensions[i],
                );
                if (error) return "extensions." + error;
              }
            }
            if (
              message.moleculeContext != null &&
              message.hasOwnProperty("moleculeContext")
            )
              switch (message.moleculeContext) {
                default:
                  return "moleculeContext: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                  break;
              }
            if (
              message.structuralType != null &&
              message.hasOwnProperty("structuralType")
            ) {
              let error =
                $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                  message.structuralType,
                );
              if (error) return "structuralType." + error;
            }
            if (
              message.vrsRefAlleleSeq != null &&
              message.hasOwnProperty("vrsRefAlleleSeq")
            )
              if (!$util.isString(message.vrsRefAlleleSeq))
                return "vrsRefAlleleSeq: string expected";
            if (
              message.allelicState != null &&
              message.hasOwnProperty("allelicState")
            ) {
              let error =
                $root.org.phenopackets.schema.v2.core.OntologyClass.verify(
                  message.allelicState,
                );
              if (error) return "allelicState." + error;
            }
            return null;
          };

          /**
           * Creates a VariationDescriptor message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrsatile.v1.VariationDescriptor} VariationDescriptor
           */
          VariationDescriptor.fromObject = function fromObject(object) {
            if (
              object instanceof $root.org.ga4gh.vrsatile.v1.VariationDescriptor
            )
              return object;
            let message = new $root.org.ga4gh.vrsatile.v1.VariationDescriptor();
            if (object.id != null) message.id = String(object.id);
            if (object.variation != null) {
              if (typeof object.variation !== "object")
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.VariationDescriptor.variation: object expected",
                );
              message.variation = $root.org.ga4gh.vrs.v1.Variation.fromObject(
                object.variation,
              );
            }
            if (object.label != null) message.label = String(object.label);
            if (object.description != null)
              message.description = String(object.description);
            if (object.geneContext != null) {
              if (typeof object.geneContext !== "object")
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.VariationDescriptor.geneContext: object expected",
                );
              message.geneContext =
                $root.org.ga4gh.vrsatile.v1.GeneDescriptor.fromObject(
                  object.geneContext,
                );
            }
            if (object.expressions) {
              if (!Array.isArray(object.expressions))
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.VariationDescriptor.expressions: array expected",
                );
              message.expressions = [];
              for (let i = 0; i < object.expressions.length; ++i) {
                if (typeof object.expressions[i] !== "object")
                  throw TypeError(
                    ".org.ga4gh.vrsatile.v1.VariationDescriptor.expressions: object expected",
                  );
                message.expressions[i] =
                  $root.org.ga4gh.vrsatile.v1.Expression.fromObject(
                    object.expressions[i],
                  );
              }
            }
            if (object.vcfRecord != null) {
              if (typeof object.vcfRecord !== "object")
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.VariationDescriptor.vcfRecord: object expected",
                );
              message.vcfRecord =
                $root.org.ga4gh.vrsatile.v1.VcfRecord.fromObject(
                  object.vcfRecord,
                );
            }
            if (object.xrefs) {
              if (!Array.isArray(object.xrefs))
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.VariationDescriptor.xrefs: array expected",
                );
              message.xrefs = [];
              for (let i = 0; i < object.xrefs.length; ++i)
                message.xrefs[i] = String(object.xrefs[i]);
            }
            if (object.alternateLabels) {
              if (!Array.isArray(object.alternateLabels))
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.VariationDescriptor.alternateLabels: array expected",
                );
              message.alternateLabels = [];
              for (let i = 0; i < object.alternateLabels.length; ++i)
                message.alternateLabels[i] = String(object.alternateLabels[i]);
            }
            if (object.extensions) {
              if (!Array.isArray(object.extensions))
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.VariationDescriptor.extensions: array expected",
                );
              message.extensions = [];
              for (let i = 0; i < object.extensions.length; ++i) {
                if (typeof object.extensions[i] !== "object")
                  throw TypeError(
                    ".org.ga4gh.vrsatile.v1.VariationDescriptor.extensions: object expected",
                  );
                message.extensions[i] =
                  $root.org.ga4gh.vrsatile.v1.Extension.fromObject(
                    object.extensions[i],
                  );
              }
            }
            switch (object.moleculeContext) {
              case "unspecified_molecule_context":
              case 0:
                message.moleculeContext = 0;
                break;
              case "genomic":
              case 1:
                message.moleculeContext = 1;
                break;
              case "transcript":
              case 2:
                message.moleculeContext = 2;
                break;
              case "protein":
              case 3:
                message.moleculeContext = 3;
                break;
            }
            if (object.structuralType != null) {
              if (typeof object.structuralType !== "object")
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.VariationDescriptor.structuralType: object expected",
                );
              message.structuralType =
                $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                  object.structuralType,
                );
            }
            if (object.vrsRefAlleleSeq != null)
              message.vrsRefAlleleSeq = String(object.vrsRefAlleleSeq);
            if (object.allelicState != null) {
              if (typeof object.allelicState !== "object")
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.VariationDescriptor.allelicState: object expected",
                );
              message.allelicState =
                $root.org.phenopackets.schema.v2.core.OntologyClass.fromObject(
                  object.allelicState,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a VariationDescriptor message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @static
           * @param {org.ga4gh.vrsatile.v1.VariationDescriptor} message VariationDescriptor
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          VariationDescriptor.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.arrays || options.defaults) {
              object.expressions = [];
              object.xrefs = [];
              object.alternateLabels = [];
              object.extensions = [];
            }
            if (options.defaults) {
              object.id = "";
              object.variation = null;
              object.label = "";
              object.description = "";
              object.geneContext = null;
              object.vcfRecord = null;
              object.moleculeContext =
                options.enums === String ? "unspecified_molecule_context" : 0;
              object.structuralType = null;
              object.vrsRefAlleleSeq = "";
              object.allelicState = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
              object.id = message.id;
            if (
              message.variation != null &&
              message.hasOwnProperty("variation")
            )
              object.variation = $root.org.ga4gh.vrs.v1.Variation.toObject(
                message.variation,
                options,
              );
            if (message.label != null && message.hasOwnProperty("label"))
              object.label = message.label;
            if (
              message.description != null &&
              message.hasOwnProperty("description")
            )
              object.description = message.description;
            if (
              message.geneContext != null &&
              message.hasOwnProperty("geneContext")
            )
              object.geneContext =
                $root.org.ga4gh.vrsatile.v1.GeneDescriptor.toObject(
                  message.geneContext,
                  options,
                );
            if (message.expressions && message.expressions.length) {
              object.expressions = [];
              for (let j = 0; j < message.expressions.length; ++j)
                object.expressions[j] =
                  $root.org.ga4gh.vrsatile.v1.Expression.toObject(
                    message.expressions[j],
                    options,
                  );
            }
            if (
              message.vcfRecord != null &&
              message.hasOwnProperty("vcfRecord")
            )
              object.vcfRecord = $root.org.ga4gh.vrsatile.v1.VcfRecord.toObject(
                message.vcfRecord,
                options,
              );
            if (message.xrefs && message.xrefs.length) {
              object.xrefs = [];
              for (let j = 0; j < message.xrefs.length; ++j)
                object.xrefs[j] = message.xrefs[j];
            }
            if (message.alternateLabels && message.alternateLabels.length) {
              object.alternateLabels = [];
              for (let j = 0; j < message.alternateLabels.length; ++j)
                object.alternateLabels[j] = message.alternateLabels[j];
            }
            if (message.extensions && message.extensions.length) {
              object.extensions = [];
              for (let j = 0; j < message.extensions.length; ++j)
                object.extensions[j] =
                  $root.org.ga4gh.vrsatile.v1.Extension.toObject(
                    message.extensions[j],
                    options,
                  );
            }
            if (
              message.moleculeContext != null &&
              message.hasOwnProperty("moleculeContext")
            )
              object.moleculeContext =
                options.enums === String
                  ? $root.org.ga4gh.vrsatile.v1.MoleculeContext[
                      message.moleculeContext
                    ]
                  : message.moleculeContext;
            if (
              message.structuralType != null &&
              message.hasOwnProperty("structuralType")
            )
              object.structuralType =
                $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                  message.structuralType,
                  options,
                );
            if (
              message.vrsRefAlleleSeq != null &&
              message.hasOwnProperty("vrsRefAlleleSeq")
            )
              object.vrsRefAlleleSeq = message.vrsRefAlleleSeq;
            if (
              message.allelicState != null &&
              message.hasOwnProperty("allelicState")
            )
              object.allelicState =
                $root.org.phenopackets.schema.v2.core.OntologyClass.toObject(
                  message.allelicState,
                  options,
                );
            return object;
          };

          /**
           * Converts this VariationDescriptor to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          VariationDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for VariationDescriptor
           * @function getTypeUrl
           * @memberof org.ga4gh.vrsatile.v1.VariationDescriptor
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          VariationDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrsatile.v1.VariationDescriptor";
          };

          return VariationDescriptor;
        })();

        /**
         * MoleculeContext enum.
         * @name org.ga4gh.vrsatile.v1.MoleculeContext
         * @enum {number}
         * @property {number} unspecified_molecule_context=0 unspecified_molecule_context value
         * @property {number} genomic=1 genomic value
         * @property {number} transcript=2 transcript value
         * @property {number} protein=3 protein value
         */
        v1.MoleculeContext = (function () {
          const valuesById = {},
            values = Object.create(valuesById);
          values[(valuesById[0] = "unspecified_molecule_context")] = 0;
          values[(valuesById[1] = "genomic")] = 1;
          values[(valuesById[2] = "transcript")] = 2;
          values[(valuesById[3] = "protein")] = 3;
          return values;
        })();

        v1.GeneDescriptor = (function () {
          /**
           * Properties of a GeneDescriptor.
           * @memberof org.ga4gh.vrsatile.v1
           * @interface IGeneDescriptor
           * @property {string|null} [valueId] GeneDescriptor valueId
           * @property {string|null} [symbol] GeneDescriptor symbol
           * @property {string|null} [description] GeneDescriptor description
           * @property {Array.<string>|null} [alternateIds] GeneDescriptor alternateIds
           * @property {Array.<string>|null} [alternateSymbols] GeneDescriptor alternateSymbols
           * @property {Array.<string>|null} [xrefs] GeneDescriptor xrefs
           */

          /**
           * Constructs a new GeneDescriptor.
           * @memberof org.ga4gh.vrsatile.v1
           * @classdesc Represents a GeneDescriptor.
           * @implements IGeneDescriptor
           * @constructor
           * @param {org.ga4gh.vrsatile.v1.IGeneDescriptor=} [properties] Properties to set
           */
          function GeneDescriptor(properties) {
            this.alternateIds = [];
            this.alternateSymbols = [];
            this.xrefs = [];
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * GeneDescriptor valueId.
           * @member {string} valueId
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @instance
           */
          GeneDescriptor.prototype.valueId = "";

          /**
           * GeneDescriptor symbol.
           * @member {string} symbol
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @instance
           */
          GeneDescriptor.prototype.symbol = "";

          /**
           * GeneDescriptor description.
           * @member {string} description
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @instance
           */
          GeneDescriptor.prototype.description = "";

          /**
           * GeneDescriptor alternateIds.
           * @member {Array.<string>} alternateIds
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @instance
           */
          GeneDescriptor.prototype.alternateIds = $util.emptyArray;

          /**
           * GeneDescriptor alternateSymbols.
           * @member {Array.<string>} alternateSymbols
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @instance
           */
          GeneDescriptor.prototype.alternateSymbols = $util.emptyArray;

          /**
           * GeneDescriptor xrefs.
           * @member {Array.<string>} xrefs
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @instance
           */
          GeneDescriptor.prototype.xrefs = $util.emptyArray;

          /**
           * Creates a new GeneDescriptor instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @static
           * @param {org.ga4gh.vrsatile.v1.IGeneDescriptor=} [properties] Properties to set
           * @returns {org.ga4gh.vrsatile.v1.GeneDescriptor} GeneDescriptor instance
           */
          GeneDescriptor.create = function create(properties) {
            return new GeneDescriptor(properties);
          };

          /**
           * Encodes the specified GeneDescriptor message. Does not implicitly {@link org.ga4gh.vrsatile.v1.GeneDescriptor.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @static
           * @param {org.ga4gh.vrsatile.v1.IGeneDescriptor} message GeneDescriptor message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          GeneDescriptor.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.valueId != null &&
              Object.hasOwnProperty.call(message, "valueId")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.valueId);
            if (
              message.symbol != null &&
              Object.hasOwnProperty.call(message, "symbol")
            )
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.symbol);
            if (
              message.description != null &&
              Object.hasOwnProperty.call(message, "description")
            )
              writer
                .uint32(/* id 3, wireType 2 =*/ 26)
                .string(message.description);
            if (message.alternateIds != null && message.alternateIds.length)
              for (let i = 0; i < message.alternateIds.length; ++i)
                writer
                  .uint32(/* id 4, wireType 2 =*/ 34)
                  .string(message.alternateIds[i]);
            if (
              message.alternateSymbols != null &&
              message.alternateSymbols.length
            )
              for (let i = 0; i < message.alternateSymbols.length; ++i)
                writer
                  .uint32(/* id 5, wireType 2 =*/ 42)
                  .string(message.alternateSymbols[i]);
            if (message.xrefs != null && message.xrefs.length)
              for (let i = 0; i < message.xrefs.length; ++i)
                writer
                  .uint32(/* id 6, wireType 2 =*/ 50)
                  .string(message.xrefs[i]);
            return writer;
          };

          /**
           * Encodes the specified GeneDescriptor message, length delimited. Does not implicitly {@link org.ga4gh.vrsatile.v1.GeneDescriptor.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @static
           * @param {org.ga4gh.vrsatile.v1.IGeneDescriptor} message GeneDescriptor message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          GeneDescriptor.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a GeneDescriptor message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrsatile.v1.GeneDescriptor} GeneDescriptor
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          GeneDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrsatile.v1.GeneDescriptor();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.valueId = reader.string();
                  break;
                }
                case 2: {
                  message.symbol = reader.string();
                  break;
                }
                case 3: {
                  message.description = reader.string();
                  break;
                }
                case 4: {
                  if (!(message.alternateIds && message.alternateIds.length))
                    message.alternateIds = [];
                  message.alternateIds.push(reader.string());
                  break;
                }
                case 5: {
                  if (
                    !(
                      message.alternateSymbols &&
                      message.alternateSymbols.length
                    )
                  )
                    message.alternateSymbols = [];
                  message.alternateSymbols.push(reader.string());
                  break;
                }
                case 6: {
                  if (!(message.xrefs && message.xrefs.length))
                    message.xrefs = [];
                  message.xrefs.push(reader.string());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a GeneDescriptor message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrsatile.v1.GeneDescriptor} GeneDescriptor
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          GeneDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a GeneDescriptor message.
           * @function verify
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          GeneDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.valueId != null && message.hasOwnProperty("valueId"))
              if (!$util.isString(message.valueId))
                return "valueId: string expected";
            if (message.symbol != null && message.hasOwnProperty("symbol"))
              if (!$util.isString(message.symbol))
                return "symbol: string expected";
            if (
              message.description != null &&
              message.hasOwnProperty("description")
            )
              if (!$util.isString(message.description))
                return "description: string expected";
            if (
              message.alternateIds != null &&
              message.hasOwnProperty("alternateIds")
            ) {
              if (!Array.isArray(message.alternateIds))
                return "alternateIds: array expected";
              for (let i = 0; i < message.alternateIds.length; ++i)
                if (!$util.isString(message.alternateIds[i]))
                  return "alternateIds: string[] expected";
            }
            if (
              message.alternateSymbols != null &&
              message.hasOwnProperty("alternateSymbols")
            ) {
              if (!Array.isArray(message.alternateSymbols))
                return "alternateSymbols: array expected";
              for (let i = 0; i < message.alternateSymbols.length; ++i)
                if (!$util.isString(message.alternateSymbols[i]))
                  return "alternateSymbols: string[] expected";
            }
            if (message.xrefs != null && message.hasOwnProperty("xrefs")) {
              if (!Array.isArray(message.xrefs)) return "xrefs: array expected";
              for (let i = 0; i < message.xrefs.length; ++i)
                if (!$util.isString(message.xrefs[i]))
                  return "xrefs: string[] expected";
            }
            return null;
          };

          /**
           * Creates a GeneDescriptor message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrsatile.v1.GeneDescriptor} GeneDescriptor
           */
          GeneDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrsatile.v1.GeneDescriptor)
              return object;
            let message = new $root.org.ga4gh.vrsatile.v1.GeneDescriptor();
            if (object.valueId != null)
              message.valueId = String(object.valueId);
            if (object.symbol != null) message.symbol = String(object.symbol);
            if (object.description != null)
              message.description = String(object.description);
            if (object.alternateIds) {
              if (!Array.isArray(object.alternateIds))
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.GeneDescriptor.alternateIds: array expected",
                );
              message.alternateIds = [];
              for (let i = 0; i < object.alternateIds.length; ++i)
                message.alternateIds[i] = String(object.alternateIds[i]);
            }
            if (object.alternateSymbols) {
              if (!Array.isArray(object.alternateSymbols))
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.GeneDescriptor.alternateSymbols: array expected",
                );
              message.alternateSymbols = [];
              for (let i = 0; i < object.alternateSymbols.length; ++i)
                message.alternateSymbols[i] = String(
                  object.alternateSymbols[i],
                );
            }
            if (object.xrefs) {
              if (!Array.isArray(object.xrefs))
                throw TypeError(
                  ".org.ga4gh.vrsatile.v1.GeneDescriptor.xrefs: array expected",
                );
              message.xrefs = [];
              for (let i = 0; i < object.xrefs.length; ++i)
                message.xrefs[i] = String(object.xrefs[i]);
            }
            return message;
          };

          /**
           * Creates a plain object from a GeneDescriptor message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @static
           * @param {org.ga4gh.vrsatile.v1.GeneDescriptor} message GeneDescriptor
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          GeneDescriptor.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.arrays || options.defaults) {
              object.alternateIds = [];
              object.alternateSymbols = [];
              object.xrefs = [];
            }
            if (options.defaults) {
              object.valueId = "";
              object.symbol = "";
              object.description = "";
            }
            if (message.valueId != null && message.hasOwnProperty("valueId"))
              object.valueId = message.valueId;
            if (message.symbol != null && message.hasOwnProperty("symbol"))
              object.symbol = message.symbol;
            if (
              message.description != null &&
              message.hasOwnProperty("description")
            )
              object.description = message.description;
            if (message.alternateIds && message.alternateIds.length) {
              object.alternateIds = [];
              for (let j = 0; j < message.alternateIds.length; ++j)
                object.alternateIds[j] = message.alternateIds[j];
            }
            if (message.alternateSymbols && message.alternateSymbols.length) {
              object.alternateSymbols = [];
              for (let j = 0; j < message.alternateSymbols.length; ++j)
                object.alternateSymbols[j] = message.alternateSymbols[j];
            }
            if (message.xrefs && message.xrefs.length) {
              object.xrefs = [];
              for (let j = 0; j < message.xrefs.length; ++j)
                object.xrefs[j] = message.xrefs[j];
            }
            return object;
          };

          /**
           * Converts this GeneDescriptor to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          GeneDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for GeneDescriptor
           * @function getTypeUrl
           * @memberof org.ga4gh.vrsatile.v1.GeneDescriptor
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          GeneDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrsatile.v1.GeneDescriptor";
          };

          return GeneDescriptor;
        })();

        return v1;
      })();

      return vrsatile;
    })();

    ga4gh.vrs = (function () {
      /**
       * Namespace vrs.
       * @memberof org.ga4gh
       * @namespace
       */
      const vrs = {};

      vrs.v1 = (function () {
        /**
         * Namespace v1.
         * @memberof org.ga4gh.vrs
         * @namespace
         */
        const v1 = {};

        v1.Variation = (function () {
          /**
           * Properties of a Variation.
           * @memberof org.ga4gh.vrs.v1
           * @interface IVariation
           * @property {org.ga4gh.vrs.v1.IAllele|null} [allele] Variation allele
           * @property {org.ga4gh.vrs.v1.IHaplotype|null} [haplotype] Variation haplotype
           * @property {org.ga4gh.vrs.v1.ICopyNumber|null} [copyNumber] Variation copyNumber
           * @property {org.ga4gh.vrs.v1.IText|null} [text] Variation text
           * @property {org.ga4gh.vrs.v1.IVariationSet|null} [variationSet] Variation variationSet
           */

          /**
           * Constructs a new Variation.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a Variation.
           * @implements IVariation
           * @constructor
           * @param {org.ga4gh.vrs.v1.IVariation=} [properties] Properties to set
           */
          function Variation(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Variation allele.
           * @member {org.ga4gh.vrs.v1.IAllele|null|undefined} allele
           * @memberof org.ga4gh.vrs.v1.Variation
           * @instance
           */
          Variation.prototype.allele = null;

          /**
           * Variation haplotype.
           * @member {org.ga4gh.vrs.v1.IHaplotype|null|undefined} haplotype
           * @memberof org.ga4gh.vrs.v1.Variation
           * @instance
           */
          Variation.prototype.haplotype = null;

          /**
           * Variation copyNumber.
           * @member {org.ga4gh.vrs.v1.ICopyNumber|null|undefined} copyNumber
           * @memberof org.ga4gh.vrs.v1.Variation
           * @instance
           */
          Variation.prototype.copyNumber = null;

          /**
           * Variation text.
           * @member {org.ga4gh.vrs.v1.IText|null|undefined} text
           * @memberof org.ga4gh.vrs.v1.Variation
           * @instance
           */
          Variation.prototype.text = null;

          /**
           * Variation variationSet.
           * @member {org.ga4gh.vrs.v1.IVariationSet|null|undefined} variationSet
           * @memberof org.ga4gh.vrs.v1.Variation
           * @instance
           */
          Variation.prototype.variationSet = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * Variation variation.
           * @member {"allele"|"haplotype"|"copyNumber"|"text"|"variationSet"|undefined} variation
           * @memberof org.ga4gh.vrs.v1.Variation
           * @instance
           */
          Object.defineProperty(Variation.prototype, "variation", {
            get: $util.oneOfGetter(
              ($oneOfFields = [
                "allele",
                "haplotype",
                "copyNumber",
                "text",
                "variationSet",
              ]),
            ),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Creates a new Variation instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.Variation
           * @static
           * @param {org.ga4gh.vrs.v1.IVariation=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.Variation} Variation instance
           */
          Variation.create = function create(properties) {
            return new Variation(properties);
          };

          /**
           * Encodes the specified Variation message. Does not implicitly {@link org.ga4gh.vrs.v1.Variation.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.Variation
           * @static
           * @param {org.ga4gh.vrs.v1.IVariation} message Variation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Variation.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.allele != null &&
              Object.hasOwnProperty.call(message, "allele")
            )
              $root.org.ga4gh.vrs.v1.Allele.encode(
                message.allele,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            if (
              message.haplotype != null &&
              Object.hasOwnProperty.call(message, "haplotype")
            )
              $root.org.ga4gh.vrs.v1.Haplotype.encode(
                message.haplotype,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            if (
              message.copyNumber != null &&
              Object.hasOwnProperty.call(message, "copyNumber")
            )
              $root.org.ga4gh.vrs.v1.CopyNumber.encode(
                message.copyNumber,
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
            if (
              message.text != null &&
              Object.hasOwnProperty.call(message, "text")
            )
              $root.org.ga4gh.vrs.v1.Text.encode(
                message.text,
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
            if (
              message.variationSet != null &&
              Object.hasOwnProperty.call(message, "variationSet")
            )
              $root.org.ga4gh.vrs.v1.VariationSet.encode(
                message.variationSet,
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified Variation message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.Variation.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.Variation
           * @static
           * @param {org.ga4gh.vrs.v1.IVariation} message Variation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Variation.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Variation message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.Variation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.Variation} Variation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Variation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.Variation();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.allele = $root.org.ga4gh.vrs.v1.Allele.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 2: {
                  message.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 3: {
                  message.copyNumber = $root.org.ga4gh.vrs.v1.CopyNumber.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 4: {
                  message.text = $root.org.ga4gh.vrs.v1.Text.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 5: {
                  message.variationSet =
                    $root.org.ga4gh.vrs.v1.VariationSet.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Variation message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.Variation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.Variation} Variation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Variation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Variation message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.Variation
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Variation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (message.allele != null && message.hasOwnProperty("allele")) {
              properties.variation = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Allele.verify(
                  message.allele,
                );
                if (error) return "allele." + error;
              }
            }
            if (
              message.haplotype != null &&
              message.hasOwnProperty("haplotype")
            ) {
              if (properties.variation === 1)
                return "variation: multiple values";
              properties.variation = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Haplotype.verify(
                  message.haplotype,
                );
                if (error) return "haplotype." + error;
              }
            }
            if (
              message.copyNumber != null &&
              message.hasOwnProperty("copyNumber")
            ) {
              if (properties.variation === 1)
                return "variation: multiple values";
              properties.variation = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.CopyNumber.verify(
                  message.copyNumber,
                );
                if (error) return "copyNumber." + error;
              }
            }
            if (message.text != null && message.hasOwnProperty("text")) {
              if (properties.variation === 1)
                return "variation: multiple values";
              properties.variation = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Text.verify(message.text);
                if (error) return "text." + error;
              }
            }
            if (
              message.variationSet != null &&
              message.hasOwnProperty("variationSet")
            ) {
              if (properties.variation === 1)
                return "variation: multiple values";
              properties.variation = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.VariationSet.verify(
                  message.variationSet,
                );
                if (error) return "variationSet." + error;
              }
            }
            return null;
          };

          /**
           * Creates a Variation message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.Variation
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.Variation} Variation
           */
          Variation.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.Variation)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.Variation();
            if (object.allele != null) {
              if (typeof object.allele !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Variation.allele: object expected",
                );
              message.allele = $root.org.ga4gh.vrs.v1.Allele.fromObject(
                object.allele,
              );
            }
            if (object.haplotype != null) {
              if (typeof object.haplotype !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Variation.haplotype: object expected",
                );
              message.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.fromObject(
                object.haplotype,
              );
            }
            if (object.copyNumber != null) {
              if (typeof object.copyNumber !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Variation.copyNumber: object expected",
                );
              message.copyNumber = $root.org.ga4gh.vrs.v1.CopyNumber.fromObject(
                object.copyNumber,
              );
            }
            if (object.text != null) {
              if (typeof object.text !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Variation.text: object expected",
                );
              message.text = $root.org.ga4gh.vrs.v1.Text.fromObject(
                object.text,
              );
            }
            if (object.variationSet != null) {
              if (typeof object.variationSet !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Variation.variationSet: object expected",
                );
              message.variationSet =
                $root.org.ga4gh.vrs.v1.VariationSet.fromObject(
                  object.variationSet,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a Variation message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.Variation
           * @static
           * @param {org.ga4gh.vrs.v1.Variation} message Variation
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Variation.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (message.allele != null && message.hasOwnProperty("allele")) {
              object.allele = $root.org.ga4gh.vrs.v1.Allele.toObject(
                message.allele,
                options,
              );
              if (options.oneofs) object.variation = "allele";
            }
            if (
              message.haplotype != null &&
              message.hasOwnProperty("haplotype")
            ) {
              object.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.toObject(
                message.haplotype,
                options,
              );
              if (options.oneofs) object.variation = "haplotype";
            }
            if (
              message.copyNumber != null &&
              message.hasOwnProperty("copyNumber")
            ) {
              object.copyNumber = $root.org.ga4gh.vrs.v1.CopyNumber.toObject(
                message.copyNumber,
                options,
              );
              if (options.oneofs) object.variation = "copyNumber";
            }
            if (message.text != null && message.hasOwnProperty("text")) {
              object.text = $root.org.ga4gh.vrs.v1.Text.toObject(
                message.text,
                options,
              );
              if (options.oneofs) object.variation = "text";
            }
            if (
              message.variationSet != null &&
              message.hasOwnProperty("variationSet")
            ) {
              object.variationSet =
                $root.org.ga4gh.vrs.v1.VariationSet.toObject(
                  message.variationSet,
                  options,
                );
              if (options.oneofs) object.variation = "variationSet";
            }
            return object;
          };

          /**
           * Converts this Variation to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.Variation
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Variation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Variation
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.Variation
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Variation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.Variation";
          };

          return Variation;
        })();

        v1.MolecularVariation = (function () {
          /**
           * Properties of a MolecularVariation.
           * @memberof org.ga4gh.vrs.v1
           * @interface IMolecularVariation
           * @property {org.ga4gh.vrs.v1.IAllele|null} [allele] MolecularVariation allele
           * @property {org.ga4gh.vrs.v1.IHaplotype|null} [haplotype] MolecularVariation haplotype
           */

          /**
           * Constructs a new MolecularVariation.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a MolecularVariation.
           * @implements IMolecularVariation
           * @constructor
           * @param {org.ga4gh.vrs.v1.IMolecularVariation=} [properties] Properties to set
           */
          function MolecularVariation(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * MolecularVariation allele.
           * @member {org.ga4gh.vrs.v1.IAllele|null|undefined} allele
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @instance
           */
          MolecularVariation.prototype.allele = null;

          /**
           * MolecularVariation haplotype.
           * @member {org.ga4gh.vrs.v1.IHaplotype|null|undefined} haplotype
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @instance
           */
          MolecularVariation.prototype.haplotype = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * MolecularVariation molecularVariation.
           * @member {"allele"|"haplotype"|undefined} molecularVariation
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @instance
           */
          Object.defineProperty(
            MolecularVariation.prototype,
            "molecularVariation",
            {
              get: $util.oneOfGetter(($oneOfFields = ["allele", "haplotype"])),
              set: $util.oneOfSetter($oneOfFields),
            },
          );

          /**
           * Creates a new MolecularVariation instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @static
           * @param {org.ga4gh.vrs.v1.IMolecularVariation=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.MolecularVariation} MolecularVariation instance
           */
          MolecularVariation.create = function create(properties) {
            return new MolecularVariation(properties);
          };

          /**
           * Encodes the specified MolecularVariation message. Does not implicitly {@link org.ga4gh.vrs.v1.MolecularVariation.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @static
           * @param {org.ga4gh.vrs.v1.IMolecularVariation} message MolecularVariation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          MolecularVariation.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.allele != null &&
              Object.hasOwnProperty.call(message, "allele")
            )
              $root.org.ga4gh.vrs.v1.Allele.encode(
                message.allele,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            if (
              message.haplotype != null &&
              Object.hasOwnProperty.call(message, "haplotype")
            )
              $root.org.ga4gh.vrs.v1.Haplotype.encode(
                message.haplotype,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified MolecularVariation message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.MolecularVariation.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @static
           * @param {org.ga4gh.vrs.v1.IMolecularVariation} message MolecularVariation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          MolecularVariation.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a MolecularVariation message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.MolecularVariation} MolecularVariation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          MolecularVariation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.MolecularVariation();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.allele = $root.org.ga4gh.vrs.v1.Allele.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 2: {
                  message.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a MolecularVariation message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.MolecularVariation} MolecularVariation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          MolecularVariation.decodeDelimited = function decodeDelimited(
            reader,
          ) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a MolecularVariation message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          MolecularVariation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (message.allele != null && message.hasOwnProperty("allele")) {
              properties.molecularVariation = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Allele.verify(
                  message.allele,
                );
                if (error) return "allele." + error;
              }
            }
            if (
              message.haplotype != null &&
              message.hasOwnProperty("haplotype")
            ) {
              if (properties.molecularVariation === 1)
                return "molecularVariation: multiple values";
              properties.molecularVariation = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Haplotype.verify(
                  message.haplotype,
                );
                if (error) return "haplotype." + error;
              }
            }
            return null;
          };

          /**
           * Creates a MolecularVariation message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.MolecularVariation} MolecularVariation
           */
          MolecularVariation.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.MolecularVariation)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.MolecularVariation();
            if (object.allele != null) {
              if (typeof object.allele !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.MolecularVariation.allele: object expected",
                );
              message.allele = $root.org.ga4gh.vrs.v1.Allele.fromObject(
                object.allele,
              );
            }
            if (object.haplotype != null) {
              if (typeof object.haplotype !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.MolecularVariation.haplotype: object expected",
                );
              message.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.fromObject(
                object.haplotype,
              );
            }
            return message;
          };

          /**
           * Creates a plain object from a MolecularVariation message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @static
           * @param {org.ga4gh.vrs.v1.MolecularVariation} message MolecularVariation
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          MolecularVariation.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (message.allele != null && message.hasOwnProperty("allele")) {
              object.allele = $root.org.ga4gh.vrs.v1.Allele.toObject(
                message.allele,
                options,
              );
              if (options.oneofs) object.molecularVariation = "allele";
            }
            if (
              message.haplotype != null &&
              message.hasOwnProperty("haplotype")
            ) {
              object.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.toObject(
                message.haplotype,
                options,
              );
              if (options.oneofs) object.molecularVariation = "haplotype";
            }
            return object;
          };

          /**
           * Converts this MolecularVariation to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          MolecularVariation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for MolecularVariation
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.MolecularVariation
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          MolecularVariation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.MolecularVariation";
          };

          return MolecularVariation;
        })();

        v1.UtilityVariation = (function () {
          /**
           * Properties of an UtilityVariation.
           * @memberof org.ga4gh.vrs.v1
           * @interface IUtilityVariation
           * @property {org.ga4gh.vrs.v1.IText|null} [text] UtilityVariation text
           * @property {org.ga4gh.vrs.v1.IVariationSet|null} [variationSet] UtilityVariation variationSet
           */

          /**
           * Constructs a new UtilityVariation.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents an UtilityVariation.
           * @implements IUtilityVariation
           * @constructor
           * @param {org.ga4gh.vrs.v1.IUtilityVariation=} [properties] Properties to set
           */
          function UtilityVariation(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * UtilityVariation text.
           * @member {org.ga4gh.vrs.v1.IText|null|undefined} text
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @instance
           */
          UtilityVariation.prototype.text = null;

          /**
           * UtilityVariation variationSet.
           * @member {org.ga4gh.vrs.v1.IVariationSet|null|undefined} variationSet
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @instance
           */
          UtilityVariation.prototype.variationSet = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * UtilityVariation utilityVariation.
           * @member {"text"|"variationSet"|undefined} utilityVariation
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @instance
           */
          Object.defineProperty(
            UtilityVariation.prototype,
            "utilityVariation",
            {
              get: $util.oneOfGetter(($oneOfFields = ["text", "variationSet"])),
              set: $util.oneOfSetter($oneOfFields),
            },
          );

          /**
           * Creates a new UtilityVariation instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @static
           * @param {org.ga4gh.vrs.v1.IUtilityVariation=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.UtilityVariation} UtilityVariation instance
           */
          UtilityVariation.create = function create(properties) {
            return new UtilityVariation(properties);
          };

          /**
           * Encodes the specified UtilityVariation message. Does not implicitly {@link org.ga4gh.vrs.v1.UtilityVariation.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @static
           * @param {org.ga4gh.vrs.v1.IUtilityVariation} message UtilityVariation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          UtilityVariation.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.text != null &&
              Object.hasOwnProperty.call(message, "text")
            )
              $root.org.ga4gh.vrs.v1.Text.encode(
                message.text,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            if (
              message.variationSet != null &&
              Object.hasOwnProperty.call(message, "variationSet")
            )
              $root.org.ga4gh.vrs.v1.VariationSet.encode(
                message.variationSet,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified UtilityVariation message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.UtilityVariation.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @static
           * @param {org.ga4gh.vrs.v1.IUtilityVariation} message UtilityVariation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          UtilityVariation.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an UtilityVariation message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.UtilityVariation} UtilityVariation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          UtilityVariation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.UtilityVariation();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.text = $root.org.ga4gh.vrs.v1.Text.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 2: {
                  message.variationSet =
                    $root.org.ga4gh.vrs.v1.VariationSet.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an UtilityVariation message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.UtilityVariation} UtilityVariation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          UtilityVariation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an UtilityVariation message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          UtilityVariation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (message.text != null && message.hasOwnProperty("text")) {
              properties.utilityVariation = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Text.verify(message.text);
                if (error) return "text." + error;
              }
            }
            if (
              message.variationSet != null &&
              message.hasOwnProperty("variationSet")
            ) {
              if (properties.utilityVariation === 1)
                return "utilityVariation: multiple values";
              properties.utilityVariation = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.VariationSet.verify(
                  message.variationSet,
                );
                if (error) return "variationSet." + error;
              }
            }
            return null;
          };

          /**
           * Creates an UtilityVariation message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.UtilityVariation} UtilityVariation
           */
          UtilityVariation.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.UtilityVariation)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.UtilityVariation();
            if (object.text != null) {
              if (typeof object.text !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.UtilityVariation.text: object expected",
                );
              message.text = $root.org.ga4gh.vrs.v1.Text.fromObject(
                object.text,
              );
            }
            if (object.variationSet != null) {
              if (typeof object.variationSet !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.UtilityVariation.variationSet: object expected",
                );
              message.variationSet =
                $root.org.ga4gh.vrs.v1.VariationSet.fromObject(
                  object.variationSet,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from an UtilityVariation message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @static
           * @param {org.ga4gh.vrs.v1.UtilityVariation} message UtilityVariation
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          UtilityVariation.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (message.text != null && message.hasOwnProperty("text")) {
              object.text = $root.org.ga4gh.vrs.v1.Text.toObject(
                message.text,
                options,
              );
              if (options.oneofs) object.utilityVariation = "text";
            }
            if (
              message.variationSet != null &&
              message.hasOwnProperty("variationSet")
            ) {
              object.variationSet =
                $root.org.ga4gh.vrs.v1.VariationSet.toObject(
                  message.variationSet,
                  options,
                );
              if (options.oneofs) object.utilityVariation = "variationSet";
            }
            return object;
          };

          /**
           * Converts this UtilityVariation to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          UtilityVariation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for UtilityVariation
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.UtilityVariation
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          UtilityVariation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.UtilityVariation";
          };

          return UtilityVariation;
        })();

        v1.SystemicVariation = (function () {
          /**
           * Properties of a SystemicVariation.
           * @memberof org.ga4gh.vrs.v1
           * @interface ISystemicVariation
           * @property {org.ga4gh.vrs.v1.ICopyNumber|null} [copyNumber] SystemicVariation copyNumber
           */

          /**
           * Constructs a new SystemicVariation.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a SystemicVariation.
           * @implements ISystemicVariation
           * @constructor
           * @param {org.ga4gh.vrs.v1.ISystemicVariation=} [properties] Properties to set
           */
          function SystemicVariation(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * SystemicVariation copyNumber.
           * @member {org.ga4gh.vrs.v1.ICopyNumber|null|undefined} copyNumber
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @instance
           */
          SystemicVariation.prototype.copyNumber = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * SystemicVariation systemicVariation.
           * @member {"copyNumber"|undefined} systemicVariation
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @instance
           */
          Object.defineProperty(
            SystemicVariation.prototype,
            "systemicVariation",
            {
              get: $util.oneOfGetter(($oneOfFields = ["copyNumber"])),
              set: $util.oneOfSetter($oneOfFields),
            },
          );

          /**
           * Creates a new SystemicVariation instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @static
           * @param {org.ga4gh.vrs.v1.ISystemicVariation=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.SystemicVariation} SystemicVariation instance
           */
          SystemicVariation.create = function create(properties) {
            return new SystemicVariation(properties);
          };

          /**
           * Encodes the specified SystemicVariation message. Does not implicitly {@link org.ga4gh.vrs.v1.SystemicVariation.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @static
           * @param {org.ga4gh.vrs.v1.ISystemicVariation} message SystemicVariation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SystemicVariation.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.copyNumber != null &&
              Object.hasOwnProperty.call(message, "copyNumber")
            )
              $root.org.ga4gh.vrs.v1.CopyNumber.encode(
                message.copyNumber,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified SystemicVariation message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.SystemicVariation.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @static
           * @param {org.ga4gh.vrs.v1.ISystemicVariation} message SystemicVariation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SystemicVariation.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SystemicVariation message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.SystemicVariation} SystemicVariation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SystemicVariation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.SystemicVariation();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.copyNumber = $root.org.ga4gh.vrs.v1.CopyNumber.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SystemicVariation message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.SystemicVariation} SystemicVariation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SystemicVariation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SystemicVariation message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SystemicVariation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (
              message.copyNumber != null &&
              message.hasOwnProperty("copyNumber")
            ) {
              properties.systemicVariation = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.CopyNumber.verify(
                  message.copyNumber,
                );
                if (error) return "copyNumber." + error;
              }
            }
            return null;
          };

          /**
           * Creates a SystemicVariation message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.SystemicVariation} SystemicVariation
           */
          SystemicVariation.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.SystemicVariation)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.SystemicVariation();
            if (object.copyNumber != null) {
              if (typeof object.copyNumber !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SystemicVariation.copyNumber: object expected",
                );
              message.copyNumber = $root.org.ga4gh.vrs.v1.CopyNumber.fromObject(
                object.copyNumber,
              );
            }
            return message;
          };

          /**
           * Creates a plain object from a SystemicVariation message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @static
           * @param {org.ga4gh.vrs.v1.SystemicVariation} message SystemicVariation
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SystemicVariation.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (
              message.copyNumber != null &&
              message.hasOwnProperty("copyNumber")
            ) {
              object.copyNumber = $root.org.ga4gh.vrs.v1.CopyNumber.toObject(
                message.copyNumber,
                options,
              );
              if (options.oneofs) object.systemicVariation = "copyNumber";
            }
            return object;
          };

          /**
           * Converts this SystemicVariation to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SystemicVariation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for SystemicVariation
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.SystemicVariation
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          SystemicVariation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.SystemicVariation";
          };

          return SystemicVariation;
        })();

        v1.Allele = (function () {
          /**
           * Properties of an Allele.
           * @memberof org.ga4gh.vrs.v1
           * @interface IAllele
           * @property {string|null} [_id] Allele _id
           * @property {string|null} [curie] Allele curie
           * @property {org.ga4gh.vrs.v1.IChromosomeLocation|null} [chromosomeLocation] Allele chromosomeLocation
           * @property {org.ga4gh.vrs.v1.ISequenceLocation|null} [sequenceLocation] Allele sequenceLocation
           * @property {org.ga4gh.vrs.v1.ISequenceState|null} [sequenceState] Allele sequenceState
           * @property {org.ga4gh.vrs.v1.ILiteralSequenceExpression|null} [literalSequenceExpression] Allele literalSequenceExpression
           * @property {org.ga4gh.vrs.v1.IDerivedSequenceExpression|null} [derivedSequenceExpression] Allele derivedSequenceExpression
           * @property {org.ga4gh.vrs.v1.IRepeatedSequenceExpression|null} [repeatedSequenceExpression] Allele repeatedSequenceExpression
           */

          /**
           * Constructs a new Allele.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents an Allele.
           * @implements IAllele
           * @constructor
           * @param {org.ga4gh.vrs.v1.IAllele=} [properties] Properties to set
           */
          function Allele(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Allele _id.
           * @member {string} _id
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           */
          Allele.prototype._id = "";

          /**
           * Allele curie.
           * @member {string|null|undefined} curie
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           */
          Allele.prototype.curie = null;

          /**
           * Allele chromosomeLocation.
           * @member {org.ga4gh.vrs.v1.IChromosomeLocation|null|undefined} chromosomeLocation
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           */
          Allele.prototype.chromosomeLocation = null;

          /**
           * Allele sequenceLocation.
           * @member {org.ga4gh.vrs.v1.ISequenceLocation|null|undefined} sequenceLocation
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           */
          Allele.prototype.sequenceLocation = null;

          /**
           * Allele sequenceState.
           * @member {org.ga4gh.vrs.v1.ISequenceState|null|undefined} sequenceState
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           */
          Allele.prototype.sequenceState = null;

          /**
           * Allele literalSequenceExpression.
           * @member {org.ga4gh.vrs.v1.ILiteralSequenceExpression|null|undefined} literalSequenceExpression
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           */
          Allele.prototype.literalSequenceExpression = null;

          /**
           * Allele derivedSequenceExpression.
           * @member {org.ga4gh.vrs.v1.IDerivedSequenceExpression|null|undefined} derivedSequenceExpression
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           */
          Allele.prototype.derivedSequenceExpression = null;

          /**
           * Allele repeatedSequenceExpression.
           * @member {org.ga4gh.vrs.v1.IRepeatedSequenceExpression|null|undefined} repeatedSequenceExpression
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           */
          Allele.prototype.repeatedSequenceExpression = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * Allele location.
           * @member {"curie"|"chromosomeLocation"|"sequenceLocation"|undefined} location
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           */
          Object.defineProperty(Allele.prototype, "location", {
            get: $util.oneOfGetter(
              ($oneOfFields = [
                "curie",
                "chromosomeLocation",
                "sequenceLocation",
              ]),
            ),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Allele state.
           * @member {"sequenceState"|"literalSequenceExpression"|"derivedSequenceExpression"|"repeatedSequenceExpression"|undefined} state
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           */
          Object.defineProperty(Allele.prototype, "state", {
            get: $util.oneOfGetter(
              ($oneOfFields = [
                "sequenceState",
                "literalSequenceExpression",
                "derivedSequenceExpression",
                "repeatedSequenceExpression",
              ]),
            ),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Creates a new Allele instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.Allele
           * @static
           * @param {org.ga4gh.vrs.v1.IAllele=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.Allele} Allele instance
           */
          Allele.create = function create(properties) {
            return new Allele(properties);
          };

          /**
           * Encodes the specified Allele message. Does not implicitly {@link org.ga4gh.vrs.v1.Allele.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.Allele
           * @static
           * @param {org.ga4gh.vrs.v1.IAllele} message Allele message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Allele.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message._id != null &&
              Object.hasOwnProperty.call(message, "_id")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message._id);
            if (
              message.curie != null &&
              Object.hasOwnProperty.call(message, "curie")
            )
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.curie);
            if (
              message.chromosomeLocation != null &&
              Object.hasOwnProperty.call(message, "chromosomeLocation")
            )
              $root.org.ga4gh.vrs.v1.ChromosomeLocation.encode(
                message.chromosomeLocation,
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
            if (
              message.sequenceLocation != null &&
              Object.hasOwnProperty.call(message, "sequenceLocation")
            )
              $root.org.ga4gh.vrs.v1.SequenceLocation.encode(
                message.sequenceLocation,
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
            if (
              message.literalSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "literalSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.encode(
                message.literalSequenceExpression,
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
            if (
              message.derivedSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "derivedSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.encode(
                message.derivedSequenceExpression,
                writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
              ).ldelim();
            if (
              message.repeatedSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "repeatedSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.encode(
                message.repeatedSequenceExpression,
                writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
              ).ldelim();
            if (
              message.sequenceState != null &&
              Object.hasOwnProperty.call(message, "sequenceState")
            )
              $root.org.ga4gh.vrs.v1.SequenceState.encode(
                message.sequenceState,
                writer.uint32(/* id 100, wireType 2 =*/ 802).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified Allele message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.Allele.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.Allele
           * @static
           * @param {org.ga4gh.vrs.v1.IAllele} message Allele message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Allele.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an Allele message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.Allele
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.Allele} Allele
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Allele.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.Allele();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message._id = reader.string();
                  break;
                }
                case 2: {
                  message.curie = reader.string();
                  break;
                }
                case 3: {
                  message.chromosomeLocation =
                    $root.org.ga4gh.vrs.v1.ChromosomeLocation.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 4: {
                  message.sequenceLocation =
                    $root.org.ga4gh.vrs.v1.SequenceLocation.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 100: {
                  message.sequenceState =
                    $root.org.ga4gh.vrs.v1.SequenceState.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 5: {
                  message.literalSequenceExpression =
                    $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 6: {
                  message.derivedSequenceExpression =
                    $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 7: {
                  message.repeatedSequenceExpression =
                    $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an Allele message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.Allele
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.Allele} Allele
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Allele.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an Allele message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.Allele
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Allele.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (message._id != null && message.hasOwnProperty("_id"))
              if (!$util.isString(message._id)) return "_id: string expected";
            if (message.curie != null && message.hasOwnProperty("curie")) {
              properties.location = 1;
              if (!$util.isString(message.curie))
                return "curie: string expected";
            }
            if (
              message.chromosomeLocation != null &&
              message.hasOwnProperty("chromosomeLocation")
            ) {
              if (properties.location === 1) return "location: multiple values";
              properties.location = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.ChromosomeLocation.verify(
                  message.chromosomeLocation,
                );
                if (error) return "chromosomeLocation." + error;
              }
            }
            if (
              message.sequenceLocation != null &&
              message.hasOwnProperty("sequenceLocation")
            ) {
              if (properties.location === 1) return "location: multiple values";
              properties.location = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.SequenceLocation.verify(
                  message.sequenceLocation,
                );
                if (error) return "sequenceLocation." + error;
              }
            }
            if (
              message.sequenceState != null &&
              message.hasOwnProperty("sequenceState")
            ) {
              properties.state = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.SequenceState.verify(
                  message.sequenceState,
                );
                if (error) return "sequenceState." + error;
              }
            }
            if (
              message.literalSequenceExpression != null &&
              message.hasOwnProperty("literalSequenceExpression")
            ) {
              if (properties.state === 1) return "state: multiple values";
              properties.state = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.verify(
                    message.literalSequenceExpression,
                  );
                if (error) return "literalSequenceExpression." + error;
              }
            }
            if (
              message.derivedSequenceExpression != null &&
              message.hasOwnProperty("derivedSequenceExpression")
            ) {
              if (properties.state === 1) return "state: multiple values";
              properties.state = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.verify(
                    message.derivedSequenceExpression,
                  );
                if (error) return "derivedSequenceExpression." + error;
              }
            }
            if (
              message.repeatedSequenceExpression != null &&
              message.hasOwnProperty("repeatedSequenceExpression")
            ) {
              if (properties.state === 1) return "state: multiple values";
              properties.state = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.verify(
                    message.repeatedSequenceExpression,
                  );
                if (error) return "repeatedSequenceExpression." + error;
              }
            }
            return null;
          };

          /**
           * Creates an Allele message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.Allele
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.Allele} Allele
           */
          Allele.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.Allele) return object;
            let message = new $root.org.ga4gh.vrs.v1.Allele();
            if (object._id != null) message._id = String(object._id);
            if (object.curie != null) message.curie = String(object.curie);
            if (object.chromosomeLocation != null) {
              if (typeof object.chromosomeLocation !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Allele.chromosomeLocation: object expected",
                );
              message.chromosomeLocation =
                $root.org.ga4gh.vrs.v1.ChromosomeLocation.fromObject(
                  object.chromosomeLocation,
                );
            }
            if (object.sequenceLocation != null) {
              if (typeof object.sequenceLocation !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Allele.sequenceLocation: object expected",
                );
              message.sequenceLocation =
                $root.org.ga4gh.vrs.v1.SequenceLocation.fromObject(
                  object.sequenceLocation,
                );
            }
            if (object.sequenceState != null) {
              if (typeof object.sequenceState !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Allele.sequenceState: object expected",
                );
              message.sequenceState =
                $root.org.ga4gh.vrs.v1.SequenceState.fromObject(
                  object.sequenceState,
                );
            }
            if (object.literalSequenceExpression != null) {
              if (typeof object.literalSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Allele.literalSequenceExpression: object expected",
                );
              message.literalSequenceExpression =
                $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.fromObject(
                  object.literalSequenceExpression,
                );
            }
            if (object.derivedSequenceExpression != null) {
              if (typeof object.derivedSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Allele.derivedSequenceExpression: object expected",
                );
              message.derivedSequenceExpression =
                $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.fromObject(
                  object.derivedSequenceExpression,
                );
            }
            if (object.repeatedSequenceExpression != null) {
              if (typeof object.repeatedSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Allele.repeatedSequenceExpression: object expected",
                );
              message.repeatedSequenceExpression =
                $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.fromObject(
                  object.repeatedSequenceExpression,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from an Allele message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.Allele
           * @static
           * @param {org.ga4gh.vrs.v1.Allele} message Allele
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Allele.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) object._id = "";
            if (message._id != null && message.hasOwnProperty("_id"))
              object._id = message._id;
            if (message.curie != null && message.hasOwnProperty("curie")) {
              object.curie = message.curie;
              if (options.oneofs) object.location = "curie";
            }
            if (
              message.chromosomeLocation != null &&
              message.hasOwnProperty("chromosomeLocation")
            ) {
              object.chromosomeLocation =
                $root.org.ga4gh.vrs.v1.ChromosomeLocation.toObject(
                  message.chromosomeLocation,
                  options,
                );
              if (options.oneofs) object.location = "chromosomeLocation";
            }
            if (
              message.sequenceLocation != null &&
              message.hasOwnProperty("sequenceLocation")
            ) {
              object.sequenceLocation =
                $root.org.ga4gh.vrs.v1.SequenceLocation.toObject(
                  message.sequenceLocation,
                  options,
                );
              if (options.oneofs) object.location = "sequenceLocation";
            }
            if (
              message.literalSequenceExpression != null &&
              message.hasOwnProperty("literalSequenceExpression")
            ) {
              object.literalSequenceExpression =
                $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.toObject(
                  message.literalSequenceExpression,
                  options,
                );
              if (options.oneofs) object.state = "literalSequenceExpression";
            }
            if (
              message.derivedSequenceExpression != null &&
              message.hasOwnProperty("derivedSequenceExpression")
            ) {
              object.derivedSequenceExpression =
                $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.toObject(
                  message.derivedSequenceExpression,
                  options,
                );
              if (options.oneofs) object.state = "derivedSequenceExpression";
            }
            if (
              message.repeatedSequenceExpression != null &&
              message.hasOwnProperty("repeatedSequenceExpression")
            ) {
              object.repeatedSequenceExpression =
                $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.toObject(
                  message.repeatedSequenceExpression,
                  options,
                );
              if (options.oneofs) object.state = "repeatedSequenceExpression";
            }
            if (
              message.sequenceState != null &&
              message.hasOwnProperty("sequenceState")
            ) {
              object.sequenceState =
                $root.org.ga4gh.vrs.v1.SequenceState.toObject(
                  message.sequenceState,
                  options,
                );
              if (options.oneofs) object.state = "sequenceState";
            }
            return object;
          };

          /**
           * Converts this Allele to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.Allele
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Allele.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Allele
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.Allele
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Allele.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.Allele";
          };

          return Allele;
        })();

        v1.Haplotype = (function () {
          /**
           * Properties of a Haplotype.
           * @memberof org.ga4gh.vrs.v1
           * @interface IHaplotype
           * @property {string|null} [_id] Haplotype _id
           * @property {Array.<org.ga4gh.vrs.v1.Haplotype.IMember>|null} [members] Haplotype members
           */

          /**
           * Constructs a new Haplotype.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a Haplotype.
           * @implements IHaplotype
           * @constructor
           * @param {org.ga4gh.vrs.v1.IHaplotype=} [properties] Properties to set
           */
          function Haplotype(properties) {
            this.members = [];
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Haplotype _id.
           * @member {string} _id
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @instance
           */
          Haplotype.prototype._id = "";

          /**
           * Haplotype members.
           * @member {Array.<org.ga4gh.vrs.v1.Haplotype.IMember>} members
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @instance
           */
          Haplotype.prototype.members = $util.emptyArray;

          /**
           * Creates a new Haplotype instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @static
           * @param {org.ga4gh.vrs.v1.IHaplotype=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.Haplotype} Haplotype instance
           */
          Haplotype.create = function create(properties) {
            return new Haplotype(properties);
          };

          /**
           * Encodes the specified Haplotype message. Does not implicitly {@link org.ga4gh.vrs.v1.Haplotype.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @static
           * @param {org.ga4gh.vrs.v1.IHaplotype} message Haplotype message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Haplotype.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message._id != null &&
              Object.hasOwnProperty.call(message, "_id")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message._id);
            if (message.members != null && message.members.length)
              for (let i = 0; i < message.members.length; ++i)
                $root.org.ga4gh.vrs.v1.Haplotype.Member.encode(
                  message.members[i],
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified Haplotype message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.Haplotype.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @static
           * @param {org.ga4gh.vrs.v1.IHaplotype} message Haplotype message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Haplotype.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Haplotype message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.Haplotype} Haplotype
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Haplotype.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.Haplotype();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message._id = reader.string();
                  break;
                }
                case 2: {
                  if (!(message.members && message.members.length))
                    message.members = [];
                  message.members.push(
                    $root.org.ga4gh.vrs.v1.Haplotype.Member.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Haplotype message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.Haplotype} Haplotype
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Haplotype.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Haplotype message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Haplotype.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message._id != null && message.hasOwnProperty("_id"))
              if (!$util.isString(message._id)) return "_id: string expected";
            if (message.members != null && message.hasOwnProperty("members")) {
              if (!Array.isArray(message.members))
                return "members: array expected";
              for (let i = 0; i < message.members.length; ++i) {
                let error = $root.org.ga4gh.vrs.v1.Haplotype.Member.verify(
                  message.members[i],
                );
                if (error) return "members." + error;
              }
            }
            return null;
          };

          /**
           * Creates a Haplotype message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.Haplotype} Haplotype
           */
          Haplotype.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.Haplotype)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.Haplotype();
            if (object._id != null) message._id = String(object._id);
            if (object.members) {
              if (!Array.isArray(object.members))
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Haplotype.members: array expected",
                );
              message.members = [];
              for (let i = 0; i < object.members.length; ++i) {
                if (typeof object.members[i] !== "object")
                  throw TypeError(
                    ".org.ga4gh.vrs.v1.Haplotype.members: object expected",
                  );
                message.members[i] =
                  $root.org.ga4gh.vrs.v1.Haplotype.Member.fromObject(
                    object.members[i],
                  );
              }
            }
            return message;
          };

          /**
           * Creates a plain object from a Haplotype message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @static
           * @param {org.ga4gh.vrs.v1.Haplotype} message Haplotype
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Haplotype.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.arrays || options.defaults) object.members = [];
            if (options.defaults) object._id = "";
            if (message._id != null && message.hasOwnProperty("_id"))
              object._id = message._id;
            if (message.members && message.members.length) {
              object.members = [];
              for (let j = 0; j < message.members.length; ++j)
                object.members[j] =
                  $root.org.ga4gh.vrs.v1.Haplotype.Member.toObject(
                    message.members[j],
                    options,
                  );
            }
            return object;
          };

          /**
           * Converts this Haplotype to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Haplotype.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Haplotype
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.Haplotype
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Haplotype.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.Haplotype";
          };

          Haplotype.Member = (function () {
            /**
             * Properties of a Member.
             * @memberof org.ga4gh.vrs.v1.Haplotype
             * @interface IMember
             * @property {org.ga4gh.vrs.v1.IAllele|null} [allele] Member allele
             * @property {string|null} [curie] Member curie
             */

            /**
             * Constructs a new Member.
             * @memberof org.ga4gh.vrs.v1.Haplotype
             * @classdesc Represents a Member.
             * @implements IMember
             * @constructor
             * @param {org.ga4gh.vrs.v1.Haplotype.IMember=} [properties] Properties to set
             */
            function Member(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Member allele.
             * @member {org.ga4gh.vrs.v1.IAllele|null|undefined} allele
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @instance
             */
            Member.prototype.allele = null;

            /**
             * Member curie.
             * @member {string|null|undefined} curie
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @instance
             */
            Member.prototype.curie = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Member value.
             * @member {"allele"|"curie"|undefined} value
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @instance
             */
            Object.defineProperty(Member.prototype, "value", {
              get: $util.oneOfGetter(($oneOfFields = ["allele", "curie"])),
              set: $util.oneOfSetter($oneOfFields),
            });

            /**
             * Creates a new Member instance using the specified properties.
             * @function create
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @static
             * @param {org.ga4gh.vrs.v1.Haplotype.IMember=} [properties] Properties to set
             * @returns {org.ga4gh.vrs.v1.Haplotype.Member} Member instance
             */
            Member.create = function create(properties) {
              return new Member(properties);
            };

            /**
             * Encodes the specified Member message. Does not implicitly {@link org.ga4gh.vrs.v1.Haplotype.Member.verify|verify} messages.
             * @function encode
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @static
             * @param {org.ga4gh.vrs.v1.Haplotype.IMember} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Member.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.allele != null &&
                Object.hasOwnProperty.call(message, "allele")
              )
                $root.org.ga4gh.vrs.v1.Allele.encode(
                  message.allele,
                  writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
                ).ldelim();
              if (
                message.curie != null &&
                Object.hasOwnProperty.call(message, "curie")
              )
                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.curie);
              return writer;
            };

            /**
             * Encodes the specified Member message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.Haplotype.Member.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @static
             * @param {org.ga4gh.vrs.v1.Haplotype.IMember} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Member.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Member message from the specified reader or buffer.
             * @function decode
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.ga4gh.vrs.v1.Haplotype.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Member.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.ga4gh.vrs.v1.Haplotype.Member();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.allele = $root.org.ga4gh.vrs.v1.Allele.decode(
                      reader,
                      reader.uint32(),
                    );
                    break;
                  }
                  case 2: {
                    message.curie = reader.string();
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Member message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.ga4gh.vrs.v1.Haplotype.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Member.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Member message.
             * @function verify
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Member.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              let properties = {};
              if (message.allele != null && message.hasOwnProperty("allele")) {
                properties.value = 1;
                {
                  let error = $root.org.ga4gh.vrs.v1.Allele.verify(
                    message.allele,
                  );
                  if (error) return "allele." + error;
                }
              }
              if (message.curie != null && message.hasOwnProperty("curie")) {
                if (properties.value === 1) return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.curie))
                  return "curie: string expected";
              }
              return null;
            };

            /**
             * Creates a Member message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.ga4gh.vrs.v1.Haplotype.Member} Member
             */
            Member.fromObject = function fromObject(object) {
              if (object instanceof $root.org.ga4gh.vrs.v1.Haplotype.Member)
                return object;
              let message = new $root.org.ga4gh.vrs.v1.Haplotype.Member();
              if (object.allele != null) {
                if (typeof object.allele !== "object")
                  throw TypeError(
                    ".org.ga4gh.vrs.v1.Haplotype.Member.allele: object expected",
                  );
                message.allele = $root.org.ga4gh.vrs.v1.Allele.fromObject(
                  object.allele,
                );
              }
              if (object.curie != null) message.curie = String(object.curie);
              return message;
            };

            /**
             * Creates a plain object from a Member message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @static
             * @param {org.ga4gh.vrs.v1.Haplotype.Member} message Member
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Member.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (message.allele != null && message.hasOwnProperty("allele")) {
                object.allele = $root.org.ga4gh.vrs.v1.Allele.toObject(
                  message.allele,
                  options,
                );
                if (options.oneofs) object.value = "allele";
              }
              if (message.curie != null && message.hasOwnProperty("curie")) {
                object.curie = message.curie;
                if (options.oneofs) object.value = "curie";
              }
              return object;
            };

            /**
             * Converts this Member to JSON.
             * @function toJSON
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Member.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Member
             * @function getTypeUrl
             * @memberof org.ga4gh.vrs.v1.Haplotype.Member
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Member.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/org.ga4gh.vrs.v1.Haplotype.Member";
            };

            return Member;
          })();

          return Haplotype;
        })();

        v1.Text = (function () {
          /**
           * Properties of a Text.
           * @memberof org.ga4gh.vrs.v1
           * @interface IText
           * @property {string|null} [_id] Text _id
           * @property {string|null} [definition] Text definition
           */

          /**
           * Constructs a new Text.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a Text.
           * @implements IText
           * @constructor
           * @param {org.ga4gh.vrs.v1.IText=} [properties] Properties to set
           */
          function Text(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Text _id.
           * @member {string} _id
           * @memberof org.ga4gh.vrs.v1.Text
           * @instance
           */
          Text.prototype._id = "";

          /**
           * Text definition.
           * @member {string} definition
           * @memberof org.ga4gh.vrs.v1.Text
           * @instance
           */
          Text.prototype.definition = "";

          /**
           * Creates a new Text instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.Text
           * @static
           * @param {org.ga4gh.vrs.v1.IText=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.Text} Text instance
           */
          Text.create = function create(properties) {
            return new Text(properties);
          };

          /**
           * Encodes the specified Text message. Does not implicitly {@link org.ga4gh.vrs.v1.Text.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.Text
           * @static
           * @param {org.ga4gh.vrs.v1.IText} message Text message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Text.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message._id != null &&
              Object.hasOwnProperty.call(message, "_id")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message._id);
            if (
              message.definition != null &&
              Object.hasOwnProperty.call(message, "definition")
            )
              writer
                .uint32(/* id 2, wireType 2 =*/ 18)
                .string(message.definition);
            return writer;
          };

          /**
           * Encodes the specified Text message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.Text.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.Text
           * @static
           * @param {org.ga4gh.vrs.v1.IText} message Text message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Text.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Text message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.Text
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.Text} Text
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Text.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.Text();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message._id = reader.string();
                  break;
                }
                case 2: {
                  message.definition = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Text message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.Text
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.Text} Text
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Text.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Text message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.Text
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Text.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message._id != null && message.hasOwnProperty("_id"))
              if (!$util.isString(message._id)) return "_id: string expected";
            if (
              message.definition != null &&
              message.hasOwnProperty("definition")
            )
              if (!$util.isString(message.definition))
                return "definition: string expected";
            return null;
          };

          /**
           * Creates a Text message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.Text
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.Text} Text
           */
          Text.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.Text) return object;
            let message = new $root.org.ga4gh.vrs.v1.Text();
            if (object._id != null) message._id = String(object._id);
            if (object.definition != null)
              message.definition = String(object.definition);
            return message;
          };

          /**
           * Creates a plain object from a Text message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.Text
           * @static
           * @param {org.ga4gh.vrs.v1.Text} message Text
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Text.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              object._id = "";
              object.definition = "";
            }
            if (message._id != null && message.hasOwnProperty("_id"))
              object._id = message._id;
            if (
              message.definition != null &&
              message.hasOwnProperty("definition")
            )
              object.definition = message.definition;
            return object;
          };

          /**
           * Converts this Text to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.Text
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Text.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Text
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.Text
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Text.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.Text";
          };

          return Text;
        })();

        v1.VariationSet = (function () {
          /**
           * Properties of a VariationSet.
           * @memberof org.ga4gh.vrs.v1
           * @interface IVariationSet
           * @property {string|null} [_id] VariationSet _id
           * @property {Array.<org.ga4gh.vrs.v1.VariationSet.IMember>|null} [members] VariationSet members
           */

          /**
           * Constructs a new VariationSet.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a VariationSet.
           * @implements IVariationSet
           * @constructor
           * @param {org.ga4gh.vrs.v1.IVariationSet=} [properties] Properties to set
           */
          function VariationSet(properties) {
            this.members = [];
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * VariationSet _id.
           * @member {string} _id
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @instance
           */
          VariationSet.prototype._id = "";

          /**
           * VariationSet members.
           * @member {Array.<org.ga4gh.vrs.v1.VariationSet.IMember>} members
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @instance
           */
          VariationSet.prototype.members = $util.emptyArray;

          /**
           * Creates a new VariationSet instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @static
           * @param {org.ga4gh.vrs.v1.IVariationSet=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.VariationSet} VariationSet instance
           */
          VariationSet.create = function create(properties) {
            return new VariationSet(properties);
          };

          /**
           * Encodes the specified VariationSet message. Does not implicitly {@link org.ga4gh.vrs.v1.VariationSet.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @static
           * @param {org.ga4gh.vrs.v1.IVariationSet} message VariationSet message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          VariationSet.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message._id != null &&
              Object.hasOwnProperty.call(message, "_id")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message._id);
            if (message.members != null && message.members.length)
              for (let i = 0; i < message.members.length; ++i)
                $root.org.ga4gh.vrs.v1.VariationSet.Member.encode(
                  message.members[i],
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified VariationSet message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.VariationSet.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @static
           * @param {org.ga4gh.vrs.v1.IVariationSet} message VariationSet message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          VariationSet.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a VariationSet message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.VariationSet} VariationSet
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          VariationSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.VariationSet();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message._id = reader.string();
                  break;
                }
                case 2: {
                  if (!(message.members && message.members.length))
                    message.members = [];
                  message.members.push(
                    $root.org.ga4gh.vrs.v1.VariationSet.Member.decode(
                      reader,
                      reader.uint32(),
                    ),
                  );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a VariationSet message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.VariationSet} VariationSet
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          VariationSet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a VariationSet message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          VariationSet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message._id != null && message.hasOwnProperty("_id"))
              if (!$util.isString(message._id)) return "_id: string expected";
            if (message.members != null && message.hasOwnProperty("members")) {
              if (!Array.isArray(message.members))
                return "members: array expected";
              for (let i = 0; i < message.members.length; ++i) {
                let error = $root.org.ga4gh.vrs.v1.VariationSet.Member.verify(
                  message.members[i],
                );
                if (error) return "members." + error;
              }
            }
            return null;
          };

          /**
           * Creates a VariationSet message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.VariationSet} VariationSet
           */
          VariationSet.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.VariationSet)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.VariationSet();
            if (object._id != null) message._id = String(object._id);
            if (object.members) {
              if (!Array.isArray(object.members))
                throw TypeError(
                  ".org.ga4gh.vrs.v1.VariationSet.members: array expected",
                );
              message.members = [];
              for (let i = 0; i < object.members.length; ++i) {
                if (typeof object.members[i] !== "object")
                  throw TypeError(
                    ".org.ga4gh.vrs.v1.VariationSet.members: object expected",
                  );
                message.members[i] =
                  $root.org.ga4gh.vrs.v1.VariationSet.Member.fromObject(
                    object.members[i],
                  );
              }
            }
            return message;
          };

          /**
           * Creates a plain object from a VariationSet message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @static
           * @param {org.ga4gh.vrs.v1.VariationSet} message VariationSet
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          VariationSet.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.arrays || options.defaults) object.members = [];
            if (options.defaults) object._id = "";
            if (message._id != null && message.hasOwnProperty("_id"))
              object._id = message._id;
            if (message.members && message.members.length) {
              object.members = [];
              for (let j = 0; j < message.members.length; ++j)
                object.members[j] =
                  $root.org.ga4gh.vrs.v1.VariationSet.Member.toObject(
                    message.members[j],
                    options,
                  );
            }
            return object;
          };

          /**
           * Converts this VariationSet to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          VariationSet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for VariationSet
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.VariationSet
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          VariationSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.VariationSet";
          };

          VariationSet.Member = (function () {
            /**
             * Properties of a Member.
             * @memberof org.ga4gh.vrs.v1.VariationSet
             * @interface IMember
             * @property {string|null} [curie] Member curie
             * @property {org.ga4gh.vrs.v1.IAllele|null} [allele] Member allele
             * @property {org.ga4gh.vrs.v1.IHaplotype|null} [haplotype] Member haplotype
             * @property {org.ga4gh.vrs.v1.ICopyNumber|null} [copyNumber] Member copyNumber
             * @property {org.ga4gh.vrs.v1.IText|null} [text] Member text
             * @property {org.ga4gh.vrs.v1.IVariationSet|null} [variationSet] Member variationSet
             */

            /**
             * Constructs a new Member.
             * @memberof org.ga4gh.vrs.v1.VariationSet
             * @classdesc Represents a Member.
             * @implements IMember
             * @constructor
             * @param {org.ga4gh.vrs.v1.VariationSet.IMember=} [properties] Properties to set
             */
            function Member(properties) {
              if (properties)
                for (
                  let keys = Object.keys(properties), i = 0;
                  i < keys.length;
                  ++i
                )
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
            }

            /**
             * Member curie.
             * @member {string|null|undefined} curie
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @instance
             */
            Member.prototype.curie = null;

            /**
             * Member allele.
             * @member {org.ga4gh.vrs.v1.IAllele|null|undefined} allele
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @instance
             */
            Member.prototype.allele = null;

            /**
             * Member haplotype.
             * @member {org.ga4gh.vrs.v1.IHaplotype|null|undefined} haplotype
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @instance
             */
            Member.prototype.haplotype = null;

            /**
             * Member copyNumber.
             * @member {org.ga4gh.vrs.v1.ICopyNumber|null|undefined} copyNumber
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @instance
             */
            Member.prototype.copyNumber = null;

            /**
             * Member text.
             * @member {org.ga4gh.vrs.v1.IText|null|undefined} text
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @instance
             */
            Member.prototype.text = null;

            /**
             * Member variationSet.
             * @member {org.ga4gh.vrs.v1.IVariationSet|null|undefined} variationSet
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @instance
             */
            Member.prototype.variationSet = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Member value.
             * @member {"curie"|"allele"|"haplotype"|"copyNumber"|"text"|"variationSet"|undefined} value
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @instance
             */
            Object.defineProperty(Member.prototype, "value", {
              get: $util.oneOfGetter(
                ($oneOfFields = [
                  "curie",
                  "allele",
                  "haplotype",
                  "copyNumber",
                  "text",
                  "variationSet",
                ]),
              ),
              set: $util.oneOfSetter($oneOfFields),
            });

            /**
             * Creates a new Member instance using the specified properties.
             * @function create
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @static
             * @param {org.ga4gh.vrs.v1.VariationSet.IMember=} [properties] Properties to set
             * @returns {org.ga4gh.vrs.v1.VariationSet.Member} Member instance
             */
            Member.create = function create(properties) {
              return new Member(properties);
            };

            /**
             * Encodes the specified Member message. Does not implicitly {@link org.ga4gh.vrs.v1.VariationSet.Member.verify|verify} messages.
             * @function encode
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @static
             * @param {org.ga4gh.vrs.v1.VariationSet.IMember} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Member.encode = function encode(message, writer) {
              if (!writer) writer = $Writer.create();
              if (
                message.curie != null &&
                Object.hasOwnProperty.call(message, "curie")
              )
                writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.curie);
              if (
                message.allele != null &&
                Object.hasOwnProperty.call(message, "allele")
              )
                $root.org.ga4gh.vrs.v1.Allele.encode(
                  message.allele,
                  writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
                ).ldelim();
              if (
                message.haplotype != null &&
                Object.hasOwnProperty.call(message, "haplotype")
              )
                $root.org.ga4gh.vrs.v1.Haplotype.encode(
                  message.haplotype,
                  writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
                ).ldelim();
              if (
                message.copyNumber != null &&
                Object.hasOwnProperty.call(message, "copyNumber")
              )
                $root.org.ga4gh.vrs.v1.CopyNumber.encode(
                  message.copyNumber,
                  writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
                ).ldelim();
              if (
                message.text != null &&
                Object.hasOwnProperty.call(message, "text")
              )
                $root.org.ga4gh.vrs.v1.Text.encode(
                  message.text,
                  writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
                ).ldelim();
              if (
                message.variationSet != null &&
                Object.hasOwnProperty.call(message, "variationSet")
              )
                $root.org.ga4gh.vrs.v1.VariationSet.encode(
                  message.variationSet,
                  writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
                ).ldelim();
              return writer;
            };

            /**
             * Encodes the specified Member message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.VariationSet.Member.verify|verify} messages.
             * @function encodeDelimited
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @static
             * @param {org.ga4gh.vrs.v1.VariationSet.IMember} message Member message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Member.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Member message from the specified reader or buffer.
             * @function decode
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {org.ga4gh.vrs.v1.VariationSet.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Member.decode = function decode(reader, length) {
              if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
              let end = length === undefined ? reader.len : reader.pos + length,
                message = new $root.org.ga4gh.vrs.v1.VariationSet.Member();
              while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1: {
                    message.curie = reader.string();
                    break;
                  }
                  case 2: {
                    message.allele = $root.org.ga4gh.vrs.v1.Allele.decode(
                      reader,
                      reader.uint32(),
                    );
                    break;
                  }
                  case 3: {
                    message.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.decode(
                      reader,
                      reader.uint32(),
                    );
                    break;
                  }
                  case 4: {
                    message.copyNumber =
                      $root.org.ga4gh.vrs.v1.CopyNumber.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  case 5: {
                    message.text = $root.org.ga4gh.vrs.v1.Text.decode(
                      reader,
                      reader.uint32(),
                    );
                    break;
                  }
                  case 6: {
                    message.variationSet =
                      $root.org.ga4gh.vrs.v1.VariationSet.decode(
                        reader,
                        reader.uint32(),
                      );
                    break;
                  }
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };

            /**
             * Decodes a Member message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {org.ga4gh.vrs.v1.VariationSet.Member} Member
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Member.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader)) reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Member message.
             * @function verify
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Member.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              let properties = {};
              if (message.curie != null && message.hasOwnProperty("curie")) {
                properties.value = 1;
                if (!$util.isString(message.curie))
                  return "curie: string expected";
              }
              if (message.allele != null && message.hasOwnProperty("allele")) {
                if (properties.value === 1) return "value: multiple values";
                properties.value = 1;
                {
                  let error = $root.org.ga4gh.vrs.v1.Allele.verify(
                    message.allele,
                  );
                  if (error) return "allele." + error;
                }
              }
              if (
                message.haplotype != null &&
                message.hasOwnProperty("haplotype")
              ) {
                if (properties.value === 1) return "value: multiple values";
                properties.value = 1;
                {
                  let error = $root.org.ga4gh.vrs.v1.Haplotype.verify(
                    message.haplotype,
                  );
                  if (error) return "haplotype." + error;
                }
              }
              if (
                message.copyNumber != null &&
                message.hasOwnProperty("copyNumber")
              ) {
                if (properties.value === 1) return "value: multiple values";
                properties.value = 1;
                {
                  let error = $root.org.ga4gh.vrs.v1.CopyNumber.verify(
                    message.copyNumber,
                  );
                  if (error) return "copyNumber." + error;
                }
              }
              if (message.text != null && message.hasOwnProperty("text")) {
                if (properties.value === 1) return "value: multiple values";
                properties.value = 1;
                {
                  let error = $root.org.ga4gh.vrs.v1.Text.verify(message.text);
                  if (error) return "text." + error;
                }
              }
              if (
                message.variationSet != null &&
                message.hasOwnProperty("variationSet")
              ) {
                if (properties.value === 1) return "value: multiple values";
                properties.value = 1;
                {
                  let error = $root.org.ga4gh.vrs.v1.VariationSet.verify(
                    message.variationSet,
                  );
                  if (error) return "variationSet." + error;
                }
              }
              return null;
            };

            /**
             * Creates a Member message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {org.ga4gh.vrs.v1.VariationSet.Member} Member
             */
            Member.fromObject = function fromObject(object) {
              if (object instanceof $root.org.ga4gh.vrs.v1.VariationSet.Member)
                return object;
              let message = new $root.org.ga4gh.vrs.v1.VariationSet.Member();
              if (object.curie != null) message.curie = String(object.curie);
              if (object.allele != null) {
                if (typeof object.allele !== "object")
                  throw TypeError(
                    ".org.ga4gh.vrs.v1.VariationSet.Member.allele: object expected",
                  );
                message.allele = $root.org.ga4gh.vrs.v1.Allele.fromObject(
                  object.allele,
                );
              }
              if (object.haplotype != null) {
                if (typeof object.haplotype !== "object")
                  throw TypeError(
                    ".org.ga4gh.vrs.v1.VariationSet.Member.haplotype: object expected",
                  );
                message.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.fromObject(
                  object.haplotype,
                );
              }
              if (object.copyNumber != null) {
                if (typeof object.copyNumber !== "object")
                  throw TypeError(
                    ".org.ga4gh.vrs.v1.VariationSet.Member.copyNumber: object expected",
                  );
                message.copyNumber =
                  $root.org.ga4gh.vrs.v1.CopyNumber.fromObject(
                    object.copyNumber,
                  );
              }
              if (object.text != null) {
                if (typeof object.text !== "object")
                  throw TypeError(
                    ".org.ga4gh.vrs.v1.VariationSet.Member.text: object expected",
                  );
                message.text = $root.org.ga4gh.vrs.v1.Text.fromObject(
                  object.text,
                );
              }
              if (object.variationSet != null) {
                if (typeof object.variationSet !== "object")
                  throw TypeError(
                    ".org.ga4gh.vrs.v1.VariationSet.Member.variationSet: object expected",
                  );
                message.variationSet =
                  $root.org.ga4gh.vrs.v1.VariationSet.fromObject(
                    object.variationSet,
                  );
              }
              return message;
            };

            /**
             * Creates a plain object from a Member message. Also converts values to other types if specified.
             * @function toObject
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @static
             * @param {org.ga4gh.vrs.v1.VariationSet.Member} message Member
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Member.toObject = function toObject(message, options) {
              if (!options) options = {};
              let object = {};
              if (message.curie != null && message.hasOwnProperty("curie")) {
                object.curie = message.curie;
                if (options.oneofs) object.value = "curie";
              }
              if (message.allele != null && message.hasOwnProperty("allele")) {
                object.allele = $root.org.ga4gh.vrs.v1.Allele.toObject(
                  message.allele,
                  options,
                );
                if (options.oneofs) object.value = "allele";
              }
              if (
                message.haplotype != null &&
                message.hasOwnProperty("haplotype")
              ) {
                object.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.toObject(
                  message.haplotype,
                  options,
                );
                if (options.oneofs) object.value = "haplotype";
              }
              if (
                message.copyNumber != null &&
                message.hasOwnProperty("copyNumber")
              ) {
                object.copyNumber = $root.org.ga4gh.vrs.v1.CopyNumber.toObject(
                  message.copyNumber,
                  options,
                );
                if (options.oneofs) object.value = "copyNumber";
              }
              if (message.text != null && message.hasOwnProperty("text")) {
                object.text = $root.org.ga4gh.vrs.v1.Text.toObject(
                  message.text,
                  options,
                );
                if (options.oneofs) object.value = "text";
              }
              if (
                message.variationSet != null &&
                message.hasOwnProperty("variationSet")
              ) {
                object.variationSet =
                  $root.org.ga4gh.vrs.v1.VariationSet.toObject(
                    message.variationSet,
                    options,
                  );
                if (options.oneofs) object.value = "variationSet";
              }
              return object;
            };

            /**
             * Converts this Member to JSON.
             * @function toJSON
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Member.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(
                this,
                $protobuf.util.toJSONOptions,
              );
            };

            /**
             * Gets the default type url for Member
             * @function getTypeUrl
             * @memberof org.ga4gh.vrs.v1.VariationSet.Member
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Member.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
              if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
              }
              return typeUrlPrefix + "/org.ga4gh.vrs.v1.VariationSet.Member";
            };

            return Member;
          })();

          return VariationSet;
        })();

        v1.Abundance = (function () {
          /**
           * Properties of an Abundance.
           * @memberof org.ga4gh.vrs.v1
           * @interface IAbundance
           * @property {org.ga4gh.vrs.v1.ICopyNumber|null} [copyNumber] Abundance copyNumber
           */

          /**
           * Constructs a new Abundance.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents an Abundance.
           * @implements IAbundance
           * @constructor
           * @param {org.ga4gh.vrs.v1.IAbundance=} [properties] Properties to set
           */
          function Abundance(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Abundance copyNumber.
           * @member {org.ga4gh.vrs.v1.ICopyNumber|null|undefined} copyNumber
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @instance
           */
          Abundance.prototype.copyNumber = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * Abundance abundance.
           * @member {"copyNumber"|undefined} abundance
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @instance
           */
          Object.defineProperty(Abundance.prototype, "abundance", {
            get: $util.oneOfGetter(($oneOfFields = ["copyNumber"])),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Creates a new Abundance instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @static
           * @param {org.ga4gh.vrs.v1.IAbundance=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.Abundance} Abundance instance
           */
          Abundance.create = function create(properties) {
            return new Abundance(properties);
          };

          /**
           * Encodes the specified Abundance message. Does not implicitly {@link org.ga4gh.vrs.v1.Abundance.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @static
           * @param {org.ga4gh.vrs.v1.IAbundance} message Abundance message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Abundance.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.copyNumber != null &&
              Object.hasOwnProperty.call(message, "copyNumber")
            )
              $root.org.ga4gh.vrs.v1.CopyNumber.encode(
                message.copyNumber,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified Abundance message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.Abundance.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @static
           * @param {org.ga4gh.vrs.v1.IAbundance} message Abundance message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Abundance.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an Abundance message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.Abundance} Abundance
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Abundance.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.Abundance();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.copyNumber = $root.org.ga4gh.vrs.v1.CopyNumber.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an Abundance message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.Abundance} Abundance
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Abundance.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an Abundance message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Abundance.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (
              message.copyNumber != null &&
              message.hasOwnProperty("copyNumber")
            ) {
              properties.abundance = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.CopyNumber.verify(
                  message.copyNumber,
                );
                if (error) return "copyNumber." + error;
              }
            }
            return null;
          };

          /**
           * Creates an Abundance message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.Abundance} Abundance
           */
          Abundance.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.Abundance)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.Abundance();
            if (object.copyNumber != null) {
              if (typeof object.copyNumber !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Abundance.copyNumber: object expected",
                );
              message.copyNumber = $root.org.ga4gh.vrs.v1.CopyNumber.fromObject(
                object.copyNumber,
              );
            }
            return message;
          };

          /**
           * Creates a plain object from an Abundance message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @static
           * @param {org.ga4gh.vrs.v1.Abundance} message Abundance
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Abundance.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (
              message.copyNumber != null &&
              message.hasOwnProperty("copyNumber")
            ) {
              object.copyNumber = $root.org.ga4gh.vrs.v1.CopyNumber.toObject(
                message.copyNumber,
                options,
              );
              if (options.oneofs) object.abundance = "copyNumber";
            }
            return object;
          };

          /**
           * Converts this Abundance to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Abundance.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Abundance
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.Abundance
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Abundance.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.Abundance";
          };

          return Abundance;
        })();

        v1.CopyNumber = (function () {
          /**
           * Properties of a CopyNumber.
           * @memberof org.ga4gh.vrs.v1
           * @interface ICopyNumber
           * @property {string|null} [_id] CopyNumber _id
           * @property {org.ga4gh.vrs.v1.IAllele|null} [allele] CopyNumber allele
           * @property {org.ga4gh.vrs.v1.IHaplotype|null} [haplotype] CopyNumber haplotype
           * @property {org.ga4gh.vrs.v1.IGene|null} [gene] CopyNumber gene
           * @property {org.ga4gh.vrs.v1.ILiteralSequenceExpression|null} [literalSequenceExpression] CopyNumber literalSequenceExpression
           * @property {org.ga4gh.vrs.v1.IDerivedSequenceExpression|null} [derivedSequenceExpression] CopyNumber derivedSequenceExpression
           * @property {org.ga4gh.vrs.v1.IRepeatedSequenceExpression|null} [repeatedSequenceExpression] CopyNumber repeatedSequenceExpression
           * @property {string|null} [curie] CopyNumber curie
           * @property {org.ga4gh.vrs.v1.INumber|null} [number] CopyNumber number
           * @property {org.ga4gh.vrs.v1.IIndefiniteRange|null} [indefiniteRange] CopyNumber indefiniteRange
           * @property {org.ga4gh.vrs.v1.IDefiniteRange|null} [definiteRange] CopyNumber definiteRange
           */

          /**
           * Constructs a new CopyNumber.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a CopyNumber.
           * @implements ICopyNumber
           * @constructor
           * @param {org.ga4gh.vrs.v1.ICopyNumber=} [properties] Properties to set
           */
          function CopyNumber(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * CopyNumber _id.
           * @member {string} _id
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype._id = "";

          /**
           * CopyNumber allele.
           * @member {org.ga4gh.vrs.v1.IAllele|null|undefined} allele
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype.allele = null;

          /**
           * CopyNumber haplotype.
           * @member {org.ga4gh.vrs.v1.IHaplotype|null|undefined} haplotype
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype.haplotype = null;

          /**
           * CopyNumber gene.
           * @member {org.ga4gh.vrs.v1.IGene|null|undefined} gene
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype.gene = null;

          /**
           * CopyNumber literalSequenceExpression.
           * @member {org.ga4gh.vrs.v1.ILiteralSequenceExpression|null|undefined} literalSequenceExpression
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype.literalSequenceExpression = null;

          /**
           * CopyNumber derivedSequenceExpression.
           * @member {org.ga4gh.vrs.v1.IDerivedSequenceExpression|null|undefined} derivedSequenceExpression
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype.derivedSequenceExpression = null;

          /**
           * CopyNumber repeatedSequenceExpression.
           * @member {org.ga4gh.vrs.v1.IRepeatedSequenceExpression|null|undefined} repeatedSequenceExpression
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype.repeatedSequenceExpression = null;

          /**
           * CopyNumber curie.
           * @member {string|null|undefined} curie
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype.curie = null;

          /**
           * CopyNumber number.
           * @member {org.ga4gh.vrs.v1.INumber|null|undefined} number
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype.number = null;

          /**
           * CopyNumber indefiniteRange.
           * @member {org.ga4gh.vrs.v1.IIndefiniteRange|null|undefined} indefiniteRange
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype.indefiniteRange = null;

          /**
           * CopyNumber definiteRange.
           * @member {org.ga4gh.vrs.v1.IDefiniteRange|null|undefined} definiteRange
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          CopyNumber.prototype.definiteRange = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * CopyNumber subject.
           * @member {"allele"|"haplotype"|"gene"|"literalSequenceExpression"|"derivedSequenceExpression"|"repeatedSequenceExpression"|"curie"|undefined} subject
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          Object.defineProperty(CopyNumber.prototype, "subject", {
            get: $util.oneOfGetter(
              ($oneOfFields = [
                "allele",
                "haplotype",
                "gene",
                "literalSequenceExpression",
                "derivedSequenceExpression",
                "repeatedSequenceExpression",
                "curie",
              ]),
            ),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * CopyNumber copies.
           * @member {"number"|"indefiniteRange"|"definiteRange"|undefined} copies
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           */
          Object.defineProperty(CopyNumber.prototype, "copies", {
            get: $util.oneOfGetter(
              ($oneOfFields = ["number", "indefiniteRange", "definiteRange"]),
            ),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Creates a new CopyNumber instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @static
           * @param {org.ga4gh.vrs.v1.ICopyNumber=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.CopyNumber} CopyNumber instance
           */
          CopyNumber.create = function create(properties) {
            return new CopyNumber(properties);
          };

          /**
           * Encodes the specified CopyNumber message. Does not implicitly {@link org.ga4gh.vrs.v1.CopyNumber.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @static
           * @param {org.ga4gh.vrs.v1.ICopyNumber} message CopyNumber message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          CopyNumber.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message._id != null &&
              Object.hasOwnProperty.call(message, "_id")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message._id);
            if (
              message.allele != null &&
              Object.hasOwnProperty.call(message, "allele")
            )
              $root.org.ga4gh.vrs.v1.Allele.encode(
                message.allele,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            if (
              message.haplotype != null &&
              Object.hasOwnProperty.call(message, "haplotype")
            )
              $root.org.ga4gh.vrs.v1.Haplotype.encode(
                message.haplotype,
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
            if (
              message.gene != null &&
              Object.hasOwnProperty.call(message, "gene")
            )
              $root.org.ga4gh.vrs.v1.Gene.encode(
                message.gene,
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
            if (
              message.literalSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "literalSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.encode(
                message.literalSequenceExpression,
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
            if (
              message.derivedSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "derivedSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.encode(
                message.derivedSequenceExpression,
                writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
              ).ldelim();
            if (
              message.repeatedSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "repeatedSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.encode(
                message.repeatedSequenceExpression,
                writer.uint32(/* id 7, wireType 2 =*/ 58).fork(),
              ).ldelim();
            if (
              message.curie != null &&
              Object.hasOwnProperty.call(message, "curie")
            )
              writer.uint32(/* id 8, wireType 2 =*/ 66).string(message.curie);
            if (
              message.number != null &&
              Object.hasOwnProperty.call(message, "number")
            )
              $root.org.ga4gh.vrs.v1.Number.encode(
                message.number,
                writer.uint32(/* id 9, wireType 2 =*/ 74).fork(),
              ).ldelim();
            if (
              message.indefiniteRange != null &&
              Object.hasOwnProperty.call(message, "indefiniteRange")
            )
              $root.org.ga4gh.vrs.v1.IndefiniteRange.encode(
                message.indefiniteRange,
                writer.uint32(/* id 10, wireType 2 =*/ 82).fork(),
              ).ldelim();
            if (
              message.definiteRange != null &&
              Object.hasOwnProperty.call(message, "definiteRange")
            )
              $root.org.ga4gh.vrs.v1.DefiniteRange.encode(
                message.definiteRange,
                writer.uint32(/* id 11, wireType 2 =*/ 90).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified CopyNumber message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.CopyNumber.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @static
           * @param {org.ga4gh.vrs.v1.ICopyNumber} message CopyNumber message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          CopyNumber.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a CopyNumber message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.CopyNumber} CopyNumber
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          CopyNumber.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.CopyNumber();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message._id = reader.string();
                  break;
                }
                case 2: {
                  message.allele = $root.org.ga4gh.vrs.v1.Allele.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 3: {
                  message.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 4: {
                  message.gene = $root.org.ga4gh.vrs.v1.Gene.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 5: {
                  message.literalSequenceExpression =
                    $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 6: {
                  message.derivedSequenceExpression =
                    $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 7: {
                  message.repeatedSequenceExpression =
                    $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 8: {
                  message.curie = reader.string();
                  break;
                }
                case 9: {
                  message.number = $root.org.ga4gh.vrs.v1.Number.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 10: {
                  message.indefiniteRange =
                    $root.org.ga4gh.vrs.v1.IndefiniteRange.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 11: {
                  message.definiteRange =
                    $root.org.ga4gh.vrs.v1.DefiniteRange.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a CopyNumber message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.CopyNumber} CopyNumber
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          CopyNumber.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a CopyNumber message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          CopyNumber.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (message._id != null && message.hasOwnProperty("_id"))
              if (!$util.isString(message._id)) return "_id: string expected";
            if (message.allele != null && message.hasOwnProperty("allele")) {
              properties.subject = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Allele.verify(
                  message.allele,
                );
                if (error) return "allele." + error;
              }
            }
            if (
              message.haplotype != null &&
              message.hasOwnProperty("haplotype")
            ) {
              if (properties.subject === 1) return "subject: multiple values";
              properties.subject = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Haplotype.verify(
                  message.haplotype,
                );
                if (error) return "haplotype." + error;
              }
            }
            if (message.gene != null && message.hasOwnProperty("gene")) {
              if (properties.subject === 1) return "subject: multiple values";
              properties.subject = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Gene.verify(message.gene);
                if (error) return "gene." + error;
              }
            }
            if (
              message.literalSequenceExpression != null &&
              message.hasOwnProperty("literalSequenceExpression")
            ) {
              if (properties.subject === 1) return "subject: multiple values";
              properties.subject = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.verify(
                    message.literalSequenceExpression,
                  );
                if (error) return "literalSequenceExpression." + error;
              }
            }
            if (
              message.derivedSequenceExpression != null &&
              message.hasOwnProperty("derivedSequenceExpression")
            ) {
              if (properties.subject === 1) return "subject: multiple values";
              properties.subject = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.verify(
                    message.derivedSequenceExpression,
                  );
                if (error) return "derivedSequenceExpression." + error;
              }
            }
            if (
              message.repeatedSequenceExpression != null &&
              message.hasOwnProperty("repeatedSequenceExpression")
            ) {
              if (properties.subject === 1) return "subject: multiple values";
              properties.subject = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.verify(
                    message.repeatedSequenceExpression,
                  );
                if (error) return "repeatedSequenceExpression." + error;
              }
            }
            if (message.curie != null && message.hasOwnProperty("curie")) {
              if (properties.subject === 1) return "subject: multiple values";
              properties.subject = 1;
              if (!$util.isString(message.curie))
                return "curie: string expected";
            }
            if (message.number != null && message.hasOwnProperty("number")) {
              properties.copies = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Number.verify(
                  message.number,
                );
                if (error) return "number." + error;
              }
            }
            if (
              message.indefiniteRange != null &&
              message.hasOwnProperty("indefiniteRange")
            ) {
              if (properties.copies === 1) return "copies: multiple values";
              properties.copies = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.IndefiniteRange.verify(
                  message.indefiniteRange,
                );
                if (error) return "indefiniteRange." + error;
              }
            }
            if (
              message.definiteRange != null &&
              message.hasOwnProperty("definiteRange")
            ) {
              if (properties.copies === 1) return "copies: multiple values";
              properties.copies = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.DefiniteRange.verify(
                  message.definiteRange,
                );
                if (error) return "definiteRange." + error;
              }
            }
            return null;
          };

          /**
           * Creates a CopyNumber message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.CopyNumber} CopyNumber
           */
          CopyNumber.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.CopyNumber)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.CopyNumber();
            if (object._id != null) message._id = String(object._id);
            if (object.allele != null) {
              if (typeof object.allele !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.CopyNumber.allele: object expected",
                );
              message.allele = $root.org.ga4gh.vrs.v1.Allele.fromObject(
                object.allele,
              );
            }
            if (object.haplotype != null) {
              if (typeof object.haplotype !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.CopyNumber.haplotype: object expected",
                );
              message.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.fromObject(
                object.haplotype,
              );
            }
            if (object.gene != null) {
              if (typeof object.gene !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.CopyNumber.gene: object expected",
                );
              message.gene = $root.org.ga4gh.vrs.v1.Gene.fromObject(
                object.gene,
              );
            }
            if (object.literalSequenceExpression != null) {
              if (typeof object.literalSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.CopyNumber.literalSequenceExpression: object expected",
                );
              message.literalSequenceExpression =
                $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.fromObject(
                  object.literalSequenceExpression,
                );
            }
            if (object.derivedSequenceExpression != null) {
              if (typeof object.derivedSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.CopyNumber.derivedSequenceExpression: object expected",
                );
              message.derivedSequenceExpression =
                $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.fromObject(
                  object.derivedSequenceExpression,
                );
            }
            if (object.repeatedSequenceExpression != null) {
              if (typeof object.repeatedSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.CopyNumber.repeatedSequenceExpression: object expected",
                );
              message.repeatedSequenceExpression =
                $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.fromObject(
                  object.repeatedSequenceExpression,
                );
            }
            if (object.curie != null) message.curie = String(object.curie);
            if (object.number != null) {
              if (typeof object.number !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.CopyNumber.number: object expected",
                );
              message.number = $root.org.ga4gh.vrs.v1.Number.fromObject(
                object.number,
              );
            }
            if (object.indefiniteRange != null) {
              if (typeof object.indefiniteRange !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.CopyNumber.indefiniteRange: object expected",
                );
              message.indefiniteRange =
                $root.org.ga4gh.vrs.v1.IndefiniteRange.fromObject(
                  object.indefiniteRange,
                );
            }
            if (object.definiteRange != null) {
              if (typeof object.definiteRange !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.CopyNumber.definiteRange: object expected",
                );
              message.definiteRange =
                $root.org.ga4gh.vrs.v1.DefiniteRange.fromObject(
                  object.definiteRange,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a CopyNumber message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @static
           * @param {org.ga4gh.vrs.v1.CopyNumber} message CopyNumber
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          CopyNumber.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) object._id = "";
            if (message._id != null && message.hasOwnProperty("_id"))
              object._id = message._id;
            if (message.allele != null && message.hasOwnProperty("allele")) {
              object.allele = $root.org.ga4gh.vrs.v1.Allele.toObject(
                message.allele,
                options,
              );
              if (options.oneofs) object.subject = "allele";
            }
            if (
              message.haplotype != null &&
              message.hasOwnProperty("haplotype")
            ) {
              object.haplotype = $root.org.ga4gh.vrs.v1.Haplotype.toObject(
                message.haplotype,
                options,
              );
              if (options.oneofs) object.subject = "haplotype";
            }
            if (message.gene != null && message.hasOwnProperty("gene")) {
              object.gene = $root.org.ga4gh.vrs.v1.Gene.toObject(
                message.gene,
                options,
              );
              if (options.oneofs) object.subject = "gene";
            }
            if (
              message.literalSequenceExpression != null &&
              message.hasOwnProperty("literalSequenceExpression")
            ) {
              object.literalSequenceExpression =
                $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.toObject(
                  message.literalSequenceExpression,
                  options,
                );
              if (options.oneofs) object.subject = "literalSequenceExpression";
            }
            if (
              message.derivedSequenceExpression != null &&
              message.hasOwnProperty("derivedSequenceExpression")
            ) {
              object.derivedSequenceExpression =
                $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.toObject(
                  message.derivedSequenceExpression,
                  options,
                );
              if (options.oneofs) object.subject = "derivedSequenceExpression";
            }
            if (
              message.repeatedSequenceExpression != null &&
              message.hasOwnProperty("repeatedSequenceExpression")
            ) {
              object.repeatedSequenceExpression =
                $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.toObject(
                  message.repeatedSequenceExpression,
                  options,
                );
              if (options.oneofs) object.subject = "repeatedSequenceExpression";
            }
            if (message.curie != null && message.hasOwnProperty("curie")) {
              object.curie = message.curie;
              if (options.oneofs) object.subject = "curie";
            }
            if (message.number != null && message.hasOwnProperty("number")) {
              object.number = $root.org.ga4gh.vrs.v1.Number.toObject(
                message.number,
                options,
              );
              if (options.oneofs) object.copies = "number";
            }
            if (
              message.indefiniteRange != null &&
              message.hasOwnProperty("indefiniteRange")
            ) {
              object.indefiniteRange =
                $root.org.ga4gh.vrs.v1.IndefiniteRange.toObject(
                  message.indefiniteRange,
                  options,
                );
              if (options.oneofs) object.copies = "indefiniteRange";
            }
            if (
              message.definiteRange != null &&
              message.hasOwnProperty("definiteRange")
            ) {
              object.definiteRange =
                $root.org.ga4gh.vrs.v1.DefiniteRange.toObject(
                  message.definiteRange,
                  options,
                );
              if (options.oneofs) object.copies = "definiteRange";
            }
            return object;
          };

          /**
           * Converts this CopyNumber to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          CopyNumber.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for CopyNumber
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.CopyNumber
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          CopyNumber.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.CopyNumber";
          };

          return CopyNumber;
        })();

        v1.Location = (function () {
          /**
           * Properties of a Location.
           * @memberof org.ga4gh.vrs.v1
           * @interface ILocation
           * @property {org.ga4gh.vrs.v1.IChromosomeLocation|null} [chromosomeLocation] Location chromosomeLocation
           * @property {org.ga4gh.vrs.v1.ISequenceLocation|null} [sequenceLocation] Location sequenceLocation
           */

          /**
           * Constructs a new Location.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a Location.
           * @implements ILocation
           * @constructor
           * @param {org.ga4gh.vrs.v1.ILocation=} [properties] Properties to set
           */
          function Location(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Location chromosomeLocation.
           * @member {org.ga4gh.vrs.v1.IChromosomeLocation|null|undefined} chromosomeLocation
           * @memberof org.ga4gh.vrs.v1.Location
           * @instance
           */
          Location.prototype.chromosomeLocation = null;

          /**
           * Location sequenceLocation.
           * @member {org.ga4gh.vrs.v1.ISequenceLocation|null|undefined} sequenceLocation
           * @memberof org.ga4gh.vrs.v1.Location
           * @instance
           */
          Location.prototype.sequenceLocation = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * Location location.
           * @member {"chromosomeLocation"|"sequenceLocation"|undefined} location
           * @memberof org.ga4gh.vrs.v1.Location
           * @instance
           */
          Object.defineProperty(Location.prototype, "location", {
            get: $util.oneOfGetter(
              ($oneOfFields = ["chromosomeLocation", "sequenceLocation"]),
            ),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Creates a new Location instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.Location
           * @static
           * @param {org.ga4gh.vrs.v1.ILocation=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.Location} Location instance
           */
          Location.create = function create(properties) {
            return new Location(properties);
          };

          /**
           * Encodes the specified Location message. Does not implicitly {@link org.ga4gh.vrs.v1.Location.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.Location
           * @static
           * @param {org.ga4gh.vrs.v1.ILocation} message Location message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Location.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.chromosomeLocation != null &&
              Object.hasOwnProperty.call(message, "chromosomeLocation")
            )
              $root.org.ga4gh.vrs.v1.ChromosomeLocation.encode(
                message.chromosomeLocation,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            if (
              message.sequenceLocation != null &&
              Object.hasOwnProperty.call(message, "sequenceLocation")
            )
              $root.org.ga4gh.vrs.v1.SequenceLocation.encode(
                message.sequenceLocation,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified Location message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.Location.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.Location
           * @static
           * @param {org.ga4gh.vrs.v1.ILocation} message Location message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Location.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Location message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.Location
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.Location} Location
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Location.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.Location();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.chromosomeLocation =
                    $root.org.ga4gh.vrs.v1.ChromosomeLocation.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 2: {
                  message.sequenceLocation =
                    $root.org.ga4gh.vrs.v1.SequenceLocation.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Location message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.Location
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.Location} Location
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Location.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Location message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.Location
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Location.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (
              message.chromosomeLocation != null &&
              message.hasOwnProperty("chromosomeLocation")
            ) {
              properties.location = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.ChromosomeLocation.verify(
                  message.chromosomeLocation,
                );
                if (error) return "chromosomeLocation." + error;
              }
            }
            if (
              message.sequenceLocation != null &&
              message.hasOwnProperty("sequenceLocation")
            ) {
              if (properties.location === 1) return "location: multiple values";
              properties.location = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.SequenceLocation.verify(
                  message.sequenceLocation,
                );
                if (error) return "sequenceLocation." + error;
              }
            }
            return null;
          };

          /**
           * Creates a Location message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.Location
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.Location} Location
           */
          Location.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.Location)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.Location();
            if (object.chromosomeLocation != null) {
              if (typeof object.chromosomeLocation !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Location.chromosomeLocation: object expected",
                );
              message.chromosomeLocation =
                $root.org.ga4gh.vrs.v1.ChromosomeLocation.fromObject(
                  object.chromosomeLocation,
                );
            }
            if (object.sequenceLocation != null) {
              if (typeof object.sequenceLocation !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Location.sequenceLocation: object expected",
                );
              message.sequenceLocation =
                $root.org.ga4gh.vrs.v1.SequenceLocation.fromObject(
                  object.sequenceLocation,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a Location message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.Location
           * @static
           * @param {org.ga4gh.vrs.v1.Location} message Location
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Location.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (
              message.chromosomeLocation != null &&
              message.hasOwnProperty("chromosomeLocation")
            ) {
              object.chromosomeLocation =
                $root.org.ga4gh.vrs.v1.ChromosomeLocation.toObject(
                  message.chromosomeLocation,
                  options,
                );
              if (options.oneofs) object.location = "chromosomeLocation";
            }
            if (
              message.sequenceLocation != null &&
              message.hasOwnProperty("sequenceLocation")
            ) {
              object.sequenceLocation =
                $root.org.ga4gh.vrs.v1.SequenceLocation.toObject(
                  message.sequenceLocation,
                  options,
                );
              if (options.oneofs) object.location = "sequenceLocation";
            }
            return object;
          };

          /**
           * Converts this Location to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.Location
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Location.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Location
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.Location
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Location.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.Location";
          };

          return Location;
        })();

        v1.ChromosomeLocation = (function () {
          /**
           * Properties of a ChromosomeLocation.
           * @memberof org.ga4gh.vrs.v1
           * @interface IChromosomeLocation
           * @property {string|null} [_id] ChromosomeLocation _id
           * @property {string|null} [speciesId] ChromosomeLocation speciesId
           * @property {string|null} [chr] ChromosomeLocation chr
           * @property {org.ga4gh.vrs.v1.ICytobandInterval|null} [interval] ChromosomeLocation interval
           */

          /**
           * Constructs a new ChromosomeLocation.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a ChromosomeLocation.
           * @implements IChromosomeLocation
           * @constructor
           * @param {org.ga4gh.vrs.v1.IChromosomeLocation=} [properties] Properties to set
           */
          function ChromosomeLocation(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * ChromosomeLocation _id.
           * @member {string} _id
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @instance
           */
          ChromosomeLocation.prototype._id = "";

          /**
           * ChromosomeLocation speciesId.
           * @member {string} speciesId
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @instance
           */
          ChromosomeLocation.prototype.speciesId = "";

          /**
           * ChromosomeLocation chr.
           * @member {string} chr
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @instance
           */
          ChromosomeLocation.prototype.chr = "";

          /**
           * ChromosomeLocation interval.
           * @member {org.ga4gh.vrs.v1.ICytobandInterval|null|undefined} interval
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @instance
           */
          ChromosomeLocation.prototype.interval = null;

          /**
           * Creates a new ChromosomeLocation instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @static
           * @param {org.ga4gh.vrs.v1.IChromosomeLocation=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.ChromosomeLocation} ChromosomeLocation instance
           */
          ChromosomeLocation.create = function create(properties) {
            return new ChromosomeLocation(properties);
          };

          /**
           * Encodes the specified ChromosomeLocation message. Does not implicitly {@link org.ga4gh.vrs.v1.ChromosomeLocation.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @static
           * @param {org.ga4gh.vrs.v1.IChromosomeLocation} message ChromosomeLocation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ChromosomeLocation.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message._id != null &&
              Object.hasOwnProperty.call(message, "_id")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message._id);
            if (
              message.speciesId != null &&
              Object.hasOwnProperty.call(message, "speciesId")
            )
              writer
                .uint32(/* id 2, wireType 2 =*/ 18)
                .string(message.speciesId);
            if (
              message.chr != null &&
              Object.hasOwnProperty.call(message, "chr")
            )
              writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.chr);
            if (
              message.interval != null &&
              Object.hasOwnProperty.call(message, "interval")
            )
              $root.org.ga4gh.vrs.v1.CytobandInterval.encode(
                message.interval,
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified ChromosomeLocation message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.ChromosomeLocation.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @static
           * @param {org.ga4gh.vrs.v1.IChromosomeLocation} message ChromosomeLocation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          ChromosomeLocation.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a ChromosomeLocation message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.ChromosomeLocation} ChromosomeLocation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ChromosomeLocation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.ChromosomeLocation();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message._id = reader.string();
                  break;
                }
                case 2: {
                  message.speciesId = reader.string();
                  break;
                }
                case 3: {
                  message.chr = reader.string();
                  break;
                }
                case 4: {
                  message.interval =
                    $root.org.ga4gh.vrs.v1.CytobandInterval.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a ChromosomeLocation message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.ChromosomeLocation} ChromosomeLocation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          ChromosomeLocation.decodeDelimited = function decodeDelimited(
            reader,
          ) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a ChromosomeLocation message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          ChromosomeLocation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message._id != null && message.hasOwnProperty("_id"))
              if (!$util.isString(message._id)) return "_id: string expected";
            if (
              message.speciesId != null &&
              message.hasOwnProperty("speciesId")
            )
              if (!$util.isString(message.speciesId))
                return "speciesId: string expected";
            if (message.chr != null && message.hasOwnProperty("chr"))
              if (!$util.isString(message.chr)) return "chr: string expected";
            if (
              message.interval != null &&
              message.hasOwnProperty("interval")
            ) {
              let error = $root.org.ga4gh.vrs.v1.CytobandInterval.verify(
                message.interval,
              );
              if (error) return "interval." + error;
            }
            return null;
          };

          /**
           * Creates a ChromosomeLocation message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.ChromosomeLocation} ChromosomeLocation
           */
          ChromosomeLocation.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.ChromosomeLocation)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.ChromosomeLocation();
            if (object._id != null) message._id = String(object._id);
            if (object.speciesId != null)
              message.speciesId = String(object.speciesId);
            if (object.chr != null) message.chr = String(object.chr);
            if (object.interval != null) {
              if (typeof object.interval !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.ChromosomeLocation.interval: object expected",
                );
              message.interval =
                $root.org.ga4gh.vrs.v1.CytobandInterval.fromObject(
                  object.interval,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a ChromosomeLocation message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @static
           * @param {org.ga4gh.vrs.v1.ChromosomeLocation} message ChromosomeLocation
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          ChromosomeLocation.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              object._id = "";
              object.speciesId = "";
              object.chr = "";
              object.interval = null;
            }
            if (message._id != null && message.hasOwnProperty("_id"))
              object._id = message._id;
            if (
              message.speciesId != null &&
              message.hasOwnProperty("speciesId")
            )
              object.speciesId = message.speciesId;
            if (message.chr != null && message.hasOwnProperty("chr"))
              object.chr = message.chr;
            if (message.interval != null && message.hasOwnProperty("interval"))
              object.interval =
                $root.org.ga4gh.vrs.v1.CytobandInterval.toObject(
                  message.interval,
                  options,
                );
            return object;
          };

          /**
           * Converts this ChromosomeLocation to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          ChromosomeLocation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for ChromosomeLocation
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.ChromosomeLocation
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          ChromosomeLocation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.ChromosomeLocation";
          };

          return ChromosomeLocation;
        })();

        v1.SequenceLocation = (function () {
          /**
           * Properties of a SequenceLocation.
           * @memberof org.ga4gh.vrs.v1
           * @interface ISequenceLocation
           * @property {string|null} [_id] SequenceLocation _id
           * @property {string|null} [sequenceId] SequenceLocation sequenceId
           * @property {org.ga4gh.vrs.v1.ISequenceInterval|null} [sequenceInterval] SequenceLocation sequenceInterval
           * @property {org.ga4gh.vrs.v1.ISimpleInterval|null} [simpleInterval] SequenceLocation simpleInterval
           */

          /**
           * Constructs a new SequenceLocation.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a SequenceLocation.
           * @implements ISequenceLocation
           * @constructor
           * @param {org.ga4gh.vrs.v1.ISequenceLocation=} [properties] Properties to set
           */
          function SequenceLocation(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * SequenceLocation _id.
           * @member {string} _id
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @instance
           */
          SequenceLocation.prototype._id = "";

          /**
           * SequenceLocation sequenceId.
           * @member {string} sequenceId
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @instance
           */
          SequenceLocation.prototype.sequenceId = "";

          /**
           * SequenceLocation sequenceInterval.
           * @member {org.ga4gh.vrs.v1.ISequenceInterval|null|undefined} sequenceInterval
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @instance
           */
          SequenceLocation.prototype.sequenceInterval = null;

          /**
           * SequenceLocation simpleInterval.
           * @member {org.ga4gh.vrs.v1.ISimpleInterval|null|undefined} simpleInterval
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @instance
           */
          SequenceLocation.prototype.simpleInterval = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * SequenceLocation interval.
           * @member {"sequenceInterval"|"simpleInterval"|undefined} interval
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @instance
           */
          Object.defineProperty(SequenceLocation.prototype, "interval", {
            get: $util.oneOfGetter(
              ($oneOfFields = ["sequenceInterval", "simpleInterval"]),
            ),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Creates a new SequenceLocation instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceLocation=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.SequenceLocation} SequenceLocation instance
           */
          SequenceLocation.create = function create(properties) {
            return new SequenceLocation(properties);
          };

          /**
           * Encodes the specified SequenceLocation message. Does not implicitly {@link org.ga4gh.vrs.v1.SequenceLocation.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceLocation} message SequenceLocation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SequenceLocation.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message._id != null &&
              Object.hasOwnProperty.call(message, "_id")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message._id);
            if (
              message.sequenceId != null &&
              Object.hasOwnProperty.call(message, "sequenceId")
            )
              writer
                .uint32(/* id 2, wireType 2 =*/ 18)
                .string(message.sequenceId);
            if (
              message.sequenceInterval != null &&
              Object.hasOwnProperty.call(message, "sequenceInterval")
            )
              $root.org.ga4gh.vrs.v1.SequenceInterval.encode(
                message.sequenceInterval,
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
            if (
              message.simpleInterval != null &&
              Object.hasOwnProperty.call(message, "simpleInterval")
            )
              $root.org.ga4gh.vrs.v1.SimpleInterval.encode(
                message.simpleInterval,
                writer.uint32(/* id 100, wireType 2 =*/ 802).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified SequenceLocation message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.SequenceLocation.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceLocation} message SequenceLocation message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SequenceLocation.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SequenceLocation message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.SequenceLocation} SequenceLocation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SequenceLocation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.SequenceLocation();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message._id = reader.string();
                  break;
                }
                case 2: {
                  message.sequenceId = reader.string();
                  break;
                }
                case 3: {
                  message.sequenceInterval =
                    $root.org.ga4gh.vrs.v1.SequenceInterval.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 100: {
                  message.simpleInterval =
                    $root.org.ga4gh.vrs.v1.SimpleInterval.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SequenceLocation message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.SequenceLocation} SequenceLocation
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SequenceLocation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SequenceLocation message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SequenceLocation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (message._id != null && message.hasOwnProperty("_id"))
              if (!$util.isString(message._id)) return "_id: string expected";
            if (
              message.sequenceId != null &&
              message.hasOwnProperty("sequenceId")
            )
              if (!$util.isString(message.sequenceId))
                return "sequenceId: string expected";
            if (
              message.sequenceInterval != null &&
              message.hasOwnProperty("sequenceInterval")
            ) {
              properties.interval = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.SequenceInterval.verify(
                  message.sequenceInterval,
                );
                if (error) return "sequenceInterval." + error;
              }
            }
            if (
              message.simpleInterval != null &&
              message.hasOwnProperty("simpleInterval")
            ) {
              if (properties.interval === 1) return "interval: multiple values";
              properties.interval = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.SimpleInterval.verify(
                  message.simpleInterval,
                );
                if (error) return "simpleInterval." + error;
              }
            }
            return null;
          };

          /**
           * Creates a SequenceLocation message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.SequenceLocation} SequenceLocation
           */
          SequenceLocation.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.SequenceLocation)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.SequenceLocation();
            if (object._id != null) message._id = String(object._id);
            if (object.sequenceId != null)
              message.sequenceId = String(object.sequenceId);
            if (object.sequenceInterval != null) {
              if (typeof object.sequenceInterval !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceLocation.sequenceInterval: object expected",
                );
              message.sequenceInterval =
                $root.org.ga4gh.vrs.v1.SequenceInterval.fromObject(
                  object.sequenceInterval,
                );
            }
            if (object.simpleInterval != null) {
              if (typeof object.simpleInterval !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceLocation.simpleInterval: object expected",
                );
              message.simpleInterval =
                $root.org.ga4gh.vrs.v1.SimpleInterval.fromObject(
                  object.simpleInterval,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a SequenceLocation message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @static
           * @param {org.ga4gh.vrs.v1.SequenceLocation} message SequenceLocation
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SequenceLocation.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              object._id = "";
              object.sequenceId = "";
            }
            if (message._id != null && message.hasOwnProperty("_id"))
              object._id = message._id;
            if (
              message.sequenceId != null &&
              message.hasOwnProperty("sequenceId")
            )
              object.sequenceId = message.sequenceId;
            if (
              message.sequenceInterval != null &&
              message.hasOwnProperty("sequenceInterval")
            ) {
              object.sequenceInterval =
                $root.org.ga4gh.vrs.v1.SequenceInterval.toObject(
                  message.sequenceInterval,
                  options,
                );
              if (options.oneofs) object.interval = "sequenceInterval";
            }
            if (
              message.simpleInterval != null &&
              message.hasOwnProperty("simpleInterval")
            ) {
              object.simpleInterval =
                $root.org.ga4gh.vrs.v1.SimpleInterval.toObject(
                  message.simpleInterval,
                  options,
                );
              if (options.oneofs) object.interval = "simpleInterval";
            }
            return object;
          };

          /**
           * Converts this SequenceLocation to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SequenceLocation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for SequenceLocation
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.SequenceLocation
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          SequenceLocation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.SequenceLocation";
          };

          return SequenceLocation;
        })();

        v1.SequenceInterval = (function () {
          /**
           * Properties of a SequenceInterval.
           * @memberof org.ga4gh.vrs.v1
           * @interface ISequenceInterval
           * @property {org.ga4gh.vrs.v1.INumber|null} [startNumber] SequenceInterval startNumber
           * @property {org.ga4gh.vrs.v1.IIndefiniteRange|null} [startIndefiniteRange] SequenceInterval startIndefiniteRange
           * @property {org.ga4gh.vrs.v1.IDefiniteRange|null} [startDefiniteRange] SequenceInterval startDefiniteRange
           * @property {org.ga4gh.vrs.v1.INumber|null} [endNumber] SequenceInterval endNumber
           * @property {org.ga4gh.vrs.v1.IIndefiniteRange|null} [endIndefiniteRange] SequenceInterval endIndefiniteRange
           * @property {org.ga4gh.vrs.v1.IDefiniteRange|null} [endDefiniteRange] SequenceInterval endDefiniteRange
           */

          /**
           * Constructs a new SequenceInterval.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a SequenceInterval.
           * @implements ISequenceInterval
           * @constructor
           * @param {org.ga4gh.vrs.v1.ISequenceInterval=} [properties] Properties to set
           */
          function SequenceInterval(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * SequenceInterval startNumber.
           * @member {org.ga4gh.vrs.v1.INumber|null|undefined} startNumber
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @instance
           */
          SequenceInterval.prototype.startNumber = null;

          /**
           * SequenceInterval startIndefiniteRange.
           * @member {org.ga4gh.vrs.v1.IIndefiniteRange|null|undefined} startIndefiniteRange
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @instance
           */
          SequenceInterval.prototype.startIndefiniteRange = null;

          /**
           * SequenceInterval startDefiniteRange.
           * @member {org.ga4gh.vrs.v1.IDefiniteRange|null|undefined} startDefiniteRange
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @instance
           */
          SequenceInterval.prototype.startDefiniteRange = null;

          /**
           * SequenceInterval endNumber.
           * @member {org.ga4gh.vrs.v1.INumber|null|undefined} endNumber
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @instance
           */
          SequenceInterval.prototype.endNumber = null;

          /**
           * SequenceInterval endIndefiniteRange.
           * @member {org.ga4gh.vrs.v1.IIndefiniteRange|null|undefined} endIndefiniteRange
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @instance
           */
          SequenceInterval.prototype.endIndefiniteRange = null;

          /**
           * SequenceInterval endDefiniteRange.
           * @member {org.ga4gh.vrs.v1.IDefiniteRange|null|undefined} endDefiniteRange
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @instance
           */
          SequenceInterval.prototype.endDefiniteRange = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * SequenceInterval start.
           * @member {"startNumber"|"startIndefiniteRange"|"startDefiniteRange"|undefined} start
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @instance
           */
          Object.defineProperty(SequenceInterval.prototype, "start", {
            get: $util.oneOfGetter(
              ($oneOfFields = [
                "startNumber",
                "startIndefiniteRange",
                "startDefiniteRange",
              ]),
            ),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * SequenceInterval end.
           * @member {"endNumber"|"endIndefiniteRange"|"endDefiniteRange"|undefined} end
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @instance
           */
          Object.defineProperty(SequenceInterval.prototype, "end", {
            get: $util.oneOfGetter(
              ($oneOfFields = [
                "endNumber",
                "endIndefiniteRange",
                "endDefiniteRange",
              ]),
            ),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Creates a new SequenceInterval instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceInterval=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.SequenceInterval} SequenceInterval instance
           */
          SequenceInterval.create = function create(properties) {
            return new SequenceInterval(properties);
          };

          /**
           * Encodes the specified SequenceInterval message. Does not implicitly {@link org.ga4gh.vrs.v1.SequenceInterval.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceInterval} message SequenceInterval message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SequenceInterval.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.startNumber != null &&
              Object.hasOwnProperty.call(message, "startNumber")
            )
              $root.org.ga4gh.vrs.v1.Number.encode(
                message.startNumber,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            if (
              message.startIndefiniteRange != null &&
              Object.hasOwnProperty.call(message, "startIndefiniteRange")
            )
              $root.org.ga4gh.vrs.v1.IndefiniteRange.encode(
                message.startIndefiniteRange,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            if (
              message.startDefiniteRange != null &&
              Object.hasOwnProperty.call(message, "startDefiniteRange")
            )
              $root.org.ga4gh.vrs.v1.DefiniteRange.encode(
                message.startDefiniteRange,
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
            if (
              message.endNumber != null &&
              Object.hasOwnProperty.call(message, "endNumber")
            )
              $root.org.ga4gh.vrs.v1.Number.encode(
                message.endNumber,
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
            if (
              message.endIndefiniteRange != null &&
              Object.hasOwnProperty.call(message, "endIndefiniteRange")
            )
              $root.org.ga4gh.vrs.v1.IndefiniteRange.encode(
                message.endIndefiniteRange,
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
            if (
              message.endDefiniteRange != null &&
              Object.hasOwnProperty.call(message, "endDefiniteRange")
            )
              $root.org.ga4gh.vrs.v1.DefiniteRange.encode(
                message.endDefiniteRange,
                writer.uint32(/* id 6, wireType 2 =*/ 50).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified SequenceInterval message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.SequenceInterval.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceInterval} message SequenceInterval message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SequenceInterval.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SequenceInterval message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.SequenceInterval} SequenceInterval
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SequenceInterval.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.SequenceInterval();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.startNumber = $root.org.ga4gh.vrs.v1.Number.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 2: {
                  message.startIndefiniteRange =
                    $root.org.ga4gh.vrs.v1.IndefiniteRange.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 3: {
                  message.startDefiniteRange =
                    $root.org.ga4gh.vrs.v1.DefiniteRange.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 4: {
                  message.endNumber = $root.org.ga4gh.vrs.v1.Number.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 5: {
                  message.endIndefiniteRange =
                    $root.org.ga4gh.vrs.v1.IndefiniteRange.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 6: {
                  message.endDefiniteRange =
                    $root.org.ga4gh.vrs.v1.DefiniteRange.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SequenceInterval message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.SequenceInterval} SequenceInterval
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SequenceInterval.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SequenceInterval message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SequenceInterval.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (
              message.startNumber != null &&
              message.hasOwnProperty("startNumber")
            ) {
              properties.start = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Number.verify(
                  message.startNumber,
                );
                if (error) return "startNumber." + error;
              }
            }
            if (
              message.startIndefiniteRange != null &&
              message.hasOwnProperty("startIndefiniteRange")
            ) {
              if (properties.start === 1) return "start: multiple values";
              properties.start = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.IndefiniteRange.verify(
                  message.startIndefiniteRange,
                );
                if (error) return "startIndefiniteRange." + error;
              }
            }
            if (
              message.startDefiniteRange != null &&
              message.hasOwnProperty("startDefiniteRange")
            ) {
              if (properties.start === 1) return "start: multiple values";
              properties.start = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.DefiniteRange.verify(
                  message.startDefiniteRange,
                );
                if (error) return "startDefiniteRange." + error;
              }
            }
            if (
              message.endNumber != null &&
              message.hasOwnProperty("endNumber")
            ) {
              properties.end = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Number.verify(
                  message.endNumber,
                );
                if (error) return "endNumber." + error;
              }
            }
            if (
              message.endIndefiniteRange != null &&
              message.hasOwnProperty("endIndefiniteRange")
            ) {
              if (properties.end === 1) return "end: multiple values";
              properties.end = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.IndefiniteRange.verify(
                  message.endIndefiniteRange,
                );
                if (error) return "endIndefiniteRange." + error;
              }
            }
            if (
              message.endDefiniteRange != null &&
              message.hasOwnProperty("endDefiniteRange")
            ) {
              if (properties.end === 1) return "end: multiple values";
              properties.end = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.DefiniteRange.verify(
                  message.endDefiniteRange,
                );
                if (error) return "endDefiniteRange." + error;
              }
            }
            return null;
          };

          /**
           * Creates a SequenceInterval message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.SequenceInterval} SequenceInterval
           */
          SequenceInterval.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.SequenceInterval)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.SequenceInterval();
            if (object.startNumber != null) {
              if (typeof object.startNumber !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceInterval.startNumber: object expected",
                );
              message.startNumber = $root.org.ga4gh.vrs.v1.Number.fromObject(
                object.startNumber,
              );
            }
            if (object.startIndefiniteRange != null) {
              if (typeof object.startIndefiniteRange !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceInterval.startIndefiniteRange: object expected",
                );
              message.startIndefiniteRange =
                $root.org.ga4gh.vrs.v1.IndefiniteRange.fromObject(
                  object.startIndefiniteRange,
                );
            }
            if (object.startDefiniteRange != null) {
              if (typeof object.startDefiniteRange !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceInterval.startDefiniteRange: object expected",
                );
              message.startDefiniteRange =
                $root.org.ga4gh.vrs.v1.DefiniteRange.fromObject(
                  object.startDefiniteRange,
                );
            }
            if (object.endNumber != null) {
              if (typeof object.endNumber !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceInterval.endNumber: object expected",
                );
              message.endNumber = $root.org.ga4gh.vrs.v1.Number.fromObject(
                object.endNumber,
              );
            }
            if (object.endIndefiniteRange != null) {
              if (typeof object.endIndefiniteRange !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceInterval.endIndefiniteRange: object expected",
                );
              message.endIndefiniteRange =
                $root.org.ga4gh.vrs.v1.IndefiniteRange.fromObject(
                  object.endIndefiniteRange,
                );
            }
            if (object.endDefiniteRange != null) {
              if (typeof object.endDefiniteRange !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceInterval.endDefiniteRange: object expected",
                );
              message.endDefiniteRange =
                $root.org.ga4gh.vrs.v1.DefiniteRange.fromObject(
                  object.endDefiniteRange,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a SequenceInterval message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @static
           * @param {org.ga4gh.vrs.v1.SequenceInterval} message SequenceInterval
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SequenceInterval.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (
              message.startNumber != null &&
              message.hasOwnProperty("startNumber")
            ) {
              object.startNumber = $root.org.ga4gh.vrs.v1.Number.toObject(
                message.startNumber,
                options,
              );
              if (options.oneofs) object.start = "startNumber";
            }
            if (
              message.startIndefiniteRange != null &&
              message.hasOwnProperty("startIndefiniteRange")
            ) {
              object.startIndefiniteRange =
                $root.org.ga4gh.vrs.v1.IndefiniteRange.toObject(
                  message.startIndefiniteRange,
                  options,
                );
              if (options.oneofs) object.start = "startIndefiniteRange";
            }
            if (
              message.startDefiniteRange != null &&
              message.hasOwnProperty("startDefiniteRange")
            ) {
              object.startDefiniteRange =
                $root.org.ga4gh.vrs.v1.DefiniteRange.toObject(
                  message.startDefiniteRange,
                  options,
                );
              if (options.oneofs) object.start = "startDefiniteRange";
            }
            if (
              message.endNumber != null &&
              message.hasOwnProperty("endNumber")
            ) {
              object.endNumber = $root.org.ga4gh.vrs.v1.Number.toObject(
                message.endNumber,
                options,
              );
              if (options.oneofs) object.end = "endNumber";
            }
            if (
              message.endIndefiniteRange != null &&
              message.hasOwnProperty("endIndefiniteRange")
            ) {
              object.endIndefiniteRange =
                $root.org.ga4gh.vrs.v1.IndefiniteRange.toObject(
                  message.endIndefiniteRange,
                  options,
                );
              if (options.oneofs) object.end = "endIndefiniteRange";
            }
            if (
              message.endDefiniteRange != null &&
              message.hasOwnProperty("endDefiniteRange")
            ) {
              object.endDefiniteRange =
                $root.org.ga4gh.vrs.v1.DefiniteRange.toObject(
                  message.endDefiniteRange,
                  options,
                );
              if (options.oneofs) object.end = "endDefiniteRange";
            }
            return object;
          };

          /**
           * Converts this SequenceInterval to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SequenceInterval.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for SequenceInterval
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.SequenceInterval
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          SequenceInterval.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.SequenceInterval";
          };

          return SequenceInterval;
        })();

        v1.CytobandInterval = (function () {
          /**
           * Properties of a CytobandInterval.
           * @memberof org.ga4gh.vrs.v1
           * @interface ICytobandInterval
           * @property {string|null} [start] CytobandInterval start
           * @property {string|null} [end] CytobandInterval end
           */

          /**
           * Constructs a new CytobandInterval.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a CytobandInterval.
           * @implements ICytobandInterval
           * @constructor
           * @param {org.ga4gh.vrs.v1.ICytobandInterval=} [properties] Properties to set
           */
          function CytobandInterval(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * CytobandInterval start.
           * @member {string} start
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @instance
           */
          CytobandInterval.prototype.start = "";

          /**
           * CytobandInterval end.
           * @member {string} end
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @instance
           */
          CytobandInterval.prototype.end = "";

          /**
           * Creates a new CytobandInterval instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @static
           * @param {org.ga4gh.vrs.v1.ICytobandInterval=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.CytobandInterval} CytobandInterval instance
           */
          CytobandInterval.create = function create(properties) {
            return new CytobandInterval(properties);
          };

          /**
           * Encodes the specified CytobandInterval message. Does not implicitly {@link org.ga4gh.vrs.v1.CytobandInterval.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @static
           * @param {org.ga4gh.vrs.v1.ICytobandInterval} message CytobandInterval message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          CytobandInterval.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.start != null &&
              Object.hasOwnProperty.call(message, "start")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.start);
            if (
              message.end != null &&
              Object.hasOwnProperty.call(message, "end")
            )
              writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.end);
            return writer;
          };

          /**
           * Encodes the specified CytobandInterval message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.CytobandInterval.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @static
           * @param {org.ga4gh.vrs.v1.ICytobandInterval} message CytobandInterval message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          CytobandInterval.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a CytobandInterval message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.CytobandInterval} CytobandInterval
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          CytobandInterval.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.CytobandInterval();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.start = reader.string();
                  break;
                }
                case 2: {
                  message.end = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a CytobandInterval message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.CytobandInterval} CytobandInterval
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          CytobandInterval.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a CytobandInterval message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          CytobandInterval.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.start != null && message.hasOwnProperty("start"))
              if (!$util.isString(message.start))
                return "start: string expected";
            if (message.end != null && message.hasOwnProperty("end"))
              if (!$util.isString(message.end)) return "end: string expected";
            return null;
          };

          /**
           * Creates a CytobandInterval message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.CytobandInterval} CytobandInterval
           */
          CytobandInterval.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.CytobandInterval)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.CytobandInterval();
            if (object.start != null) message.start = String(object.start);
            if (object.end != null) message.end = String(object.end);
            return message;
          };

          /**
           * Creates a plain object from a CytobandInterval message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @static
           * @param {org.ga4gh.vrs.v1.CytobandInterval} message CytobandInterval
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          CytobandInterval.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              object.start = "";
              object.end = "";
            }
            if (message.start != null && message.hasOwnProperty("start"))
              object.start = message.start;
            if (message.end != null && message.hasOwnProperty("end"))
              object.end = message.end;
            return object;
          };

          /**
           * Converts this CytobandInterval to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          CytobandInterval.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for CytobandInterval
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.CytobandInterval
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          CytobandInterval.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.CytobandInterval";
          };

          return CytobandInterval;
        })();

        v1.SequenceExpression = (function () {
          /**
           * Properties of a SequenceExpression.
           * @memberof org.ga4gh.vrs.v1
           * @interface ISequenceExpression
           * @property {org.ga4gh.vrs.v1.ILiteralSequenceExpression|null} [literalSequenceExpression] SequenceExpression literalSequenceExpression
           * @property {org.ga4gh.vrs.v1.IDerivedSequenceExpression|null} [derivedSequenceExpression] SequenceExpression derivedSequenceExpression
           * @property {org.ga4gh.vrs.v1.IRepeatedSequenceExpression|null} [repeatedSequenceExpression] SequenceExpression repeatedSequenceExpression
           */

          /**
           * Constructs a new SequenceExpression.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a SequenceExpression.
           * @implements ISequenceExpression
           * @constructor
           * @param {org.ga4gh.vrs.v1.ISequenceExpression=} [properties] Properties to set
           */
          function SequenceExpression(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * SequenceExpression literalSequenceExpression.
           * @member {org.ga4gh.vrs.v1.ILiteralSequenceExpression|null|undefined} literalSequenceExpression
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @instance
           */
          SequenceExpression.prototype.literalSequenceExpression = null;

          /**
           * SequenceExpression derivedSequenceExpression.
           * @member {org.ga4gh.vrs.v1.IDerivedSequenceExpression|null|undefined} derivedSequenceExpression
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @instance
           */
          SequenceExpression.prototype.derivedSequenceExpression = null;

          /**
           * SequenceExpression repeatedSequenceExpression.
           * @member {org.ga4gh.vrs.v1.IRepeatedSequenceExpression|null|undefined} repeatedSequenceExpression
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @instance
           */
          SequenceExpression.prototype.repeatedSequenceExpression = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * SequenceExpression sequenceExpression.
           * @member {"literalSequenceExpression"|"derivedSequenceExpression"|"repeatedSequenceExpression"|undefined} sequenceExpression
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @instance
           */
          Object.defineProperty(
            SequenceExpression.prototype,
            "sequenceExpression",
            {
              get: $util.oneOfGetter(
                ($oneOfFields = [
                  "literalSequenceExpression",
                  "derivedSequenceExpression",
                  "repeatedSequenceExpression",
                ]),
              ),
              set: $util.oneOfSetter($oneOfFields),
            },
          );

          /**
           * Creates a new SequenceExpression instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceExpression=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.SequenceExpression} SequenceExpression instance
           */
          SequenceExpression.create = function create(properties) {
            return new SequenceExpression(properties);
          };

          /**
           * Encodes the specified SequenceExpression message. Does not implicitly {@link org.ga4gh.vrs.v1.SequenceExpression.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceExpression} message SequenceExpression message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SequenceExpression.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.literalSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "literalSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.encode(
                message.literalSequenceExpression,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            if (
              message.derivedSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "derivedSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.encode(
                message.derivedSequenceExpression,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            if (
              message.repeatedSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "repeatedSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.encode(
                message.repeatedSequenceExpression,
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified SequenceExpression message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.SequenceExpression.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceExpression} message SequenceExpression message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SequenceExpression.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SequenceExpression message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.SequenceExpression} SequenceExpression
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SequenceExpression.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.SequenceExpression();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.literalSequenceExpression =
                    $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 2: {
                  message.derivedSequenceExpression =
                    $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 3: {
                  message.repeatedSequenceExpression =
                    $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SequenceExpression message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.SequenceExpression} SequenceExpression
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SequenceExpression.decodeDelimited = function decodeDelimited(
            reader,
          ) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SequenceExpression message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SequenceExpression.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (
              message.literalSequenceExpression != null &&
              message.hasOwnProperty("literalSequenceExpression")
            ) {
              properties.sequenceExpression = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.verify(
                    message.literalSequenceExpression,
                  );
                if (error) return "literalSequenceExpression." + error;
              }
            }
            if (
              message.derivedSequenceExpression != null &&
              message.hasOwnProperty("derivedSequenceExpression")
            ) {
              if (properties.sequenceExpression === 1)
                return "sequenceExpression: multiple values";
              properties.sequenceExpression = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.verify(
                    message.derivedSequenceExpression,
                  );
                if (error) return "derivedSequenceExpression." + error;
              }
            }
            if (
              message.repeatedSequenceExpression != null &&
              message.hasOwnProperty("repeatedSequenceExpression")
            ) {
              if (properties.sequenceExpression === 1)
                return "sequenceExpression: multiple values";
              properties.sequenceExpression = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.verify(
                    message.repeatedSequenceExpression,
                  );
                if (error) return "repeatedSequenceExpression." + error;
              }
            }
            return null;
          };

          /**
           * Creates a SequenceExpression message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.SequenceExpression} SequenceExpression
           */
          SequenceExpression.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.SequenceExpression)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.SequenceExpression();
            if (object.literalSequenceExpression != null) {
              if (typeof object.literalSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceExpression.literalSequenceExpression: object expected",
                );
              message.literalSequenceExpression =
                $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.fromObject(
                  object.literalSequenceExpression,
                );
            }
            if (object.derivedSequenceExpression != null) {
              if (typeof object.derivedSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceExpression.derivedSequenceExpression: object expected",
                );
              message.derivedSequenceExpression =
                $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.fromObject(
                  object.derivedSequenceExpression,
                );
            }
            if (object.repeatedSequenceExpression != null) {
              if (typeof object.repeatedSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.SequenceExpression.repeatedSequenceExpression: object expected",
                );
              message.repeatedSequenceExpression =
                $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.fromObject(
                  object.repeatedSequenceExpression,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a SequenceExpression message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.SequenceExpression} message SequenceExpression
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SequenceExpression.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (
              message.literalSequenceExpression != null &&
              message.hasOwnProperty("literalSequenceExpression")
            ) {
              object.literalSequenceExpression =
                $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.toObject(
                  message.literalSequenceExpression,
                  options,
                );
              if (options.oneofs)
                object.sequenceExpression = "literalSequenceExpression";
            }
            if (
              message.derivedSequenceExpression != null &&
              message.hasOwnProperty("derivedSequenceExpression")
            ) {
              object.derivedSequenceExpression =
                $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.toObject(
                  message.derivedSequenceExpression,
                  options,
                );
              if (options.oneofs)
                object.sequenceExpression = "derivedSequenceExpression";
            }
            if (
              message.repeatedSequenceExpression != null &&
              message.hasOwnProperty("repeatedSequenceExpression")
            ) {
              object.repeatedSequenceExpression =
                $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression.toObject(
                  message.repeatedSequenceExpression,
                  options,
                );
              if (options.oneofs)
                object.sequenceExpression = "repeatedSequenceExpression";
            }
            return object;
          };

          /**
           * Converts this SequenceExpression to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SequenceExpression.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for SequenceExpression
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.SequenceExpression
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          SequenceExpression.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.SequenceExpression";
          };

          return SequenceExpression;
        })();

        v1.LiteralSequenceExpression = (function () {
          /**
           * Properties of a LiteralSequenceExpression.
           * @memberof org.ga4gh.vrs.v1
           * @interface ILiteralSequenceExpression
           * @property {string|null} [sequence] LiteralSequenceExpression sequence
           */

          /**
           * Constructs a new LiteralSequenceExpression.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a LiteralSequenceExpression.
           * @implements ILiteralSequenceExpression
           * @constructor
           * @param {org.ga4gh.vrs.v1.ILiteralSequenceExpression=} [properties] Properties to set
           */
          function LiteralSequenceExpression(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * LiteralSequenceExpression sequence.
           * @member {string} sequence
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @instance
           */
          LiteralSequenceExpression.prototype.sequence = "";

          /**
           * Creates a new LiteralSequenceExpression instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.ILiteralSequenceExpression=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.LiteralSequenceExpression} LiteralSequenceExpression instance
           */
          LiteralSequenceExpression.create = function create(properties) {
            return new LiteralSequenceExpression(properties);
          };

          /**
           * Encodes the specified LiteralSequenceExpression message. Does not implicitly {@link org.ga4gh.vrs.v1.LiteralSequenceExpression.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.ILiteralSequenceExpression} message LiteralSequenceExpression message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LiteralSequenceExpression.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.sequence != null &&
              Object.hasOwnProperty.call(message, "sequence")
            )
              writer
                .uint32(/* id 1, wireType 2 =*/ 10)
                .string(message.sequence);
            return writer;
          };

          /**
           * Encodes the specified LiteralSequenceExpression message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.LiteralSequenceExpression.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.ILiteralSequenceExpression} message LiteralSequenceExpression message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          LiteralSequenceExpression.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a LiteralSequenceExpression message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.LiteralSequenceExpression} LiteralSequenceExpression
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LiteralSequenceExpression.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.LiteralSequenceExpression();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.sequence = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a LiteralSequenceExpression message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.LiteralSequenceExpression} LiteralSequenceExpression
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          LiteralSequenceExpression.decodeDelimited = function decodeDelimited(
            reader,
          ) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a LiteralSequenceExpression message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          LiteralSequenceExpression.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.sequence != null && message.hasOwnProperty("sequence"))
              if (!$util.isString(message.sequence))
                return "sequence: string expected";
            return null;
          };

          /**
           * Creates a LiteralSequenceExpression message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.LiteralSequenceExpression} LiteralSequenceExpression
           */
          LiteralSequenceExpression.fromObject = function fromObject(object) {
            if (
              object instanceof $root.org.ga4gh.vrs.v1.LiteralSequenceExpression
            )
              return object;
            let message =
              new $root.org.ga4gh.vrs.v1.LiteralSequenceExpression();
            if (object.sequence != null)
              message.sequence = String(object.sequence);
            return message;
          };

          /**
           * Creates a plain object from a LiteralSequenceExpression message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.LiteralSequenceExpression} message LiteralSequenceExpression
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          LiteralSequenceExpression.toObject = function toObject(
            message,
            options,
          ) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) object.sequence = "";
            if (message.sequence != null && message.hasOwnProperty("sequence"))
              object.sequence = message.sequence;
            return object;
          };

          /**
           * Converts this LiteralSequenceExpression to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          LiteralSequenceExpression.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for LiteralSequenceExpression
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.LiteralSequenceExpression
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          LiteralSequenceExpression.getTypeUrl = function getTypeUrl(
            typeUrlPrefix,
          ) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return (
              typeUrlPrefix + "/org.ga4gh.vrs.v1.LiteralSequenceExpression"
            );
          };

          return LiteralSequenceExpression;
        })();

        v1.DerivedSequenceExpression = (function () {
          /**
           * Properties of a DerivedSequenceExpression.
           * @memberof org.ga4gh.vrs.v1
           * @interface IDerivedSequenceExpression
           * @property {org.ga4gh.vrs.v1.ISequenceLocation|null} [location] DerivedSequenceExpression location
           * @property {boolean|null} [reverseComplement] DerivedSequenceExpression reverseComplement
           */

          /**
           * Constructs a new DerivedSequenceExpression.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a DerivedSequenceExpression.
           * @implements IDerivedSequenceExpression
           * @constructor
           * @param {org.ga4gh.vrs.v1.IDerivedSequenceExpression=} [properties] Properties to set
           */
          function DerivedSequenceExpression(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * DerivedSequenceExpression location.
           * @member {org.ga4gh.vrs.v1.ISequenceLocation|null|undefined} location
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @instance
           */
          DerivedSequenceExpression.prototype.location = null;

          /**
           * DerivedSequenceExpression reverseComplement.
           * @member {boolean} reverseComplement
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @instance
           */
          DerivedSequenceExpression.prototype.reverseComplement = false;

          /**
           * Creates a new DerivedSequenceExpression instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.IDerivedSequenceExpression=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.DerivedSequenceExpression} DerivedSequenceExpression instance
           */
          DerivedSequenceExpression.create = function create(properties) {
            return new DerivedSequenceExpression(properties);
          };

          /**
           * Encodes the specified DerivedSequenceExpression message. Does not implicitly {@link org.ga4gh.vrs.v1.DerivedSequenceExpression.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.IDerivedSequenceExpression} message DerivedSequenceExpression message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DerivedSequenceExpression.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.location != null &&
              Object.hasOwnProperty.call(message, "location")
            )
              $root.org.ga4gh.vrs.v1.SequenceLocation.encode(
                message.location,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            if (
              message.reverseComplement != null &&
              Object.hasOwnProperty.call(message, "reverseComplement")
            )
              writer
                .uint32(/* id 2, wireType 0 =*/ 16)
                .bool(message.reverseComplement);
            return writer;
          };

          /**
           * Encodes the specified DerivedSequenceExpression message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.DerivedSequenceExpression.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.IDerivedSequenceExpression} message DerivedSequenceExpression message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DerivedSequenceExpression.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a DerivedSequenceExpression message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.DerivedSequenceExpression} DerivedSequenceExpression
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DerivedSequenceExpression.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.DerivedSequenceExpression();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.location =
                    $root.org.ga4gh.vrs.v1.SequenceLocation.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 2: {
                  message.reverseComplement = reader.bool();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a DerivedSequenceExpression message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.DerivedSequenceExpression} DerivedSequenceExpression
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DerivedSequenceExpression.decodeDelimited = function decodeDelimited(
            reader,
          ) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a DerivedSequenceExpression message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          DerivedSequenceExpression.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (
              message.location != null &&
              message.hasOwnProperty("location")
            ) {
              let error = $root.org.ga4gh.vrs.v1.SequenceLocation.verify(
                message.location,
              );
              if (error) return "location." + error;
            }
            if (
              message.reverseComplement != null &&
              message.hasOwnProperty("reverseComplement")
            )
              if (typeof message.reverseComplement !== "boolean")
                return "reverseComplement: boolean expected";
            return null;
          };

          /**
           * Creates a DerivedSequenceExpression message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.DerivedSequenceExpression} DerivedSequenceExpression
           */
          DerivedSequenceExpression.fromObject = function fromObject(object) {
            if (
              object instanceof $root.org.ga4gh.vrs.v1.DerivedSequenceExpression
            )
              return object;
            let message =
              new $root.org.ga4gh.vrs.v1.DerivedSequenceExpression();
            if (object.location != null) {
              if (typeof object.location !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.DerivedSequenceExpression.location: object expected",
                );
              message.location =
                $root.org.ga4gh.vrs.v1.SequenceLocation.fromObject(
                  object.location,
                );
            }
            if (object.reverseComplement != null)
              message.reverseComplement = Boolean(object.reverseComplement);
            return message;
          };

          /**
           * Creates a plain object from a DerivedSequenceExpression message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.DerivedSequenceExpression} message DerivedSequenceExpression
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          DerivedSequenceExpression.toObject = function toObject(
            message,
            options,
          ) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              object.location = null;
              object.reverseComplement = false;
            }
            if (message.location != null && message.hasOwnProperty("location"))
              object.location =
                $root.org.ga4gh.vrs.v1.SequenceLocation.toObject(
                  message.location,
                  options,
                );
            if (
              message.reverseComplement != null &&
              message.hasOwnProperty("reverseComplement")
            )
              object.reverseComplement = message.reverseComplement;
            return object;
          };

          /**
           * Converts this DerivedSequenceExpression to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          DerivedSequenceExpression.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for DerivedSequenceExpression
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.DerivedSequenceExpression
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          DerivedSequenceExpression.getTypeUrl = function getTypeUrl(
            typeUrlPrefix,
          ) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return (
              typeUrlPrefix + "/org.ga4gh.vrs.v1.DerivedSequenceExpression"
            );
          };

          return DerivedSequenceExpression;
        })();

        v1.RepeatedSequenceExpression = (function () {
          /**
           * Properties of a RepeatedSequenceExpression.
           * @memberof org.ga4gh.vrs.v1
           * @interface IRepeatedSequenceExpression
           * @property {org.ga4gh.vrs.v1.ILiteralSequenceExpression|null} [literalSequenceExpression] RepeatedSequenceExpression literalSequenceExpression
           * @property {org.ga4gh.vrs.v1.IDerivedSequenceExpression|null} [derivedSequenceExpression] RepeatedSequenceExpression derivedSequenceExpression
           * @property {org.ga4gh.vrs.v1.INumber|null} [number] RepeatedSequenceExpression number
           * @property {org.ga4gh.vrs.v1.IIndefiniteRange|null} [indefiniteRange] RepeatedSequenceExpression indefiniteRange
           * @property {org.ga4gh.vrs.v1.IDefiniteRange|null} [definiteRange] RepeatedSequenceExpression definiteRange
           */

          /**
           * Constructs a new RepeatedSequenceExpression.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a RepeatedSequenceExpression.
           * @implements IRepeatedSequenceExpression
           * @constructor
           * @param {org.ga4gh.vrs.v1.IRepeatedSequenceExpression=} [properties] Properties to set
           */
          function RepeatedSequenceExpression(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * RepeatedSequenceExpression literalSequenceExpression.
           * @member {org.ga4gh.vrs.v1.ILiteralSequenceExpression|null|undefined} literalSequenceExpression
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @instance
           */
          RepeatedSequenceExpression.prototype.literalSequenceExpression = null;

          /**
           * RepeatedSequenceExpression derivedSequenceExpression.
           * @member {org.ga4gh.vrs.v1.IDerivedSequenceExpression|null|undefined} derivedSequenceExpression
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @instance
           */
          RepeatedSequenceExpression.prototype.derivedSequenceExpression = null;

          /**
           * RepeatedSequenceExpression number.
           * @member {org.ga4gh.vrs.v1.INumber|null|undefined} number
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @instance
           */
          RepeatedSequenceExpression.prototype.number = null;

          /**
           * RepeatedSequenceExpression indefiniteRange.
           * @member {org.ga4gh.vrs.v1.IIndefiniteRange|null|undefined} indefiniteRange
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @instance
           */
          RepeatedSequenceExpression.prototype.indefiniteRange = null;

          /**
           * RepeatedSequenceExpression definiteRange.
           * @member {org.ga4gh.vrs.v1.IDefiniteRange|null|undefined} definiteRange
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @instance
           */
          RepeatedSequenceExpression.prototype.definiteRange = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * RepeatedSequenceExpression seqExpr.
           * @member {"literalSequenceExpression"|"derivedSequenceExpression"|undefined} seqExpr
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @instance
           */
          Object.defineProperty(
            RepeatedSequenceExpression.prototype,
            "seqExpr",
            {
              get: $util.oneOfGetter(
                ($oneOfFields = [
                  "literalSequenceExpression",
                  "derivedSequenceExpression",
                ]),
              ),
              set: $util.oneOfSetter($oneOfFields),
            },
          );

          /**
           * RepeatedSequenceExpression count.
           * @member {"number"|"indefiniteRange"|"definiteRange"|undefined} count
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @instance
           */
          Object.defineProperty(RepeatedSequenceExpression.prototype, "count", {
            get: $util.oneOfGetter(
              ($oneOfFields = ["number", "indefiniteRange", "definiteRange"]),
            ),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Creates a new RepeatedSequenceExpression instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.IRepeatedSequenceExpression=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.RepeatedSequenceExpression} RepeatedSequenceExpression instance
           */
          RepeatedSequenceExpression.create = function create(properties) {
            return new RepeatedSequenceExpression(properties);
          };

          /**
           * Encodes the specified RepeatedSequenceExpression message. Does not implicitly {@link org.ga4gh.vrs.v1.RepeatedSequenceExpression.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.IRepeatedSequenceExpression} message RepeatedSequenceExpression message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          RepeatedSequenceExpression.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.literalSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "literalSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.encode(
                message.literalSequenceExpression,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            if (
              message.derivedSequenceExpression != null &&
              Object.hasOwnProperty.call(message, "derivedSequenceExpression")
            )
              $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.encode(
                message.derivedSequenceExpression,
                writer.uint32(/* id 2, wireType 2 =*/ 18).fork(),
              ).ldelim();
            if (
              message.number != null &&
              Object.hasOwnProperty.call(message, "number")
            )
              $root.org.ga4gh.vrs.v1.Number.encode(
                message.number,
                writer.uint32(/* id 3, wireType 2 =*/ 26).fork(),
              ).ldelim();
            if (
              message.indefiniteRange != null &&
              Object.hasOwnProperty.call(message, "indefiniteRange")
            )
              $root.org.ga4gh.vrs.v1.IndefiniteRange.encode(
                message.indefiniteRange,
                writer.uint32(/* id 4, wireType 2 =*/ 34).fork(),
              ).ldelim();
            if (
              message.definiteRange != null &&
              Object.hasOwnProperty.call(message, "definiteRange")
            )
              $root.org.ga4gh.vrs.v1.DefiniteRange.encode(
                message.definiteRange,
                writer.uint32(/* id 5, wireType 2 =*/ 42).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified RepeatedSequenceExpression message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.RepeatedSequenceExpression.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.IRepeatedSequenceExpression} message RepeatedSequenceExpression message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          RepeatedSequenceExpression.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a RepeatedSequenceExpression message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.RepeatedSequenceExpression} RepeatedSequenceExpression
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          RepeatedSequenceExpression.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.literalSequenceExpression =
                    $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 2: {
                  message.derivedSequenceExpression =
                    $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 3: {
                  message.number = $root.org.ga4gh.vrs.v1.Number.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                case 4: {
                  message.indefiniteRange =
                    $root.org.ga4gh.vrs.v1.IndefiniteRange.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                case 5: {
                  message.definiteRange =
                    $root.org.ga4gh.vrs.v1.DefiniteRange.decode(
                      reader,
                      reader.uint32(),
                    );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a RepeatedSequenceExpression message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.RepeatedSequenceExpression} RepeatedSequenceExpression
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          RepeatedSequenceExpression.decodeDelimited = function decodeDelimited(
            reader,
          ) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a RepeatedSequenceExpression message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          RepeatedSequenceExpression.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (
              message.literalSequenceExpression != null &&
              message.hasOwnProperty("literalSequenceExpression")
            ) {
              properties.seqExpr = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.verify(
                    message.literalSequenceExpression,
                  );
                if (error) return "literalSequenceExpression." + error;
              }
            }
            if (
              message.derivedSequenceExpression != null &&
              message.hasOwnProperty("derivedSequenceExpression")
            ) {
              if (properties.seqExpr === 1) return "seqExpr: multiple values";
              properties.seqExpr = 1;
              {
                let error =
                  $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.verify(
                    message.derivedSequenceExpression,
                  );
                if (error) return "derivedSequenceExpression." + error;
              }
            }
            if (message.number != null && message.hasOwnProperty("number")) {
              properties.count = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Number.verify(
                  message.number,
                );
                if (error) return "number." + error;
              }
            }
            if (
              message.indefiniteRange != null &&
              message.hasOwnProperty("indefiniteRange")
            ) {
              if (properties.count === 1) return "count: multiple values";
              properties.count = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.IndefiniteRange.verify(
                  message.indefiniteRange,
                );
                if (error) return "indefiniteRange." + error;
              }
            }
            if (
              message.definiteRange != null &&
              message.hasOwnProperty("definiteRange")
            ) {
              if (properties.count === 1) return "count: multiple values";
              properties.count = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.DefiniteRange.verify(
                  message.definiteRange,
                );
                if (error) return "definiteRange." + error;
              }
            }
            return null;
          };

          /**
           * Creates a RepeatedSequenceExpression message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.RepeatedSequenceExpression} RepeatedSequenceExpression
           */
          RepeatedSequenceExpression.fromObject = function fromObject(object) {
            if (
              object instanceof
              $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression
            )
              return object;
            let message =
              new $root.org.ga4gh.vrs.v1.RepeatedSequenceExpression();
            if (object.literalSequenceExpression != null) {
              if (typeof object.literalSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.RepeatedSequenceExpression.literalSequenceExpression: object expected",
                );
              message.literalSequenceExpression =
                $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.fromObject(
                  object.literalSequenceExpression,
                );
            }
            if (object.derivedSequenceExpression != null) {
              if (typeof object.derivedSequenceExpression !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.RepeatedSequenceExpression.derivedSequenceExpression: object expected",
                );
              message.derivedSequenceExpression =
                $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.fromObject(
                  object.derivedSequenceExpression,
                );
            }
            if (object.number != null) {
              if (typeof object.number !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.RepeatedSequenceExpression.number: object expected",
                );
              message.number = $root.org.ga4gh.vrs.v1.Number.fromObject(
                object.number,
              );
            }
            if (object.indefiniteRange != null) {
              if (typeof object.indefiniteRange !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.RepeatedSequenceExpression.indefiniteRange: object expected",
                );
              message.indefiniteRange =
                $root.org.ga4gh.vrs.v1.IndefiniteRange.fromObject(
                  object.indefiniteRange,
                );
            }
            if (object.definiteRange != null) {
              if (typeof object.definiteRange !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.RepeatedSequenceExpression.definiteRange: object expected",
                );
              message.definiteRange =
                $root.org.ga4gh.vrs.v1.DefiniteRange.fromObject(
                  object.definiteRange,
                );
            }
            return message;
          };

          /**
           * Creates a plain object from a RepeatedSequenceExpression message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @static
           * @param {org.ga4gh.vrs.v1.RepeatedSequenceExpression} message RepeatedSequenceExpression
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          RepeatedSequenceExpression.toObject = function toObject(
            message,
            options,
          ) {
            if (!options) options = {};
            let object = {};
            if (
              message.literalSequenceExpression != null &&
              message.hasOwnProperty("literalSequenceExpression")
            ) {
              object.literalSequenceExpression =
                $root.org.ga4gh.vrs.v1.LiteralSequenceExpression.toObject(
                  message.literalSequenceExpression,
                  options,
                );
              if (options.oneofs) object.seqExpr = "literalSequenceExpression";
            }
            if (
              message.derivedSequenceExpression != null &&
              message.hasOwnProperty("derivedSequenceExpression")
            ) {
              object.derivedSequenceExpression =
                $root.org.ga4gh.vrs.v1.DerivedSequenceExpression.toObject(
                  message.derivedSequenceExpression,
                  options,
                );
              if (options.oneofs) object.seqExpr = "derivedSequenceExpression";
            }
            if (message.number != null && message.hasOwnProperty("number")) {
              object.number = $root.org.ga4gh.vrs.v1.Number.toObject(
                message.number,
                options,
              );
              if (options.oneofs) object.count = "number";
            }
            if (
              message.indefiniteRange != null &&
              message.hasOwnProperty("indefiniteRange")
            ) {
              object.indefiniteRange =
                $root.org.ga4gh.vrs.v1.IndefiniteRange.toObject(
                  message.indefiniteRange,
                  options,
                );
              if (options.oneofs) object.count = "indefiniteRange";
            }
            if (
              message.definiteRange != null &&
              message.hasOwnProperty("definiteRange")
            ) {
              object.definiteRange =
                $root.org.ga4gh.vrs.v1.DefiniteRange.toObject(
                  message.definiteRange,
                  options,
                );
              if (options.oneofs) object.count = "definiteRange";
            }
            return object;
          };

          /**
           * Converts this RepeatedSequenceExpression to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          RepeatedSequenceExpression.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for RepeatedSequenceExpression
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.RepeatedSequenceExpression
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          RepeatedSequenceExpression.getTypeUrl = function getTypeUrl(
            typeUrlPrefix,
          ) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return (
              typeUrlPrefix + "/org.ga4gh.vrs.v1.RepeatedSequenceExpression"
            );
          };

          return RepeatedSequenceExpression;
        })();

        v1.Feature = (function () {
          /**
           * Properties of a Feature.
           * @memberof org.ga4gh.vrs.v1
           * @interface IFeature
           * @property {org.ga4gh.vrs.v1.IGene|null} [gene] Feature gene
           */

          /**
           * Constructs a new Feature.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a Feature.
           * @implements IFeature
           * @constructor
           * @param {org.ga4gh.vrs.v1.IFeature=} [properties] Properties to set
           */
          function Feature(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Feature gene.
           * @member {org.ga4gh.vrs.v1.IGene|null|undefined} gene
           * @memberof org.ga4gh.vrs.v1.Feature
           * @instance
           */
          Feature.prototype.gene = null;

          // OneOf field names bound to virtual getters and setters
          let $oneOfFields;

          /**
           * Feature feature.
           * @member {"gene"|undefined} feature
           * @memberof org.ga4gh.vrs.v1.Feature
           * @instance
           */
          Object.defineProperty(Feature.prototype, "feature", {
            get: $util.oneOfGetter(($oneOfFields = ["gene"])),
            set: $util.oneOfSetter($oneOfFields),
          });

          /**
           * Creates a new Feature instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.Feature
           * @static
           * @param {org.ga4gh.vrs.v1.IFeature=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.Feature} Feature instance
           */
          Feature.create = function create(properties) {
            return new Feature(properties);
          };

          /**
           * Encodes the specified Feature message. Does not implicitly {@link org.ga4gh.vrs.v1.Feature.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.Feature
           * @static
           * @param {org.ga4gh.vrs.v1.IFeature} message Feature message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Feature.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.gene != null &&
              Object.hasOwnProperty.call(message, "gene")
            )
              $root.org.ga4gh.vrs.v1.Gene.encode(
                message.gene,
                writer.uint32(/* id 1, wireType 2 =*/ 10).fork(),
              ).ldelim();
            return writer;
          };

          /**
           * Encodes the specified Feature message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.Feature.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.Feature
           * @static
           * @param {org.ga4gh.vrs.v1.IFeature} message Feature message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Feature.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Feature message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.Feature
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.Feature} Feature
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Feature.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.Feature();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.gene = $root.org.ga4gh.vrs.v1.Gene.decode(
                    reader,
                    reader.uint32(),
                  );
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Feature message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.Feature
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.Feature} Feature
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Feature.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Feature message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.Feature
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Feature.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            let properties = {};
            if (message.gene != null && message.hasOwnProperty("gene")) {
              properties.feature = 1;
              {
                let error = $root.org.ga4gh.vrs.v1.Gene.verify(message.gene);
                if (error) return "gene." + error;
              }
            }
            return null;
          };

          /**
           * Creates a Feature message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.Feature
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.Feature} Feature
           */
          Feature.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.Feature) return object;
            let message = new $root.org.ga4gh.vrs.v1.Feature();
            if (object.gene != null) {
              if (typeof object.gene !== "object")
                throw TypeError(
                  ".org.ga4gh.vrs.v1.Feature.gene: object expected",
                );
              message.gene = $root.org.ga4gh.vrs.v1.Gene.fromObject(
                object.gene,
              );
            }
            return message;
          };

          /**
           * Creates a plain object from a Feature message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.Feature
           * @static
           * @param {org.ga4gh.vrs.v1.Feature} message Feature
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Feature.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (message.gene != null && message.hasOwnProperty("gene")) {
              object.gene = $root.org.ga4gh.vrs.v1.Gene.toObject(
                message.gene,
                options,
              );
              if (options.oneofs) object.feature = "gene";
            }
            return object;
          };

          /**
           * Converts this Feature to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.Feature
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Feature.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Feature
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.Feature
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Feature.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.Feature";
          };

          return Feature;
        })();

        v1.Gene = (function () {
          /**
           * Properties of a Gene.
           * @memberof org.ga4gh.vrs.v1
           * @interface IGene
           * @property {string|null} [geneId] Gene geneId
           */

          /**
           * Constructs a new Gene.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a Gene.
           * @implements IGene
           * @constructor
           * @param {org.ga4gh.vrs.v1.IGene=} [properties] Properties to set
           */
          function Gene(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Gene geneId.
           * @member {string} geneId
           * @memberof org.ga4gh.vrs.v1.Gene
           * @instance
           */
          Gene.prototype.geneId = "";

          /**
           * Creates a new Gene instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.Gene
           * @static
           * @param {org.ga4gh.vrs.v1.IGene=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.Gene} Gene instance
           */
          Gene.create = function create(properties) {
            return new Gene(properties);
          };

          /**
           * Encodes the specified Gene message. Does not implicitly {@link org.ga4gh.vrs.v1.Gene.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.Gene
           * @static
           * @param {org.ga4gh.vrs.v1.IGene} message Gene message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Gene.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.geneId != null &&
              Object.hasOwnProperty.call(message, "geneId")
            )
              writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.geneId);
            return writer;
          };

          /**
           * Encodes the specified Gene message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.Gene.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.Gene
           * @static
           * @param {org.ga4gh.vrs.v1.IGene} message Gene message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Gene.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Gene message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.Gene
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.Gene} Gene
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Gene.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.Gene();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.geneId = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Gene message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.Gene
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.Gene} Gene
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Gene.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Gene message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.Gene
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Gene.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.geneId != null && message.hasOwnProperty("geneId"))
              if (!$util.isString(message.geneId))
                return "geneId: string expected";
            return null;
          };

          /**
           * Creates a Gene message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.Gene
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.Gene} Gene
           */
          Gene.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.Gene) return object;
            let message = new $root.org.ga4gh.vrs.v1.Gene();
            if (object.geneId != null) message.geneId = String(object.geneId);
            return message;
          };

          /**
           * Creates a plain object from a Gene message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.Gene
           * @static
           * @param {org.ga4gh.vrs.v1.Gene} message Gene
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Gene.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) object.geneId = "";
            if (message.geneId != null && message.hasOwnProperty("geneId"))
              object.geneId = message.geneId;
            return object;
          };

          /**
           * Converts this Gene to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.Gene
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Gene.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Gene
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.Gene
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Gene.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.Gene";
          };

          return Gene;
        })();

        v1.Number = (function () {
          /**
           * Properties of a Number.
           * @memberof org.ga4gh.vrs.v1
           * @interface INumber
           * @property {number|Long|null} [value] Number value
           */

          /**
           * Constructs a new Number.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a Number.
           * @implements INumber
           * @constructor
           * @param {org.ga4gh.vrs.v1.INumber=} [properties] Properties to set
           */
          function Number(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * Number value.
           * @member {number|Long} value
           * @memberof org.ga4gh.vrs.v1.Number
           * @instance
           */
          Number.prototype.value = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;

          /**
           * Creates a new Number instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.Number
           * @static
           * @param {org.ga4gh.vrs.v1.INumber=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.Number} Number instance
           */
          Number.create = function create(properties) {
            return new Number(properties);
          };

          /**
           * Encodes the specified Number message. Does not implicitly {@link org.ga4gh.vrs.v1.Number.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.Number
           * @static
           * @param {org.ga4gh.vrs.v1.INumber} message Number message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Number.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.value != null &&
              Object.hasOwnProperty.call(message, "value")
            )
              writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.value);
            return writer;
          };

          /**
           * Encodes the specified Number message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.Number.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.Number
           * @static
           * @param {org.ga4gh.vrs.v1.INumber} message Number message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          Number.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a Number message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.Number
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.Number} Number
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Number.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.Number();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.value = reader.uint64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a Number message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.Number
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.Number} Number
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          Number.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a Number message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.Number
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          Number.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
              if (
                !$util.isInteger(message.value) &&
                !(
                  message.value &&
                  $util.isInteger(message.value.low) &&
                  $util.isInteger(message.value.high)
                )
              )
                return "value: integer|Long expected";
            return null;
          };

          /**
           * Creates a Number message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.Number
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.Number} Number
           */
          Number.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.Number) return object;
            let message = new $root.org.ga4gh.vrs.v1.Number();
            if (object.value != null)
              if ($util.Long)
                (message.value = $util.Long.fromValue(
                  object.value,
                )).unsigned = true;
              else if (typeof object.value === "string")
                message.value = parseInt(object.value, 10);
              else if (typeof object.value === "number")
                message.value = object.value;
              else if (typeof object.value === "object")
                message.value = new $util.LongBits(
                  object.value.low >>> 0,
                  object.value.high >>> 0,
                ).toNumber(true);
            return message;
          };

          /**
           * Creates a plain object from a Number message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.Number
           * @static
           * @param {org.ga4gh.vrs.v1.Number} message Number
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          Number.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults)
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.value =
                  options.longs === String
                    ? long.toString()
                    : options.longs === Number
                    ? long.toNumber()
                    : long;
              } else object.value = options.longs === String ? "0" : 0;
            if (message.value != null && message.hasOwnProperty("value"))
              if (typeof message.value === "number")
                object.value =
                  options.longs === String
                    ? String(message.value)
                    : message.value;
              else
                object.value =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.value)
                    : options.longs === Number
                    ? new $util.LongBits(
                        message.value.low >>> 0,
                        message.value.high >>> 0,
                      ).toNumber(true)
                    : message.value;
            return object;
          };

          /**
           * Converts this Number to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.Number
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          Number.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for Number
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.Number
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          Number.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.Number";
          };

          return Number;
        })();

        v1.IndefiniteRange = (function () {
          /**
           * Properties of an IndefiniteRange.
           * @memberof org.ga4gh.vrs.v1
           * @interface IIndefiniteRange
           * @property {number|Long|null} [value] IndefiniteRange value
           * @property {string|null} [comparator] IndefiniteRange comparator
           */

          /**
           * Constructs a new IndefiniteRange.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents an IndefiniteRange.
           * @implements IIndefiniteRange
           * @constructor
           * @param {org.ga4gh.vrs.v1.IIndefiniteRange=} [properties] Properties to set
           */
          function IndefiniteRange(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * IndefiniteRange value.
           * @member {number|Long} value
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @instance
           */
          IndefiniteRange.prototype.value = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;

          /**
           * IndefiniteRange comparator.
           * @member {string} comparator
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @instance
           */
          IndefiniteRange.prototype.comparator = "";

          /**
           * Creates a new IndefiniteRange instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @static
           * @param {org.ga4gh.vrs.v1.IIndefiniteRange=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.IndefiniteRange} IndefiniteRange instance
           */
          IndefiniteRange.create = function create(properties) {
            return new IndefiniteRange(properties);
          };

          /**
           * Encodes the specified IndefiniteRange message. Does not implicitly {@link org.ga4gh.vrs.v1.IndefiniteRange.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @static
           * @param {org.ga4gh.vrs.v1.IIndefiniteRange} message IndefiniteRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          IndefiniteRange.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.value != null &&
              Object.hasOwnProperty.call(message, "value")
            )
              writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.value);
            if (
              message.comparator != null &&
              Object.hasOwnProperty.call(message, "comparator")
            )
              writer
                .uint32(/* id 2, wireType 2 =*/ 18)
                .string(message.comparator);
            return writer;
          };

          /**
           * Encodes the specified IndefiniteRange message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.IndefiniteRange.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @static
           * @param {org.ga4gh.vrs.v1.IIndefiniteRange} message IndefiniteRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          IndefiniteRange.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes an IndefiniteRange message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.IndefiniteRange} IndefiniteRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          IndefiniteRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.IndefiniteRange();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.value = reader.uint64();
                  break;
                }
                case 2: {
                  message.comparator = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes an IndefiniteRange message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.IndefiniteRange} IndefiniteRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          IndefiniteRange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies an IndefiniteRange message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          IndefiniteRange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
              if (
                !$util.isInteger(message.value) &&
                !(
                  message.value &&
                  $util.isInteger(message.value.low) &&
                  $util.isInteger(message.value.high)
                )
              )
                return "value: integer|Long expected";
            if (
              message.comparator != null &&
              message.hasOwnProperty("comparator")
            )
              if (!$util.isString(message.comparator))
                return "comparator: string expected";
            return null;
          };

          /**
           * Creates an IndefiniteRange message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.IndefiniteRange} IndefiniteRange
           */
          IndefiniteRange.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.IndefiniteRange)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.IndefiniteRange();
            if (object.value != null)
              if ($util.Long)
                (message.value = $util.Long.fromValue(
                  object.value,
                )).unsigned = true;
              else if (typeof object.value === "string")
                message.value = parseInt(object.value, 10);
              else if (typeof object.value === "number")
                message.value = object.value;
              else if (typeof object.value === "object")
                message.value = new $util.LongBits(
                  object.value.low >>> 0,
                  object.value.high >>> 0,
                ).toNumber(true);
            if (object.comparator != null)
              message.comparator = String(object.comparator);
            return message;
          };

          /**
           * Creates a plain object from an IndefiniteRange message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @static
           * @param {org.ga4gh.vrs.v1.IndefiniteRange} message IndefiniteRange
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          IndefiniteRange.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.value =
                  options.longs === String
                    ? long.toString()
                    : options.longs === Number
                    ? long.toNumber()
                    : long;
              } else object.value = options.longs === String ? "0" : 0;
              object.comparator = "";
            }
            if (message.value != null && message.hasOwnProperty("value"))
              if (typeof message.value === "number")
                object.value =
                  options.longs === String
                    ? String(message.value)
                    : message.value;
              else
                object.value =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.value)
                    : options.longs === Number
                    ? new $util.LongBits(
                        message.value.low >>> 0,
                        message.value.high >>> 0,
                      ).toNumber(true)
                    : message.value;
            if (
              message.comparator != null &&
              message.hasOwnProperty("comparator")
            )
              object.comparator = message.comparator;
            return object;
          };

          /**
           * Converts this IndefiniteRange to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          IndefiniteRange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for IndefiniteRange
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.IndefiniteRange
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          IndefiniteRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.IndefiniteRange";
          };

          return IndefiniteRange;
        })();

        v1.DefiniteRange = (function () {
          /**
           * Properties of a DefiniteRange.
           * @memberof org.ga4gh.vrs.v1
           * @interface IDefiniteRange
           * @property {number|Long|null} [min] DefiniteRange min
           * @property {number|Long|null} [max] DefiniteRange max
           */

          /**
           * Constructs a new DefiniteRange.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a DefiniteRange.
           * @implements IDefiniteRange
           * @constructor
           * @param {org.ga4gh.vrs.v1.IDefiniteRange=} [properties] Properties to set
           */
          function DefiniteRange(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * DefiniteRange min.
           * @member {number|Long} min
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @instance
           */
          DefiniteRange.prototype.min = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;

          /**
           * DefiniteRange max.
           * @member {number|Long} max
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @instance
           */
          DefiniteRange.prototype.max = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;

          /**
           * Creates a new DefiniteRange instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @static
           * @param {org.ga4gh.vrs.v1.IDefiniteRange=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.DefiniteRange} DefiniteRange instance
           */
          DefiniteRange.create = function create(properties) {
            return new DefiniteRange(properties);
          };

          /**
           * Encodes the specified DefiniteRange message. Does not implicitly {@link org.ga4gh.vrs.v1.DefiniteRange.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @static
           * @param {org.ga4gh.vrs.v1.IDefiniteRange} message DefiniteRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DefiniteRange.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.min != null &&
              Object.hasOwnProperty.call(message, "min")
            )
              writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.min);
            if (
              message.max != null &&
              Object.hasOwnProperty.call(message, "max")
            )
              writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.max);
            return writer;
          };

          /**
           * Encodes the specified DefiniteRange message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.DefiniteRange.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @static
           * @param {org.ga4gh.vrs.v1.IDefiniteRange} message DefiniteRange message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          DefiniteRange.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a DefiniteRange message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.DefiniteRange} DefiniteRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DefiniteRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.DefiniteRange();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.min = reader.uint64();
                  break;
                }
                case 2: {
                  message.max = reader.uint64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a DefiniteRange message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.DefiniteRange} DefiniteRange
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          DefiniteRange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a DefiniteRange message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          DefiniteRange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.min != null && message.hasOwnProperty("min"))
              if (
                !$util.isInteger(message.min) &&
                !(
                  message.min &&
                  $util.isInteger(message.min.low) &&
                  $util.isInteger(message.min.high)
                )
              )
                return "min: integer|Long expected";
            if (message.max != null && message.hasOwnProperty("max"))
              if (
                !$util.isInteger(message.max) &&
                !(
                  message.max &&
                  $util.isInteger(message.max.low) &&
                  $util.isInteger(message.max.high)
                )
              )
                return "max: integer|Long expected";
            return null;
          };

          /**
           * Creates a DefiniteRange message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.DefiniteRange} DefiniteRange
           */
          DefiniteRange.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.DefiniteRange)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.DefiniteRange();
            if (object.min != null)
              if ($util.Long)
                (message.min = $util.Long.fromValue(
                  object.min,
                )).unsigned = true;
              else if (typeof object.min === "string")
                message.min = parseInt(object.min, 10);
              else if (typeof object.min === "number") message.min = object.min;
              else if (typeof object.min === "object")
                message.min = new $util.LongBits(
                  object.min.low >>> 0,
                  object.min.high >>> 0,
                ).toNumber(true);
            if (object.max != null)
              if ($util.Long)
                (message.max = $util.Long.fromValue(
                  object.max,
                )).unsigned = true;
              else if (typeof object.max === "string")
                message.max = parseInt(object.max, 10);
              else if (typeof object.max === "number") message.max = object.max;
              else if (typeof object.max === "object")
                message.max = new $util.LongBits(
                  object.max.low >>> 0,
                  object.max.high >>> 0,
                ).toNumber(true);
            return message;
          };

          /**
           * Creates a plain object from a DefiniteRange message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @static
           * @param {org.ga4gh.vrs.v1.DefiniteRange} message DefiniteRange
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          DefiniteRange.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.min =
                  options.longs === String
                    ? long.toString()
                    : options.longs === Number
                    ? long.toNumber()
                    : long;
              } else object.min = options.longs === String ? "0" : 0;
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.max =
                  options.longs === String
                    ? long.toString()
                    : options.longs === Number
                    ? long.toNumber()
                    : long;
              } else object.max = options.longs === String ? "0" : 0;
            }
            if (message.min != null && message.hasOwnProperty("min"))
              if (typeof message.min === "number")
                object.min =
                  options.longs === String ? String(message.min) : message.min;
              else
                object.min =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.min)
                    : options.longs === Number
                    ? new $util.LongBits(
                        message.min.low >>> 0,
                        message.min.high >>> 0,
                      ).toNumber(true)
                    : message.min;
            if (message.max != null && message.hasOwnProperty("max"))
              if (typeof message.max === "number")
                object.max =
                  options.longs === String ? String(message.max) : message.max;
              else
                object.max =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.max)
                    : options.longs === Number
                    ? new $util.LongBits(
                        message.max.low >>> 0,
                        message.max.high >>> 0,
                      ).toNumber(true)
                    : message.max;
            return object;
          };

          /**
           * Converts this DefiniteRange to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          DefiniteRange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for DefiniteRange
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.DefiniteRange
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          DefiniteRange.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.DefiniteRange";
          };

          return DefiniteRange;
        })();

        v1.SequenceState = (function () {
          /**
           * Properties of a SequenceState.
           * @memberof org.ga4gh.vrs.v1
           * @interface ISequenceState
           * @property {string|null} [sequence] SequenceState sequence
           */

          /**
           * Constructs a new SequenceState.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a SequenceState.
           * @implements ISequenceState
           * @constructor
           * @param {org.ga4gh.vrs.v1.ISequenceState=} [properties] Properties to set
           */
          function SequenceState(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * SequenceState sequence.
           * @member {string} sequence
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @instance
           */
          SequenceState.prototype.sequence = "";

          /**
           * Creates a new SequenceState instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceState=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.SequenceState} SequenceState instance
           */
          SequenceState.create = function create(properties) {
            return new SequenceState(properties);
          };

          /**
           * Encodes the specified SequenceState message. Does not implicitly {@link org.ga4gh.vrs.v1.SequenceState.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceState} message SequenceState message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SequenceState.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.sequence != null &&
              Object.hasOwnProperty.call(message, "sequence")
            )
              writer
                .uint32(/* id 1, wireType 2 =*/ 10)
                .string(message.sequence);
            return writer;
          };

          /**
           * Encodes the specified SequenceState message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.SequenceState.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @static
           * @param {org.ga4gh.vrs.v1.ISequenceState} message SequenceState message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SequenceState.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SequenceState message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.SequenceState} SequenceState
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SequenceState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.SequenceState();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.sequence = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SequenceState message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.SequenceState} SequenceState
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SequenceState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SequenceState message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SequenceState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.sequence != null && message.hasOwnProperty("sequence"))
              if (!$util.isString(message.sequence))
                return "sequence: string expected";
            return null;
          };

          /**
           * Creates a SequenceState message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.SequenceState} SequenceState
           */
          SequenceState.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.SequenceState)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.SequenceState();
            if (object.sequence != null)
              message.sequence = String(object.sequence);
            return message;
          };

          /**
           * Creates a plain object from a SequenceState message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @static
           * @param {org.ga4gh.vrs.v1.SequenceState} message SequenceState
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SequenceState.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) object.sequence = "";
            if (message.sequence != null && message.hasOwnProperty("sequence"))
              object.sequence = message.sequence;
            return object;
          };

          /**
           * Converts this SequenceState to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SequenceState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for SequenceState
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.SequenceState
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          SequenceState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.SequenceState";
          };

          return SequenceState;
        })();

        v1.SimpleInterval = (function () {
          /**
           * Properties of a SimpleInterval.
           * @memberof org.ga4gh.vrs.v1
           * @interface ISimpleInterval
           * @property {number|Long|null} [start] SimpleInterval start
           * @property {number|Long|null} [end] SimpleInterval end
           */

          /**
           * Constructs a new SimpleInterval.
           * @memberof org.ga4gh.vrs.v1
           * @classdesc Represents a SimpleInterval.
           * @implements ISimpleInterval
           * @constructor
           * @param {org.ga4gh.vrs.v1.ISimpleInterval=} [properties] Properties to set
           */
          function SimpleInterval(properties) {
            if (properties)
              for (
                let keys = Object.keys(properties), i = 0;
                i < keys.length;
                ++i
              )
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
          }

          /**
           * SimpleInterval start.
           * @member {number|Long} start
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @instance
           */
          SimpleInterval.prototype.start = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;

          /**
           * SimpleInterval end.
           * @member {number|Long} end
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @instance
           */
          SimpleInterval.prototype.end = $util.Long
            ? $util.Long.fromBits(0, 0, true)
            : 0;

          /**
           * Creates a new SimpleInterval instance using the specified properties.
           * @function create
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @static
           * @param {org.ga4gh.vrs.v1.ISimpleInterval=} [properties] Properties to set
           * @returns {org.ga4gh.vrs.v1.SimpleInterval} SimpleInterval instance
           */
          SimpleInterval.create = function create(properties) {
            return new SimpleInterval(properties);
          };

          /**
           * Encodes the specified SimpleInterval message. Does not implicitly {@link org.ga4gh.vrs.v1.SimpleInterval.verify|verify} messages.
           * @function encode
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @static
           * @param {org.ga4gh.vrs.v1.ISimpleInterval} message SimpleInterval message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SimpleInterval.encode = function encode(message, writer) {
            if (!writer) writer = $Writer.create();
            if (
              message.start != null &&
              Object.hasOwnProperty.call(message, "start")
            )
              writer.uint32(/* id 1, wireType 0 =*/ 8).uint64(message.start);
            if (
              message.end != null &&
              Object.hasOwnProperty.call(message, "end")
            )
              writer.uint32(/* id 2, wireType 0 =*/ 16).uint64(message.end);
            return writer;
          };

          /**
           * Encodes the specified SimpleInterval message, length delimited. Does not implicitly {@link org.ga4gh.vrs.v1.SimpleInterval.verify|verify} messages.
           * @function encodeDelimited
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @static
           * @param {org.ga4gh.vrs.v1.ISimpleInterval} message SimpleInterval message or plain object to encode
           * @param {$protobuf.Writer} [writer] Writer to encode to
           * @returns {$protobuf.Writer} Writer
           */
          SimpleInterval.encodeDelimited = function encodeDelimited(
            message,
            writer,
          ) {
            return this.encode(message, writer).ldelim();
          };

          /**
           * Decodes a SimpleInterval message from the specified reader or buffer.
           * @function decode
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @param {number} [length] Message length if known beforehand
           * @returns {org.ga4gh.vrs.v1.SimpleInterval} SimpleInterval
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SimpleInterval.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length,
              message = new $root.org.ga4gh.vrs.v1.SimpleInterval();
            while (reader.pos < end) {
              let tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.start = reader.uint64();
                  break;
                }
                case 2: {
                  message.end = reader.uint64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };

          /**
           * Decodes a SimpleInterval message from the specified reader or buffer, length delimited.
           * @function decodeDelimited
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @static
           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
           * @returns {org.ga4gh.vrs.v1.SimpleInterval} SimpleInterval
           * @throws {Error} If the payload is not a reader or valid buffer
           * @throws {$protobuf.util.ProtocolError} If required fields are missing
           */
          SimpleInterval.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader)) reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };

          /**
           * Verifies a SimpleInterval message.
           * @function verify
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @static
           * @param {Object.<string,*>} message Plain object to verify
           * @returns {string|null} `null` if valid, otherwise the reason why it is not
           */
          SimpleInterval.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.start != null && message.hasOwnProperty("start"))
              if (
                !$util.isInteger(message.start) &&
                !(
                  message.start &&
                  $util.isInteger(message.start.low) &&
                  $util.isInteger(message.start.high)
                )
              )
                return "start: integer|Long expected";
            if (message.end != null && message.hasOwnProperty("end"))
              if (
                !$util.isInteger(message.end) &&
                !(
                  message.end &&
                  $util.isInteger(message.end.low) &&
                  $util.isInteger(message.end.high)
                )
              )
                return "end: integer|Long expected";
            return null;
          };

          /**
           * Creates a SimpleInterval message from a plain object. Also converts values to their respective internal types.
           * @function fromObject
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @static
           * @param {Object.<string,*>} object Plain object
           * @returns {org.ga4gh.vrs.v1.SimpleInterval} SimpleInterval
           */
          SimpleInterval.fromObject = function fromObject(object) {
            if (object instanceof $root.org.ga4gh.vrs.v1.SimpleInterval)
              return object;
            let message = new $root.org.ga4gh.vrs.v1.SimpleInterval();
            if (object.start != null)
              if ($util.Long)
                (message.start = $util.Long.fromValue(
                  object.start,
                )).unsigned = true;
              else if (typeof object.start === "string")
                message.start = parseInt(object.start, 10);
              else if (typeof object.start === "number")
                message.start = object.start;
              else if (typeof object.start === "object")
                message.start = new $util.LongBits(
                  object.start.low >>> 0,
                  object.start.high >>> 0,
                ).toNumber(true);
            if (object.end != null)
              if ($util.Long)
                (message.end = $util.Long.fromValue(
                  object.end,
                )).unsigned = true;
              else if (typeof object.end === "string")
                message.end = parseInt(object.end, 10);
              else if (typeof object.end === "number") message.end = object.end;
              else if (typeof object.end === "object")
                message.end = new $util.LongBits(
                  object.end.low >>> 0,
                  object.end.high >>> 0,
                ).toNumber(true);
            return message;
          };

          /**
           * Creates a plain object from a SimpleInterval message. Also converts values to other types if specified.
           * @function toObject
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @static
           * @param {org.ga4gh.vrs.v1.SimpleInterval} message SimpleInterval
           * @param {$protobuf.IConversionOptions} [options] Conversion options
           * @returns {Object.<string,*>} Plain object
           */
          SimpleInterval.toObject = function toObject(message, options) {
            if (!options) options = {};
            let object = {};
            if (options.defaults) {
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.start =
                  options.longs === String
                    ? long.toString()
                    : options.longs === Number
                    ? long.toNumber()
                    : long;
              } else object.start = options.longs === String ? "0" : 0;
              if ($util.Long) {
                let long = new $util.Long(0, 0, true);
                object.end =
                  options.longs === String
                    ? long.toString()
                    : options.longs === Number
                    ? long.toNumber()
                    : long;
              } else object.end = options.longs === String ? "0" : 0;
            }
            if (message.start != null && message.hasOwnProperty("start"))
              if (typeof message.start === "number")
                object.start =
                  options.longs === String
                    ? String(message.start)
                    : message.start;
              else
                object.start =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.start)
                    : options.longs === Number
                    ? new $util.LongBits(
                        message.start.low >>> 0,
                        message.start.high >>> 0,
                      ).toNumber(true)
                    : message.start;
            if (message.end != null && message.hasOwnProperty("end"))
              if (typeof message.end === "number")
                object.end =
                  options.longs === String ? String(message.end) : message.end;
              else
                object.end =
                  options.longs === String
                    ? $util.Long.prototype.toString.call(message.end)
                    : options.longs === Number
                    ? new $util.LongBits(
                        message.end.low >>> 0,
                        message.end.high >>> 0,
                      ).toNumber(true)
                    : message.end;
            return object;
          };

          /**
           * Converts this SimpleInterval to JSON.
           * @function toJSON
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @instance
           * @returns {Object.<string,*>} JSON object
           */
          SimpleInterval.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(
              this,
              $protobuf.util.toJSONOptions,
            );
          };

          /**
           * Gets the default type url for SimpleInterval
           * @function getTypeUrl
           * @memberof org.ga4gh.vrs.v1.SimpleInterval
           * @static
           * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
           * @returns {string} The default type url
           */
          SimpleInterval.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/org.ga4gh.vrs.v1.SimpleInterval";
          };

          return SimpleInterval;
        })();

        return v1;
      })();

      return vrs;
    })();

    return ga4gh;
  })();

  return org;
})());

export const google = ($root.google = (() => {
  /**
   * Namespace google.
   * @exports google
   * @namespace
   */
  const google = {};

  google.protobuf = (function () {
    /**
     * Namespace protobuf.
     * @memberof google
     * @namespace
     */
    const protobuf = {};

    protobuf.Timestamp = (function () {
      /**
       * Properties of a Timestamp.
       * @memberof google.protobuf
       * @interface ITimestamp
       * @property {number|Long|null} [seconds] Timestamp seconds
       * @property {number|null} [nanos] Timestamp nanos
       */

      /**
       * Constructs a new Timestamp.
       * @memberof google.protobuf
       * @classdesc Represents a Timestamp.
       * @implements ITimestamp
       * @constructor
       * @param {google.protobuf.ITimestamp=} [properties] Properties to set
       */
      function Timestamp(properties) {
        if (properties)
          for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
      }

      /**
       * Timestamp seconds.
       * @member {number|Long} seconds
       * @memberof google.protobuf.Timestamp
       * @instance
       */
      Timestamp.prototype.seconds = $util.Long
        ? $util.Long.fromBits(0, 0, false)
        : 0;

      /**
       * Timestamp nanos.
       * @member {number} nanos
       * @memberof google.protobuf.Timestamp
       * @instance
       */
      Timestamp.prototype.nanos = 0;

      /**
       * Creates a new Timestamp instance using the specified properties.
       * @function create
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {google.protobuf.ITimestamp=} [properties] Properties to set
       * @returns {google.protobuf.Timestamp} Timestamp instance
       */
      Timestamp.create = function create(properties) {
        return new Timestamp(properties);
      };

      /**
       * Encodes the specified Timestamp message. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
       * @function encode
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Timestamp.encode = function encode(message, writer) {
        if (!writer) writer = $Writer.create();
        if (
          message.seconds != null &&
          Object.hasOwnProperty.call(message, "seconds")
        )
          writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.seconds);
        if (
          message.nanos != null &&
          Object.hasOwnProperty.call(message, "nanos")
        )
          writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.nanos);
        return writer;
      };

      /**
       * Encodes the specified Timestamp message, length delimited. Does not implicitly {@link google.protobuf.Timestamp.verify|verify} messages.
       * @function encodeDelimited
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {google.protobuf.ITimestamp} message Timestamp message or plain object to encode
       * @param {$protobuf.Writer} [writer] Writer to encode to
       * @returns {$protobuf.Writer} Writer
       */
      Timestamp.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };

      /**
       * Decodes a Timestamp message from the specified reader or buffer.
       * @function decode
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @param {number} [length] Message length if known beforehand
       * @returns {google.protobuf.Timestamp} Timestamp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Timestamp.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length,
          message = new $root.google.protobuf.Timestamp();
        while (reader.pos < end) {
          let tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              message.seconds = reader.int64();
              break;
            }
            case 2: {
              message.nanos = reader.int32();
              break;
            }
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };

      /**
       * Decodes a Timestamp message from the specified reader or buffer, length delimited.
       * @function decodeDelimited
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
       * @returns {google.protobuf.Timestamp} Timestamp
       * @throws {Error} If the payload is not a reader or valid buffer
       * @throws {$protobuf.util.ProtocolError} If required fields are missing
       */
      Timestamp.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader)) reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };

      /**
       * Verifies a Timestamp message.
       * @function verify
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {Object.<string,*>} message Plain object to verify
       * @returns {string|null} `null` if valid, otherwise the reason why it is not
       */
      Timestamp.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.seconds != null && message.hasOwnProperty("seconds"))
          if (
            !$util.isInteger(message.seconds) &&
            !(
              message.seconds &&
              $util.isInteger(message.seconds.low) &&
              $util.isInteger(message.seconds.high)
            )
          )
            return "seconds: integer|Long expected";
        if (message.nanos != null && message.hasOwnProperty("nanos"))
          if (!$util.isInteger(message.nanos)) return "nanos: integer expected";
        return null;
      };

      /**
       * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
       * @function fromObject
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {Object.<string,*>} object Plain object
       * @returns {google.protobuf.Timestamp} Timestamp
       */
      Timestamp.fromObject = function fromObject(object) {
        if (object instanceof $root.google.protobuf.Timestamp) return object;
        let message = new $root.google.protobuf.Timestamp();
        if (object.seconds != null)
          if ($util.Long)
            (message.seconds = $util.Long.fromValue(
              object.seconds,
            )).unsigned = false;
          else if (typeof object.seconds === "string")
            message.seconds = parseInt(object.seconds, 10);
          else if (typeof object.seconds === "number")
            message.seconds = object.seconds;
          else if (typeof object.seconds === "object")
            message.seconds = new $util.LongBits(
              object.seconds.low >>> 0,
              object.seconds.high >>> 0,
            ).toNumber();
        if (object.nanos != null) message.nanos = object.nanos | 0;
        return message;
      };

      /**
       * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
       * @function toObject
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {google.protobuf.Timestamp} message Timestamp
       * @param {$protobuf.IConversionOptions} [options] Conversion options
       * @returns {Object.<string,*>} Plain object
       */
      Timestamp.toObject = function toObject(message, options) {
        if (!options) options = {};
        let object = {};
        if (options.defaults) {
          if ($util.Long) {
            let long = new $util.Long(0, 0, false);
            object.seconds =
              options.longs === String
                ? long.toString()
                : options.longs === Number
                ? long.toNumber()
                : long;
          } else object.seconds = options.longs === String ? "0" : 0;
          object.nanos = 0;
        }
        if (message.seconds != null && message.hasOwnProperty("seconds"))
          if (typeof message.seconds === "number")
            object.seconds =
              options.longs === String
                ? String(message.seconds)
                : message.seconds;
          else
            object.seconds =
              options.longs === String
                ? $util.Long.prototype.toString.call(message.seconds)
                : options.longs === Number
                ? new $util.LongBits(
                    message.seconds.low >>> 0,
                    message.seconds.high >>> 0,
                  ).toNumber()
                : message.seconds;
        if (message.nanos != null && message.hasOwnProperty("nanos"))
          object.nanos = message.nanos;
        return object;
      };

      /**
       * Converts this Timestamp to JSON.
       * @function toJSON
       * @memberof google.protobuf.Timestamp
       * @instance
       * @returns {Object.<string,*>} JSON object
       */
      Timestamp.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };

      /**
       * Gets the default type url for Timestamp
       * @function getTypeUrl
       * @memberof google.protobuf.Timestamp
       * @static
       * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
       * @returns {string} The default type url
       */
      Timestamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
        if (typeUrlPrefix === undefined) {
          typeUrlPrefix = "type.googleapis.com";
        }
        return typeUrlPrefix + "/google.protobuf.Timestamp";
      };

      return Timestamp;
    })();

    return protobuf;
  })();

  return google;
})());
