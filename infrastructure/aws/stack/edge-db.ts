import {
  aws_ec2 as ec2,
  aws_route53 as route53,
  aws_secretsmanager as secretsmanager,
  CfnOutput,
  Duration,
  NestedStack,
  StackProps,
} from "aws-cdk-lib";
import { Construct } from "constructs";
import { ServerlessBaseDatabase } from "../lib/rds/serverless-base-database";
import { Protocol } from "aws-cdk-lib/aws-elasticloadbalancingv2";
import { StringParameter } from "aws-cdk-lib/aws-ssm";
import { Certificate } from "aws-cdk-lib/aws-certificatemanager";
import { HostedZone } from "aws-cdk-lib/aws-route53";
import { EdgeDbServiceConstruct } from "./edge-db-service-construct";
import { EdgeDbLoadBalancerConstruct } from "./edge-db-load-balancer-construct";

interface Props extends StackProps {
  vpc: ec2.IVpc;
  hostedZone: route53.IHostedZone;
  config: {
    // if set to true - changes the behaviour of most resources to be publicly accessible (still secure though)
    isDevelopment?: boolean;

    // the configuration of the postgres instance which EdgeDb wraps
    baseDatabase: {
      // type: "serverless" | "instance";
      dbAdminUser: string;
      dbName: string;
    };
    // the configuration of the fargate service that is edge db itself
    edgeDbService: {
      superUser: string;
      desiredCount: number;
      cpu: number;
      memory: number;
    };
    // the configuration of the network load balancer sitting in front of edge db
    edgeDbLoadBalancer: {
      port: number;
    };
  };
}

export class EdgeDbStack extends NestedStack {
  private readonly _dsn: string;

  constructor(scope: Construct, id: string, props: Props) {
    super(scope, id, props);

    const vpc = props.vpc;
    const hostedZone = props.hostedZone;
    const config = props.config;

    // create a new secret for our base database with an autogenerated password
    const baseDbSecret = new secretsmanager.Secret(this, "BaseDbSecret", {
      generateSecretString: {
        excludePunctuation: true,
        secretStringTemplate: JSON.stringify({
          username: config.baseDatabase.dbAdminUser,
          password: "",
        }),
        generateStringKey: "password",
      },
    });

    // create a new secret for our edge db database with an autogenerated password
    const edgeDbSecret = new secretsmanager.Secret(this, "EdgeDbSecret", {
      generateSecretString: {
        excludePunctuation: true,
      },
    });

    const baseDb = new ServerlessBaseDatabase(this, "BaseDb", {
      isDevelopment: config.isDevelopment,
      vpc: vpc,
      databaseName: props.config.baseDatabase.dbName,
      secret: baseDbSecret,
    });

    const edgeDbService = new EdgeDbServiceConstruct(this, "EdgeDbService", {
      isDevelopment: config.isDevelopment,
      vpc: vpc,
      baseDbDsn: baseDb.dsn,
      desiredCount: config.edgeDbService.desiredCount,
      cpu: config.edgeDbService.cpu,
      memory: config.edgeDbService.memory,
      superUser: config.edgeDbService.superUser,
      superUserSecret: edgeDbSecret,
      edgeDbVersion: "2.3",
    });

    if (config.isDevelopment) {
      baseDb.connections().allowDefaultPortFromAnyIpv4();
    } else {
      baseDb.connections().allowDefaultPortFrom(edgeDbService.service);
    }

    edgeDbService.service.connections.allowFromAnyIpv4(
      ec2.Port.tcp(edgeDbService.servicePort)
    );

    // TODO: set all this name stuff from outside
    const hostedPrefix = "elsa-edge-db";
    // we have been passed in the values of an existing SSL cert and domain name in Route 53
    // need to make CDK handles for them via lookups
    const certificate = Certificate.fromCertificateArn(
      this,
      "SslCert",
      StringParameter.valueFromLookup(this, "cert_apse2_arn")
    );
    const domainZone = HostedZone.fromLookup(this, "Zone", {
      domainName: StringParameter.valueFromLookup(this, "hosted_zone_name"),
    });

    const edgeDbLoadBalancer = new EdgeDbLoadBalancerConstruct(
      this,
      "EdgeDbLoadBalancer",
      {
        isDevelopment: config.isDevelopment,
        vpc: vpc,
        port: config.edgeDbLoadBalancer.port,
        service: edgeDbService.service,
        servicePort: edgeDbService.servicePort,
        hostedPrefix: hostedPrefix,
        hostedZone: hostedZone,
        hostedCertificate: certificate,
        serviceHealthCheck: {
          enabled: true,
          healthyThresholdCount: 2,
          unhealthyThresholdCount: 2,
          protocol: Protocol.HTTPS,
          path: "/server/status/ready",
          interval: Duration.seconds(10),
        },
      }
    );

    // for the moment we are going with the flow of using the default edgedb database name.. if we go multi tenant etc
    // then we'd have to bring in this as a real variable
    const defaultEdgeDbName = "edgedb";

    this._dsn = `https://${
      config.edgeDbService.superUser
    }:${edgeDbSecret.secretValue.unsafeUnwrap()}@${hostedPrefix}.${
      domainZone.zoneName
    }:${config.edgeDbLoadBalancer.port}/${defaultEdgeDbName}`;

    new CfnOutput(this, "EdgeDbUrl", {
      value: `https://${config.edgeDbService.superUser}@${hostedPrefix}.${domainZone.zoneName}:${config.edgeDbLoadBalancer.port}/${defaultEdgeDbName}`,
    });

    new CfnOutput(this, "BaseDatabaseUrl", {
      value: `postgres://${config.baseDatabase.dbAdminUser}@${baseDb.hostname}:${baseDb.port}/${config.baseDatabase.dbName}`,
    });

    // only in development mode is the UI switched on and accessible
    if (config.isDevelopment) {
      new CfnOutput(this, "EdgeDbUiLogin", {
        value: `https://${hostedPrefix}.${domainZone.zoneName}:${config.edgeDbLoadBalancer.port}/ui/_login`,
      });
    }
  }

  public get dsnForEnvironmentVariable(): string {
    return this._dsn;
  }
}
